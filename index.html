<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.13.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Keep Running">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Keep Running">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="华">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Keep Running</title>
  






  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Keep Running</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="华"
      src="/images/Avatar.png">
  <p class="site-author-name" itemprop="name">华</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/HBlogs" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;HBlogs" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/2575861939@qq.com" title="E-Mail → 2575861939@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/06/bigworld_03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Avatar.png">
      <meta itemprop="name" content="华">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keep Running">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Keep Running">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/11/06/bigworld_03/" class="post-title-link" itemprop="url">BIGWORLD 客户端Tutorial</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-11-06 11:20:31" itemprop="dateCreated datePublished" datetime="2024-11-06T11:20:31+08:00">2024-11-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-11-07 08:59:47" itemprop="dateModified" datetime="2022-11-07T08:59:47+08:00">2022-11-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/BigWorld/" itemprop="url" rel="index"><span itemprop="name">BigWorld</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="BIGWORLD-03–Tutorial"><a href="#BIGWORLD-03–Tutorial" class="headerlink" title="BIGWORLD_03–Tutorial"></a>BIGWORLD_03–Tutorial</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>本教程简要概述了从头开始制作一款基本游戏所需的最低步骤。第一次与BigWorld合作的游戏开发者和技术美工应该通过本教程了解如何将各种文件和目录组合在一起，从而制作出一款有效的游戏。</p>
<h3 id="1-1常规"><a href="#1-1常规" class="headerlink" title="1.1常规"></a>1.1常规</h3><h4 id="1-1-1-文件和目录"><a href="#1-1-1-文件和目录" class="headerlink" title="1.1.1 文件和目录"></a>1.1.1 文件和目录</h4><p>统一以&#x2F;划分层级，例如 &lt;res&gt;&#x2F;scripts&#x2F;db.xml,而不是 &lt;res&gt;\scripts\db.xml。</p>
<h4 id="1-1-2-提供的文件"><a href="#1-1-2-提供的文件" class="headerlink" title="1.1.2 提供的文件"></a>1.1.2 提供的文件</h4><p>本教程中使用的所有文件都在BigWorld包的教程目录中。</p>
<h4 id="1-1-3-Debugging"><a href="#1-1-3-Debugging" class="headerlink" title="1.1.3 Debugging"></a>1.1.3 Debugging</h4><p>在学习本教程时，由于脚本中的某些错误，客户端可能无法启动。为了发现错误的原因，使用诸如DebugView(可以在微软网站上找到)这样的程序，它捕获并显示调试输出。</p>
<h2 id="2-一个基本的仅限客户端的游戏"><a href="#2-一个基本的仅限客户端的游戏" class="headerlink" title="2. 一个基本的仅限客户端的游戏"></a>2. 一个基本的仅限客户端的游戏</h2><p>本章描述如何启动一个基本的客户机，并使用它自己的资源和脚本运行。这涉及到:</p>
<ul>
<li>创建一个新的BigWorld项目目录。</li>
<li>创建定义单个客户端播放器实体所需的文件和目录。</li>
<li>创造一个新的空间。<br>在本部分教程的最后，我们将能够使用第一人称视角在客户端中行走。</li>
</ul>
<h3 id="2-1-创建新的项目"><a href="#2-1-创建新的项目" class="headerlink" title="2.1 创建新的项目"></a>2.1 创建新的项目</h3><p>FantasyDemo项目位于C:\BigWorld的FantasyDemo目录中。按照这个约定，我们将在同一个目录中启动新的教程项目，方法是在C:\BigWorld中创建一个名为tutorial的新目录。所有特定于此项目的资源和脚本都将位于此目录中。</p>
<h3 id="2-2-定义资源路径"><a href="#2-2-定义资源路径" class="headerlink" title="2.2 定义资源路径"></a>2.2 定义资源路径</h3><h3 id="2-3-创建资源目录"><a href="#2-3-创建资源目录" class="headerlink" title="2.3 创建资源目录"></a>2.3 创建资源目录</h3><p>在tutorial中创建res目录，这个顶级资源目录将包含所有游戏特定的脚本、资产和配置文件。</p>
<h3 id="2-4-创建第一个实体"><a href="#2-4-创建第一个实体" class="headerlink" title="2.4 创建第一个实体"></a>2.4 创建第一个实体</h3><p>实体是具有位置的游戏对象。实体的例子包括玩家、npc、聊天室、掉落物品等….</p>
<h4 id="2-4-1-entities-xml"><a href="#2-4-1-entities-xml" class="headerlink" title="2.4.1 entities.xml"></a>2.4.1 entities.xml</h4><p>实例脚本必须位于res&#x2F;scripts中，<br>在tutorial&#x2F;res&#x2F;scripts&#x2F;entities.xml文件中写入：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ClientServerEntities</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Avatar</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ClientServerEntities</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ServerOnlyEntities</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ServerOnlyEntities</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="2-4-2-定义Avatar实体类型"><a href="#2-4-2-定义Avatar实体类型" class="headerlink" title="2.4.2 定义Avatar实体类型"></a>2.4.2 定义Avatar实体类型</h4><p>另一个必须存在的目录是res&#x2F;scripts&#x2F;entity_defs，其中包含.def文件包含每个实体的属性和方法的定义。</p>
<p>将这些定义文件想象成类似于C&#x2F;C++头文件可能会有所帮助，因为它们指定了附加到实体的属性类型和方法调用。<br>在tutorial&#x2F;res&#x2F;scripts&#x2F;entity_defs&#x2F;Avatar.def文件中写入以下内容：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Volatile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">position</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">yaw</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Volatile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">playerName</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Type</span>&gt;</span> UNICODE_STRING <span class="tag">&lt;/<span class="name">Type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Flags</span>&gt;</span> ALL_CLIENTS <span class="tag">&lt;/<span class="name">Flags</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">playerName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ClientMethods</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ClientMethods</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">CellMethods</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">CellMethods</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">BaseMethods</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">BaseMethods</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这是一个非常基本的实体定义，它定义了实体的属性，但没有方法。注意，属性被分为两部分:volatile和非volatile。</p>
<h4 id="2-4-2-1-Volatile-properties"><a href="#2-4-2-1-Volatile-properties" class="headerlink" title="2.4.2.1 Volatile properties"></a>2.4.2.1 Volatile properties</h4><p>对于BigWorld实体，volatile属性是位置&#x2F;方向属性。它们之所以被描述为不稳定的，是因为它们在不断地变化。volatile属性的当前值只被认为是重要的，而属性的历史变化则不那么重要。在带宽受限的环境中，只发送当前值。</p>
<h4 id="2-4-2-2-Non-volatile-properties"><a href="#2-4-2-2-Non-volatile-properties" class="headerlink" title="2.4.2.2 Non-volatile properties"></a>2.4.2.2 Non-volatile properties</h4><p>与volatile属性相比，常规属性的更改频率较低，因此对特定属性的所有更改都应该发送到客户机。每个属性都可以按照您的意愿命名，并且可以附加许多不同的设置。</p>
<h4 id="2-4-3-实现Avatar实体类型"><a href="#2-4-3-实现Avatar实体类型" class="headerlink" title="2.4.3 实现Avatar实体类型"></a>2.4.3 实现Avatar实体类型</h4><p>在 tutorial&#x2F;res&#x2F;scripts目录中创建base,cell,client文件夹，其中base和cell是控制服务端实体脚本文件夹，client是客户端实体脚本文件夹。</p>
<p>创建脚本tutorial&#x2F;res&#x2F;scripts&#x2F;client&#x2F;Avatar.py，并写入：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">import</span> BigWorld</span><br><span class="line"><span class="comment"># These are constants for identifying keypresses, mouse movement etc</span></span><br><span class="line"><span class="keyword">import</span> Keys</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Avatar</span>( BigWorld.Entity ):</span><br><span class="line"> 	<span class="keyword">def</span> <span class="title function_">onEnterWorld</span>(<span class="params"> self, prereqs </span>):</span><br><span class="line"> 		<span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PlayerAvatar</span>( <span class="title class_ inherited__">Avatar</span> ):</span><br><span class="line"> 	<span class="keyword">def</span> <span class="title function_">onEnterWorld</span>(<span class="params"> self, prereqs </span>):</span><br><span class="line"> 		Avatar.onEnterWorld( self, prereqs )</span><br><span class="line"> 		<span class="comment"># Set the position/movement filter to correspond to an player avatar</span></span><br><span class="line">		self.<span class="built_in">filter</span> = BigWorld.PlayerAvatarFilter()</span><br><span class="line">		<span class="comment"># Setup the physics for the Avatar</span></span><br><span class="line">		self.physics = BigWorld.STANDARD_PHYSICS</span><br><span class="line">		self.physics.velocityMouse = <span class="string">&quot;Direction&quot;</span></span><br><span class="line">		self.physics.collide = <span class="literal">True</span></span><br><span class="line">		self.physics.fall = <span class="literal">True</span></span><br><span class="line"> 	<span class="keyword">def</span> <span class="title function_">handleKeyEvent</span>(<span class="params"> self, event </span>):</span><br><span class="line">		 <span class="comment"># Get the current velocity</span></span><br><span class="line">		v = self.physics.velocity</span><br><span class="line">		<span class="comment"># Update the velocity depending on the key input</span></span><br><span class="line">		<span class="keyword">if</span> event.key == Keys.KEY_W:</span><br><span class="line">			v.z = event.isKeyDown() * <span class="number">5.0</span></span><br><span class="line">		<span class="keyword">elif</span> event.key == Keys.KEY_S:</span><br><span class="line">			v.z = event.isKeyDown() * -<span class="number">5.0</span></span><br><span class="line">		<span class="keyword">elif</span> event.key == Keys.KEY_A:</span><br><span class="line">			v.x = event.isKeyDown() * -<span class="number">5.0</span></span><br><span class="line">		<span class="keyword">elif</span> event.key == Keys.KEY_D:</span><br><span class="line">			v.x = event.isKeyDown() * <span class="number">5.0</span></span><br><span class="line">			self.physics.velocity = v</span><br><span class="line"> 		<span class="comment"># Save back the new velocity</span></span><br></pre></td></tr></table></figure>
<h3 id="2-5-独立脚本（The-personality-script）"><a href="#2-5-独立脚本（The-personality-script）" class="headerlink" title="2.5 独立脚本（The personality script）"></a>2.5 独立脚本（The personality script）</h3><p>我们的基本客户端的下一个必需脚本是个性脚本。最简单的方法是把这个脚本看作BigWorld系统每个组件的引导脚本。<br>创建并保存以下脚本tutorial&#x2F;res&#x2F;scripts&#x2F;client&#x2F;BWPersonality.py:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是BigWorld教程的客户端个性脚本。</span></span><br><span class="line"><span class="comment"># 可以将其视为客户机的引导脚本。它包含的函数</span></span><br><span class="line"><span class="comment"># 在各种输入事件的初始化、关闭和处理程序时调用。</span></span><br><span class="line"><span class="keyword">import</span> BigWorld</span><br><span class="line"><span class="comment"># ----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># 必需的回调</span></span><br><span class="line"><span class="comment"># ----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># init函数是作为BigWorld初始化过程的一部分调用的。</span></span><br><span class="line"><span class="comment"># 它接收BigWorld xml配置文件作为参数。</span></span><br><span class="line"><span class="comment"># 这是配置所有应用程序特定的BigWorld组件的最佳位置，比如初始相机视图等…</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init</span>(<span class="params"> scriptConfig, engineConfig, prefs </span>):</span><br><span class="line">	initOffline( scriptConfig )</span><br><span class="line">	<span class="comment">#隐藏鼠标光标并将其限制在窗口的客户端区域。	</span></span><br><span class="line">	GUI.mcursor().clipped = <span class="literal">True</span></span><br><span class="line">	GUI.mcursor().visible = <span class="literal">False</span></span><br><span class="line"><span class="comment">#init()结束后立即调用。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start</span>():</span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当玩家从内部环境移动到外部环境时，</span></span><br><span class="line"><span class="comment"># BigWorld就会调用这一机制，反之亦然。</span></span><br><span class="line"><span class="comment"># 它应该被用来适应任何与个性相关的数据(例如，相机位置/性质等)。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">onChangeEnvironments</span>(<span class="params"> inside </span>):</span><br><span class="line"> 	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当出现系统生成的消息时，引擎将调用该函数。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">addChatMsg</span>(<span class="params"> msg </span>):</span><br><span class="line">	<span class="built_in">print</span> <span class="string">&quot;addChatMsg:&quot;</span>, msg</span><br><span class="line"><span class="comment"># 键盘时间</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handleKeyEvent</span>(<span class="params"> event </span>):</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="comment"># 鼠标事件</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handleMouseEvent</span>(<span class="params"> event </span>):</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="comment"># 操纵杆事件</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handleAxisEvent</span>(<span class="params"> event </span>):</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="comment"># ----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Section: Helper methods</span></span><br><span class="line"><span class="comment"># ----------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">initOffline</span>(<span class="params"> scriptConfig </span>):</span><br><span class="line"> 	<span class="comment"># Create a space for the client to inhabit</span></span><br><span class="line">	spaceID = BigWorld.createSpace()</span><br><span class="line">	<span class="comment"># 加载script_config.xml中指定的空间</span></span><br><span class="line">	BigWorld.addSpaceGeometryMapping(spaceID, <span class="literal">None</span>, scriptConfig.readString( <span class="string">&quot;space&quot;</span> ) )</span><br><span class="line">	<span class="comment"># 使用script_config.xml中的位置创建玩家实体</span></span><br><span class="line">	playerID = BigWorld.createEntity( </span><br><span class="line">		scriptConfig.readString( <span class="string">&quot;player/entityType&quot;</span> ),spaceID, <span class="number">0</span>,</span><br><span class="line">		scriptConfig.readVector3( <span class="string">&quot;player/startPosition&quot;</span> ),</span><br><span class="line">		scriptConfig.readVector3( <span class="string">&quot;player/startDirection&quot;</span> ),</span><br><span class="line">		&#123;&#125;</span><br><span class="line">	)</span><br><span class="line">	BigWorld.player( BigWorld.entities[ playerID ] )</span><br><span class="line">	<span class="comment"># 使用第一人称模式，因为我们还没有使用模型。</span></span><br><span class="line">	BigWorld.camera().firstPerson = <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>这个性脚本提供了一个initOffline方法，该方法包含足够的代码来运行一个基本的客户端，以及所有其他所需回调的存根实现。</p>
<p>下面的部分将描述如何设置这些文件，以便在启动时将它们传递给个性脚本。</p>
<h3 id="2-6-XML-configuration-files（XML配置文件）"><a href="#2-6-XML-configuration-files（XML配置文件）" class="headerlink" title="2.6 XML configuration files（XML配置文件）"></a>2.6 XML configuration files（XML配置文件）</h3><p>至少，BigWorld客户端希望在启动时向个性脚本传递三个XML配置文件：</p>
<ul>
<li>&lt;engine_config&gt;.xml</li>
<li>&lt;scripts_config&gt;.xml</li>
<li>&lt;preferences&gt;.xml</li>
</ul>
<p>xml文件用于在客户端引擎上设置各种可配置属性，包括游戏个性的名称。我们将通过复制FantasyDemo &#x2F;res&#x2F;engine_config.xml到tutorial&#x2F;res&#x2F;engine_config.xml.<br>打开复制的文件，并修改（名称与个性脚本名称一致）：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 修改前 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;personality&gt; FantasyDemo	&lt;/personality&gt; --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 修改后 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">personality</span>&gt;</span> BWPersonality	<span class="tag">&lt;/<span class="name">personality</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>&lt;scripts_config&gt;.xml文件用于定义个性脚本所期望的设置—保存以下内容到tutorial&#x2F;res&#x2F;scripts_config.xml中:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">scripts_config.xml</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这个文件的内容被传递给个性脚本</span></span><br><span class="line"><span class="comment">作为init函数的第一个参数(作为数据部分)。它的</span></span><br><span class="line"><span class="comment">语法完全由个性脚本定义。 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">space</span>&gt;</span> spaces/main <span class="tag">&lt;/<span class="name">space</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">player</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">entityType</span>&gt;</span> Avatar <span class="tag">&lt;/<span class="name">entityType</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 这是将要创建的玩家的实体类型。你</span></span><br><span class="line"><span class="comment">		必须实现一个Player&lt;类&gt;类型(例如PlayerAvatar)</span></span><br><span class="line"><span class="comment">		来使用该类型作为客户端代理。以下选项 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">startPosition</span>&gt;</span> 0.0 1.25 0.0 <span class="tag">&lt;/<span class="name">startPosition</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">startDirection</span>&gt;</span> 1.0 0.0 0.0 <span class="tag">&lt;/<span class="name">startDirection</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 是由个性脚本提供的起始位置和</span></span><br><span class="line"><span class="comment">		面对dir为玩家如果没有空间特定生成点.</span></span><br><span class="line"><span class="comment">		--&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">player</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">scripts_config.xml</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>脚本配置将字符串spaces&#x2F;main作为创建客户端实体的空间传递到个性脚本中，因此接下来我们将创建一个基本的行走空间。</p>
<h3 id="2-7-一个简单空间"><a href="#2-7-一个简单空间" class="headerlink" title="2.7 一个简单空间"></a>2.7 一个简单空间</h3><p>在启动世界编辑器之前，您需要告诉它在哪里可以找到特定项目的资源。<br>为此，打开bigworld&#x2F;tools&#x2F;worldeditor&#x2F;paths.xml，并将FantasyDemo的引用替换到你自己的项目中。例如,</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Paths</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Path</span>&gt;</span>../../../tutorial/res<span class="tag">&lt;/<span class="name">Path</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Path</span>&gt;</span>../../../bigworld/res<span class="tag">&lt;/<span class="name">Path</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Paths</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>要创建一个简单的可导航的空间，请遵循以下步骤:</p>
<ol>
<li>启动世界编辑器(bigworld&#x2F;tools&#x2F; worlddeditor &#x2F;worldeditor.exe)</li>
<li>在打开空间对话框中，单击create按钮</li>
<li>在New Space对话框中:<ol>
<li>Set the Space Name field to main.</li>
<li>Set the Space Dimensions group box’s Width and Height fields to 5.</li>
<li>Set the Default Terrain Texture field to a texture of your choosing.</li>
<li>Click the Create button</li>
</ol>
</li>
</ol>
<p>新的空间主体将被创建并显示在世界编辑器中，保存并关闭编辑器。</p>
<h3 id="2-8-第一次运行客户端"><a href="#2-8-第一次运行客户端" class="headerlink" title="2.8 第一次运行客户端"></a>2.8 第一次运行客户端</h3><p>执行完本教程前几节中的步骤后，现在可以运行客户机了。为此，请使用前面创建的（参考2.2 run.bat）。你应该拥有一个能够使用鼠标控制朝向和方向键控制在空间中行走的第一人称玩家。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/06/bigworld_02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Avatar.png">
      <meta itemprop="name" content="华">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keep Running">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Keep Running">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/11/06/bigworld_02/" class="post-title-link" itemprop="url">BIGWORLD File Grammar Guide</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-11-06 11:20:31" itemprop="dateCreated datePublished" datetime="2024-11-06T11:20:31+08:00">2024-11-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-11-07 08:59:37" itemprop="dateModified" datetime="2022-11-07T08:59:37+08:00">2022-11-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/BigWorld/" itemprop="url" rel="index"><span itemprop="name">BigWorld</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="BIGWORLD-File-Grammar-Guide"><a href="#BIGWORLD-File-Grammar-Guide" class="headerlink" title="BIGWORLD File Grammar Guide"></a>BIGWORLD File Grammar Guide</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>本文档详细介绍了BigWorld技术在客户端和服务器端使用的文件的语法。</p>
<p>除了文件的语法之外，每个部分都描述了文件的用途，以及在适用的情况下对进一步信息的引用。</p>
<h2 id="2-alias-xml"><a href="#2-alias-xml" class="headerlink" title="2.alias.xml"></a>2.alias.xml</h2><p>用于创建数据类型别名</p>
<h2 id="3-BinSection-files"><a href="#3-BinSection-files" class="headerlink" title="3.BinSection files"></a>3.BinSection files</h2><p>二进制数据文件</p>
<h2 id="4-ZipSection-files"><a href="#4-ZipSection-files" class="headerlink" title="4.ZipSection files"></a>4.ZipSection files</h2><p>ZipSection文件ZipSection可以被解释为数据段的集合。在存储时，zipsection使用PKZIP文件格式(通过zipFileSystemclass)对多个数据节进行分组和压缩，保持层次结构。</p>
<h2 id="5-Brush-files"><a href="#5-Brush-files" class="headerlink" title="5. Brush files"></a>5. Brush files</h2><p>笔刷文件</p>
<h2 id="6-capabilities-xml"><a href="#6-capabilities-xml" class="headerlink" title="6.capabilities.xml"></a>6.capabilities.xml</h2><p>关于匹配触发器和能力标志的详细信息</p>
<h2 id="7-cdata"><a href="#7-cdata" class="headerlink" title="7. .cdata"></a>7. .cdata</h2><p>包含二进制地形和光照数据，详细用法参照<strong>ZipSection files</strong></p>
<h3 id="7-1-terrain2-resources"><a href="#7-1-terrain2-resources" class="headerlink" title="7.1 terrain2 resources"></a>7.1 terrain2 resources</h3><p>terrain2 section包含在一块，它包含了块中地形的所有资源。</p>
<ul>
<li>heights sections 高度部分存储地形块的高度图。</li>
<li>layer sections 层段存储地形块的纹理层。</li>
<li>normals &amp; lodNormals sections 法线部分存储了地形块的高分辨率法线贴图。</li>
<li>holes section 存储地形块的holemap，只有当地形块中有holes时才存储该部分</li>
<li>horizonShadows section 存储了地形块的地平线阴影</li>
<li>lodTexture.dds section 存储地形块的LOD纹理。LOD纹理是所有纹理层混合在一起的低分辨率快照。</li>
<li>dominantTextures section 存储了主要的纹理图。主导纹理地图存储地形块中每个x&#x2F;z位置的<strong>最高</strong>混合纹理。</li>
</ul>
<h2 id="8-chunk"><a href="#8-chunk" class="headerlink" title="8. .chunk"></a>8. .chunk</h2><ul>
<li>&lt;chunk&gt;o.chunk (作用于外部)</li>
<li>&lt;chunk&gt;i.chunk (作用于内部)<br>这些文件包含场景对象列表，纹理集，碰撞场景等</li>
</ul>
<h2 id="9-common-options-xml"><a href="#9-common-options-xml" class="headerlink" title="9. common_options.xml"></a>9. common_options.xml</h2><p>用于保存多个BigWorld工具通用的设置和选项。</p>
<h2 id="10-dxenum-xml"><a href="#10-dxenum-xml" class="headerlink" title="10. dxenum.xml"></a>10. dxenum.xml</h2><p>BigWorld的枚举文件(dxenum.xml和.**&lt;enumeration&gt;xml)提供了在DirectX中定义的枚举值的描述，以便它们可以在源文件(如FX文件)和BigWorld工具（如模型编辑器）中使用。</p>
<p>具体见： <strong>&lt;enumeration&gt;.xml</strong></p>
<h2 id="11-EffectMaterial-section"><a href="#11-EffectMaterial-section" class="headerlink" title="11. EffectMaterial section"></a>11. EffectMaterial section</h2><p>由EffectMaterial类使用，这个部分包含材料信息</p>
<h2 id="12-exporter-xml"><a href="#12-exporter-xml" class="headerlink" title="12. exporter.xml"></a>12. exporter.xml</h2><p>有关3ds Max和Maya exporter</p>
<h2 id="13-filters-xml"><a href="#13-filters-xml" class="headerlink" title="13. filters.xml"></a>13. filters.xml</h2><p>过滤器。世界编辑器用于配置地形过滤面板中可用的过滤器，该文件位于underbigworld&#x2F;tools&#x2F;worldeditor&#x2F;resources&#x2F;data。</p>
<h2 id="14-flags-xml"><a href="#14-flags-xml" class="headerlink" title="14. flags.xml"></a>14. flags.xml</h2><p>模型编辑器用来在属性视图中显示材质碰撞标志，这个文件位于bigworld&#x2F;tools&#x2F;worldEditor&#x2F;Resources下。</p>
<h2 id="15-font"><a href="#15-font" class="headerlink" title="15. .font"></a>15. .font</h2><p>字体文件</p>
<h2 id="16-girths-xml"><a href="#16-girths-xml" class="headerlink" title="16. girths.xml"></a>16. girths.xml</h2><p>包含NavGen和脱机处理器用于生成导航网格的设置。</p>
<h2 id="17-gui"><a href="#17-gui" class="headerlink" title="17. .gui"></a>17. .gui</h2><p>用于持久化GUI层次结构，这些文件位于fantasydemo&#x2F;res&#x2F; GUI下。</p>
<p>有关每个部分(GUI类)和标签(GUI成员)的详细描述，请参见Client Python API的条目Modules GUI。</p>
<h2 id="18-gui-xml"><a href="#18-gui-xml" class="headerlink" title="18. gui.xml"></a>18. gui.xml</h2><p>GUI XML文件用于配置World Editor的菜单和工具栏。在bigworld&#x2F;tools&#x2F;worldeditor&#x2F;resources&#x2F;data中定义。</p>
<h2 id="19-LightMapSection"><a href="#19-LightMapSection" class="headerlink" title="19. LightMapSection"></a>19. LightMapSection</h2><p>flora和sky的配置文件有一个light_map部分，指定了各自元素如何应用光的设置。</p>
<h2 id="20-material-kinds-xml"><a href="#20-material-kinds-xml" class="headerlink" title="20. material_kinds.xml"></a>20. material_kinds.xml</h2><p>在模型编辑器的材料设置面板的材料类型下拉列表框中定义要显示的材料类型。</p>
<h2 id="21-mfm"><a href="#21-mfm" class="headerlink" title="21. .mfm"></a>21. .mfm</h2><p>位于 &lt;res&gt;资源文件树中。<br>常用标签 EffectMaterial</p>
<h2 id="22-model"><a href="#22-model" class="headerlink" title="22. .model"></a>22. .model</h2><p>定义在&lt;res&gt;资源树下的各种子文件夹(例如：&lt;res&gt;&#x2F;environments,&lt;res&gt;&#x2F;flora, &lt;res&gt;&#x2F;sets&#x2F;vehicles, etc…)</p>
<h2 id="23-modules-xml"><a href="#23-modules-xml" class="headerlink" title="23. modules.xml"></a>23. modules.xml</h2><p>由客户端工具World Editor, Model Editor和Particle Editor使用，位于bigworld&#x2F;tools&#x2F;<tool_folder>&#x2F;resources&#x2F;data,该文件用于确定该工具应该运行哪些模块。</p>
<h2 id="24-mvl"><a href="#24-mvl" class="headerlink" title="24. .mvl"></a>24. .mvl</h2><p>mvl文件是特定于模型编辑器的。它们只用于观察不同光照条件下的模型。您可以根据需要创建、加载、保存和配置它们，但是它们只在Model Editor中使用。</p>
<h2 id="25-navgen-settings-xml"><a href="#25-navgen-settings-xml" class="headerlink" title="25. navgen_settings.xml"></a>25. navgen_settings.xml</h2><p>关于NavGen的详细信息，请参见Content Tools Reference Guide,中NavGen→“Changing settings”一节。</p>
<h2 id="26-options-xml"><a href="#26-options-xml" class="headerlink" title="26. options.xml"></a>26. options.xml</h2><p>不同的工具使用一个名为options.xml的配置文件。配置如下</p>
<ul>
<li>CAT → Client Access Tool </li>
<li>Model Editor</li>
<li>Particle Editor</li>
<li>World Editor</li>
</ul>
<h2 id="27-PackedSection-files"><a href="#27-PackedSection-files" class="headerlink" title="27. PackedSection files"></a>27. PackedSection files</h2><p>PackedSection文件是用BNF格式描述的只读数据段。</p>
<p>在packkedsection文件中，整数被略微优化(例如，如果值为零，则不存储数据;如果value是一个int8（Byte即一个字节），那么将存储1个字节，依此类推)。</p>
<h2 id="28-path-xml"><a href="#28-path-xml" class="headerlink" title="28. path.xml"></a>28. path.xml</h2><p>以下文件夹包含paths.xml的版本:</p>
<ul>
<li>bigworld&#x2F;tools&#x2F;exporter&#x2F;3dsmax&lt;version&gt;</li>
<li>bigworld&#x2F;tools&#x2F;exporter&#x2F;maya&lt;version&gt;</li>
<li>bigworld&#x2F;tools&#x2F;misc</li>
<li>bigworld&#x2F;tools&#x2F;modeleditor</li>
<li>bigworld&#x2F;tools&#x2F;particleeditor</li>
<li>bigworld&#x2F;tools&#x2F;worldeditor</li>
<li>fantasydemo&#x2F;game</li>
</ul>
<h2 id="29-ppchain"><a href="#29-ppchain" class="headerlink" title="29. .ppchain"></a>29. .ppchain</h2><p>PPChain文件保存在世界编辑器的后期处理编辑器面板。它们描述了整个链，或者部分链。默认情况下，它们位于 &lt;res&gt;system&#x2F;post_processing&#x2F;chains s文件夹中。</p>
<h2 id="30-primitives"><a href="#30-primitives" class="headerlink" title="30. . primitives"></a>30. . primitives</h2><p>. primitives定义在资源树下的各种子文件夹中，例如： &lt;res&gt;&#x2F;environments,&lt;res&gt;&#x2F;flora,&lt;res&gt;&#x2F;sets&#x2F;vehicles。primitives文件使用BigWorld文件系统将二进制数据的离散位保存在一个文件中。</p>
<ul>
<li>Vertex data section,带有顶点数据的部分包含一个小标题，后面是原始顶点数据。</li>
<li>Index data section,包含索引数据的部分包含一个小标题和原始索引数据，后面是原始组。</li>
<li>BSP data section,带有BSP数据的部分包含一个小报头，后面是原始BSP数据。</li>
</ul>
<h2 id="31-shadows-xml"><a href="#31-shadows-xml" class="headerlink" title="31. shadows.xml"></a>31. shadows.xml</h2><p>位于bigworld&#x2F;res&#x2F;system&#x2F;data下，这个文件被3D游戏引擎用来配置各种阴影功能.</p>
<h2 id="32-space-settings"><a href="#32-space-settings" class="headerlink" title="32. space.settings"></a>32. space.settings</h2><p>包含环境设置、网格正方形的边框等…</p>
<h2 id="33-texanim"><a href="#33-texanim" class="headerlink" title="33. .texanim"></a>33. .texanim</h2><p>动画纹理可以通过模型编辑器应用到材质。<br>&lt;texture&gt;.texanim文件格式</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">frames</span>&gt;</span> +[a-z] <span class="tag">&lt;/<span class="name">frames</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fps</span>&gt;</span> integer <span class="tag">&lt;/<span class="name">fps</span>&gt;</span></span><br><span class="line">    +<span class="tag">&lt;<span class="name">texture</span>&gt;</span> folder/file <span class="tag">&lt;/<span class="name">texture</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="34-texformat"><a href="#34-texformat" class="headerlink" title="34. .texformat"></a>34. .texformat</h2><p>位于&lt;res&gt;文件夹下，texture_detail_levels.xml 和 .texformat文件，分别为文件名匹配条件、转换规则。</p>
<h2 id="35-texture-detail-levels-xml"><a href="#35-texture-detail-levels-xml" class="headerlink" title="35. texture_detail_levels.xml"></a>35. texture_detail_levels.xml</h2><p>文件命名规则</p>
<h2 id="36-ual-config-xml"><a href="#36-ual-config-xml" class="headerlink" title="36. ual_config.xml"></a>36. ual_config.xml</h2><p>该文件配置资产浏览器的外观、布局和工作的各个方面</p>
<p>使用它的BigWorld工具(世界编辑器、模型编辑器和粒子编辑器)位于 bigworld&#x2F;tools&#x2F;&lt;tool_folder&gt;&#x2F;resources&#x2F;ual.<br>在文档内容工具参考指南的资产浏览器章节“定制”中提到，这个文件中的标签被记录在bigworld&#x2F;Tools&#x2F; worlddeditor&#x2F;resources&#x2F;ual&#x2F;ual_config.xml中。</p>
<h2 id="37-visual"><a href="#37-visual" class="headerlink" title="37. .visual"></a>37. .visual</h2><p>定义在资源树下例如&lt;res&gt;&#x2F;environments,<br>&lt;res&gt;&#x2F;flora, &lt;res&gt;&#x2F;sets&#x2F;vehicles。</p>
<ul>
<li>NodeSection</li>
<li>PortalSection,描述了邻近块的视线，应该只出现在shell中。</li>
</ul>
<h2 id="38-visual-rules-xml"><a href="#38-visual-rules-xml" class="headerlink" title="38. visual_rules.xml"></a>38. visual_rules.xml</h2><p>3ds Max和Maya可视化导出器用于在导出之前验证文件，规则集定义在bigworld&#x2F;tools&#x2F;res&#x2F;visual_rules.xml中。详细信息请参见《内容工具参考》<br>指南的章节3ds Max和玛雅出口商。</p>
<h2 id="39-xml"><a href="#39-xml" class="headerlink" title="39. .xml"></a>39. .xml</h2><p>各种BigWorld文件都使用XML格式，本章将介绍以下几种文件的语法:</p>
<ul>
<li>&lt;effect&gt;.xml,用于客户端引擎配置镜头效果,位于 fantasydemo&#x2F;res&#x2F;environments&#x2F;fx.</li>
<li>&lt;enumeration&gt;.xml,BigWorld的枚举文件(dxenum.xml和&lt;enumeration&gt;.xml)提供了在DirectX中定义的枚举值的描述，以便在源文件(如FX文件)和BigWorld工具中使用(例如模型编辑器).</li>
<li>&lt;flora&gt;.xml,Flora配置文件的位置由&lt;res&gt;&#x2F;resources.xml中的floraXML标记设置,XML植物群文件定义了要使用的灯光图，以及生态类型和噪声生成函数。</li>
<li>&lt;graphics_settings&gt;.xml,图形设置配置文件的位置由resources.xml中的graphicsSettingsXML标记设置(详细信息请 Client Programming Guide’s section <em>Overview</em> → “Configuration files” → “File resources.xml”)。</li>
<li>&lt;light&gt;.xml,灯光配置文件。</li>
<li>&lt;mouse_cursors&gt;.xml,由客户端引擎用来定义游戏中可用的鼠标光标形状，鼠标光标定义文件可以在res&#x2F;resources.xml中的标签gui&#x2F;cursorDefinitions中指定，但默认为res&#x2F;gui&#x2F;mouse_cursor.xml。</li>
<li>&lt;particle&gt;.xml,粒子系统。</li>
<li>&lt;sky&gt;.xml,Sky配置文件由空间使用，并且可以位于您选择的任何文件夹中，因为它们的位置是由&lt;res&gt;&#x2F;spaces&#x2F;&lt;space&gt;&#x2F;space中的timeOfDay标记设置的</li>
<li>&lt;fx&gt;.xml,FX文件由python FX模块使用，可以放在您选择的任何文件夹中。FX文件是基于actor的。对于每个参与者，您应该指定一个Joint。对于每个参与者，您可以指定任意数量的Events。每个Actor、Joint或Event节都要求将参与者的名称指定为其节名的字符串。</li>
<li>&lt;weather&gt;.xml,weather XML文件为整个游戏指定了可用的天气系统列表。不同天气系统的数量由你决定。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/06/bigworld_01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Avatar.png">
      <meta itemprop="name" content="华">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keep Running">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Keep Running">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/11/06/bigworld_01/" class="post-title-link" itemprop="url">BIG WORLD 术语表</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-11-06 11:20:31 / 修改时间：15:01:56" itemprop="dateCreated datePublished" datetime="2024-11-06T11:20:31+08:00">2024-11-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/BigWorld/" itemprop="url" rel="index"><span itemprop="name">BigWorld</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>这是首页的概述，正文内容会被隐藏</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/11/06/bigworld_01/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/06/bigworld_05_03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Avatar.png">
      <meta itemprop="name" content="华">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keep Running">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Keep Running">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/11/06/bigworld_05_03/" class="post-title-link" itemprop="url">BIGWORLD 客户端编程指南03</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-11-06 11:20:31" itemprop="dateCreated datePublished" datetime="2024-11-06T11:20:31+08:00">2024-11-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-11-07 09:22:47" itemprop="dateModified" datetime="2022-11-07T09:22:47+08:00">2022-11-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/BigWorld/" itemprop="url" rel="index"><span itemprop="name">BigWorld</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="BIGWORLD-05-Client-Programming-Guide-03"><a href="#BIGWORLD-05-Client-Programming-Guide-03" class="headerlink" title="BIGWORLD_05_Client Programming Guide_03"></a>BIGWORLD_05_Client Programming Guide_03</h1><h2 id="22-3D-Engine-Moo"><a href="#22-3D-Engine-Moo" class="headerlink" title="22. 3D Engine (Moo)"></a><strong>22. 3D Engine (Moo)</strong></h2><p>Moo是一个使用DirectX 9的3D引擎，提供了基于资源、对象和设备的服务，但不包括场景数据库。</p>
<p>基于资源的服务包括顶点缓冲区、索引缓冲区、顶点着色器、像素着色器和效果的生成和管理。纹理被自动压缩和存储。所有不受Direct3D管理的资源都由Moo管理，允许大量数据进出使用。</p>
<p>基于对象的服务包括完整的动画系统、带皮肤的两足动物、复合骨骼几何和专门的地形渲染。Moo公开了一个视觉的概念，一个重要的中层几何结构，它位于场景数据库之下，并大大简化了场景数据库代码。</p>
<p>基于设备的服务包括渲染状态的细节控制，封装在材料和着色器中。3D窗口被封装为一个RenderContext，并提供了渲染几何图形和存储照明状态的参考框架。</p>
<p>最后，Moo提供了基本的alpha混合排序三角形管道，不幸的是，Direct3D或(大多数)硬件仍然没有提供这种服务。</p>
<p>需要注意的是，在可能的情况下，Moo使用底层的Direct3DX结构，如D3DXMatrix,D3DXVector和D3DXQuaternion。DirectX团队不断改进这些数学类的实现，它们的功能经常利用处理器特定的指令，如MMX, SIMD和3DNow!利用这些工程师的努力是谨慎的。</p>
<h3 id="22-1-Features"><a href="#22-1-Features" class="headerlink" title="22.1. Features"></a><strong>22.1. Features</strong></h3><p>Moo的一些高级功能如下:</p>
<ul>
<li>D3DXEffects的顶点和像素着色器支持</li>
<li>立方环境地图</li>
<li>渲染目标</li>
<li>光照</li>
<li>法线贴图&#x2F;凹凸贴图</li>
<li>地形</li>
<li>动画</li>
<li>定点渐变</li>
</ul>
<p>以下部分描述了这些特性。</p>
<h4 id="22-1-1-D3DXEffects-vertex-and-pixel-shader-support"><a href="#22-1-1-D3DXEffects-vertex-and-pixel-shader-support" class="headerlink" title="22.1.1. D3DXEffects vertex and pixel shader support"></a><strong>22.1.1. D3DXEffects vertex and pixel shader support</strong></h4><p>Moo中广泛使用效果文件。大多数渲染管道都是基于类EffectMaterial，它实现了一种管理效果使用的全局值的方法，以及每个实例的效果数据，如纹理、自照明值和镜面反射常数。</p>
<p>效果文件也使它更容易管理像素和顶点着色器，因为他们是一起创建在一个文件。使用D3DXEffect格式消除了向引擎添加新的着色器效果的复杂性，并允许快速创建新的视觉效果原型。</p>
<h4 id="22-1-2-Cubic-environment-maps"><a href="#22-1-2-Cubic-environment-maps" class="headerlink" title="22.1.2. Cubic environment maps"></a><strong>22.1.2. Cubic environment maps</strong></h4><p>立方体环境映射可以用于一些反射和标准化立方体映射(用于法线映射)。</p>
<h4 id="22-1-3-Render-targets"><a href="#22-1-3-Render-targets" class="headerlink" title="22.1.3. Render targets"></a><strong>22.1.3. Render targets</strong></h4><p>渲染目标用于创建广告牌纹理。它们还可以与GUI组件一起使用，在2D GUI中显示3D对象(例如，用于项目选择预览)。</p>
<h4 id="22-1-4-Lighting"><a href="#22-1-4-Lighting" class="headerlink" title="22.1.4. Lighting"></a><strong>22.1.4. Lighting</strong></h4><p>Moo的照明组件支持三种不同的灯:</p>
<ul>
<li>Directional lights（平行光）</li>
<li>Point lights（点光源）</li>
<li>Spot lights（聚光灯）</li>
</ul>
<p>任何物体都可以用两个方向灯、四个点灯和两个射灯来照明。这些灯是根据衰减度量来挑选的，所以通常会选择最近的灯。还需要注意的是，使用的灯光越少，光照顶点着色器的执行速度就越快。</p>
<h4 id="22-1-4-1-Light-maps"><a href="#22-1-4-1-Light-maps" class="headerlink" title="22.1.4.1. Light maps"></a><strong>22.1.4.1. Light maps</strong></h4><p>bigworld&#x2F;src&#x2F;lib&#x2F;romp&#x2F;light_map.cpp被一般化以同时支持flora和sky光贴图。光照贴图可以在XML文件中配置。</p>
<h5 id="22-1-4-1-1-Flora-light-map"><a href="#22-1-4-1-1-Flora-light-map" class="headerlink" title="22.1.4.1.1. Flora light map"></a><strong>22.1.4.1.1. Flora light map</strong></h5><p>flora.xml中指定了flora.xml光照图的详细信息，它的位置在文件resources.xml中指定。</p>
<p>植物群灯光贴图的材质标签应该是system&#x2F;materials&#x2F;light_map。(关于该文件语法的详细信息，请参阅文件语法指南的.mfm)。</p>
<p>flora light贴图的默认宽度&#x2F;高度是64x64。这是很小的，但仍然足够的分辨率投影到植物群，因为它的可见面积是100x100米。</p>
<p><img src="/image%5Cbigworld%5C05_11.png" alt="05_11"></p>
<h5 id="22-1-4-1-2-Sky-light-map"><a href="#22-1-4-1-2-Sky-light-map" class="headerlink" title="22.1.4.1.2. Sky light map"></a><strong>22.1.4.1.2. Sky light map</strong></h5><p>天空灯光的细节在空间的sky.xml文件中指定，它的位置在空间的空间中指定。(关于该文件语法的详细信息，请参阅文件语法指南的space.setting)</p>
<p>天光贴图的材质标签应该是system&#x2F;materials&#x2F;sky_light_map。(关于该文件语法的详细信息，请参阅文件语法指南的.mfm)。</p>
<p>天光贴图的默认宽度&#x2F;高度是512x512。这是相当大的，因为光地图是投射在整个可见世界(通常约1x1公里)。</p>
<p><img src="/image%5Cbigworld%5C05_12.png" alt="05_12"></p>
<p><em>天光贴图可以通过SKY_LIGHT_MAP图形设置来禁用</em></p>
<h4 id="22-1-5-Normal-mapping-x2F-bump-mapping"><a href="#22-1-5-Normal-mapping-x2F-bump-mapping" class="headerlink" title="22.1.5. Normal mapping&#x2F;bump mapping"></a><strong>22.1.5. Normal mapping&#x2F;bump mapping</strong></h4><p>法线贴图通过使用每个贴图的法线来添加物体的表面细节。Moo目前支持在动态照明的物体上进行高光和漫反射照明的法线贴图，以及在静态照明的物体上进行高光照明。当前版本的导出器只支持切线空间法线映射。</p>
<h4 id="22-1-6-Terrain"><a href="#22-1-6-Terrain" class="headerlink" title="22.1.6. Terrain"></a><strong>22.1.6. Terrain</strong></h4><p>Moo利用了支持的显卡的多纹理、顶点和像素着色能力。因为它使用了一个混合的4层纹理系统的地形，Moo利用硬件的四个纹理阶段的最佳，所以大多数地形可以在一个通道渲染。地形也支持来自定向光源的自阴影。</p>
<h4 id="22-1-7-Animation"><a href="#22-1-7-Animation" class="headerlink" title="22.1.7. Animation"></a><strong>22.1.7. Animation</strong></h4><p>Moo支持基于节点和基于顶点(变形)的动画。Moo还可以混合动画一起提供他们之间的平滑过渡。</p>
<h4 id="22-1-8-Vertex-morphing"><a href="#22-1-8-Vertex-morphing" class="headerlink" title="22.1.8. Vertex morphing"></a><strong>22.1.8. Vertex morphing</strong></h4><p>Moo的顶点变形适用于表面的小变化，如面部动画。变形目标从内容创建包中导出，并通过普通的动画系统进行控制。</p>
<p>请注意，由于变形目标应用于软件，大量使用将影响渲染性能。</p>
<h3 id="22-2-Supported-video-cards"><a href="#22-2-Supported-video-cards" class="headerlink" title="22.2. Supported video cards"></a><strong>22.2. Supported video cards</strong></h3><p>支持的显卡</p>
<h3 id="22-3-Hardware-requirements-for-special-effects"><a href="#22-3-Hardware-requirements-for-special-effects" class="headerlink" title="22.3. Hardware requirements for special effects"></a><strong>22.3. Hardware requirements for special effects</strong></h3><p>下表列出了Moo中可用的特效及其硬件要求:</p>
<table>
<thead>
<tr>
<th><strong>Special effect</strong></th>
<th><strong>Vertex shader version</strong></th>
<th><strong>Pixel shader version</strong></th>
<th><strong>Texture stages required</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Bloom</td>
<td>1.1</td>
<td>1.1</td>
<td>4</td>
</tr>
<tr>
<td>Cloud shadows</td>
<td>1.1</td>
<td>-</td>
<td>3</td>
</tr>
<tr>
<td>Flora</td>
<td>1.1</td>
<td>-</td>
<td>1</td>
</tr>
<tr>
<td>Heat Shimmer</td>
<td>1.1</td>
<td>-</td>
<td>1</td>
</tr>
<tr>
<td>Normal mapping</td>
<td>1.1</td>
<td>1.1</td>
<td>4</td>
</tr>
<tr>
<td>PyModel Shimmer</td>
<td>1.1</td>
<td>-</td>
<td>1</td>
</tr>
<tr>
<td>PyModel stipple</td>
<td>1.1</td>
<td>1.1</td>
<td>4</td>
</tr>
<tr>
<td>Entity shadows</td>
<td>2.0</td>
<td>2.0</td>
<td>1</td>
</tr>
<tr>
<td>Simulated sub-surface scattering</td>
<td>3.0</td>
<td>3.0</td>
<td>4</td>
</tr>
<tr>
<td>Sky Gradient dome</td>
<td>1.1</td>
<td>-</td>
<td>3</td>
</tr>
<tr>
<td>Terrian shadows</td>
<td>1.1</td>
<td>1.1</td>
<td>4</td>
</tr>
<tr>
<td>Terrain Specular</td>
<td>1.1</td>
<td>1.1</td>
<td>4</td>
</tr>
</tbody></table>
<h3 id="22-4-Visual"><a href="#22-4-Visual" class="headerlink" title="22.4. Visual"></a><strong>22.4. Visual</strong></h3><p>Visual类实现3D引擎绘制的基本可渲染对象。一个可视对象包含用于绘制对象的节点层次结构、顶点、索引和材质，它还包含用于碰撞检测的BSP树。当渲染对象时，节点层次结构为可渲染对象提供了一个参考框架。Visual使用EffectMaterial、Primitives和Vertices类来渲染其几何图形。</p>
<h3 id="22-5-EffectMaterial"><a href="#22-5-EffectMaterial" class="headerlink" title="22.5. EffectMaterial"></a><strong>22.5. EffectMaterial</strong></h3><p>BigWorld 3D引擎中的材料系统广泛地使用了D3DXEffects文件</p>
<p>材料系统是通过类EffectMaterial实现的，它包含一个或多个D3DX效果，它们的覆盖值，以及关于碰撞属性和材料表面类型的信息。</p>
<p>材料系统背后的想法是给美工尽可能多的控制权，让他们在不涉及程序员的情况下试验新的渲染技术。</p>
<h4 id="22-5-1-Format"><a href="#22-5-1-Format" class="headerlink" title="22.5.1. Format"></a><strong>22.5.1. Format</strong></h4><p>EffectMaterial在磁盘上的格式非常简单，只有少数几个部分，大部分工作都是通过.fx文件完成的。</p>
<p><strong>22.5.2. Automatic variables&#x2F;Globals</strong></p>
<p>自动变量用于由引擎控制的任何变量，如变换、灯光、相机位置等。自动变量使用变量语义向Effect文件公开。</p>
<p>在Effect文件中，自动变量的定义如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt; &lt;variableName&gt; : &lt;semantic&gt;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>&lt;type&gt;</p>
<p>变量类型(float, bool，纹理等)。</p>
</li>
<li><p>&lt;veriableName&gt;</p>
<p>效果文件中变量的名称。</p>
</li>
<li><p>&lt;semantic&gt;</p>
<p>公开给引擎的名称。</p>
</li>
</ul>
<p>自动变量通过类EffectConstantValue连接到效果。可以通过覆盖EffectConstantValue接口、实现操作()以及使用EffectConstantValue::set或使用EffectConstantValue::get返回的句柄添加新类的实例来添加新的自动变量。</p>
<p> 以下是Moo::EffectVisualContext设置的自动变量:</p>
<ul>
<li><p><strong>Ambient(float4)</strong></p>
<p>当前的环境色。</p>
</li>
<li><p><strong>CamerPos(float3)</strong></p>
<p>当前相机在世界空间的位置。</p>
</li>
<li><p><strong>CamerPosObjectSpace(float3)</strong></p>
<p>当前相机在物体空间中的位置。</p>
</li>
<li><p><strong>DepthTex(trxtrue)</strong></p>
</li>
<li><p><strong>DirectionalLightCount (int)</strong></p>
</li>
<li><p><strong>DirectionalLights</strong>  <strong>(DirectionalLights[2])</strong></p>
</li>
<li><p><strong>DirectionalLightsObjectSpace</strong>  <strong>(DirectionalLights[2])</strong></p>
</li>
<li><p><strong>EnvironmentCubeMap(texture)</strong></p>
</li>
<li><p><strong>EnvironmentTransform(float4x4)</strong></p>
</li>
<li><p><strong>EnvironmentShadowTransform(float4x4)</strong></p>
</li>
<li><p><strong>FarPlane(float)</strong></p>
</li>
<li><p><strong>FloraAnimationGrid(float4[64])</strong></p>
</li>
<li><p><strong>FloraTexture(texture)</strong></p>
</li>
<li><p><strong>FogColour(float4)</strong></p>
</li>
<li><p><strong>FogEnd(float)</strong></p>
</li>
<li><p><strong>FogGradientTexture(texture)</strong></p>
</li>
<li><p><strong>FogStart(float)</strong></p>
</li>
<li><p><strong>FogTextureTransform(matrix)</strong></p>
</li>
<li><p><strong>GUIColour(float4)</strong></p>
</li>
<li><p><strong>LastViewProjection(float4x4)</strong></p>
</li>
<li><p><strong>InvView(float4x4)</strong></p>
</li>
<li><p><strong>InvViewProjection(float4x4)</strong></p>
</li>
<li><p><strong>MipFilter(int)</strong></p>
</li>
<li><p><strong>MinMagFilter(int)</strong></p>
</li>
<li><p><strong>MaxAnisotropy(int)</strong></p>
</li>
<li><p><strong>NearPlane(float)</strong></p>
</li>
<li><p><strong>NormalisationMap(texture)</strong></p>
</li>
<li><p><strong>ObjectID(float)</strong></p>
</li>
<li><p><strong>PenumbraSize(float)</strong></p>
</li>
<li><p><strong>PointLightCount(int)</strong></p>
</li>
<li><p><strong>PointLights(PointLights[4])</strong></p>
</li>
<li><p><strong>Screen(float4)</strong></p>
</li>
<li><p><strong>SkyBoxController(float4)</strong></p>
</li>
<li><p><strong>SpecularDirectionalLightCount(int)</strong></p>
</li>
<li><p><strong>SpecularDirectionalLights(DirectionLights[2])</strong></p>
</li>
<li><p><strong>SpecularDirectionalLightsObjectSpace(DirectionLights[2])</strong></p>
</li>
<li><p><strong>SpecularPointLightCount(int)</strong></p>
</li>
<li><p><strong>SpecularPointLights(PointLight[2])</strong></p>
</li>
<li><p><strong>SpecularPointLightsObjectSpace(PointLights[2])</strong></p>
</li>
<li><p><strong>SpotLightCount(int)</strong></p>
</li>
<li><p><strong>SpotLights(SpotLight[2])</strong></p>
</li>
<li><p><strong>SpotLightsObjectSpace(SpotLight[2])</strong></p>
</li>
<li><p><strong>StaticLighting(bool)</strong></p>
</li>
<li><p><strong>StippleMap(texture)</strong></p>
</li>
<li><p><strong>SunAngle(flaot)</strong></p>
</li>
<li><p><strong>TerrainTextureTransform(float4[2])</strong></p>
</li>
<li><p><strong>Time(float)</strong></p>
</li>
<li><p><strong>View(float4x4)</strong></p>
</li>
<li><p><strong>ViewProjection(float4x4)</strong></p>
</li>
<li><p><strong>WindAnimation(float4)</strong></p>
</li>
<li><p><strong>World(float4x4)</strong></p>
</li>
<li><p><strong>WorldPalette(float[17*3])</strong></p>
</li>
<li><p><strong>WorldView(flaot4x4)</strong></p>
</li>
<li><p><strong>WorldViewProjection(float4x4)</strong></p>
</li>
</ul>
<h4 id="22-5-3-Artist-editable-x2F-tweakable-variables"><a href="#22-5-3-Artist-editable-x2F-tweakable-variables" class="headerlink" title="22.5.3. Artist-editable&#x2F;tweakable variables"></a><strong>22.5.3. Artist-editable&#x2F;tweakable variables</strong></h4><p>Artist-editable变量是被设计为在每个材质的基础上重写的变量。这些变量可以在世界编辑器和模型编辑器中编辑，允许您在可视化的同时实时更改模型的外观</p>
<p>通过将属性artist_Editable或worldBuilderEditable设置为true，可以将Artist-editable变量暴露给引擎。</p>
<p>将artistEditable设置为true将变量暴露给模型编辑器的材料设置面板，而将worldBuilderEditable设置为true将它暴露给模型编辑器，如果bigworld&#x2F;tools&#x2F; worlddeditor &#x2F;options.xml文件中objects&#x2F;materialOverrideMode标签设置为1，则暴露给世界编辑器的属性面板。</p>
<p>以下是FX文件中这些变量的表示法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt; &lt;variableName&gt;</span><br><span class="line">&lt;</span><br><span class="line"> bool [artistEditable|worldBuilderEditable] = true;</span><br><span class="line"> ... 1</span><br><span class="line">&gt; = &lt;defaultValue&gt;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>&lt;type&gt;</strong> — 对象的类型</li>
<li><strong>&lt;variableName&gt;</strong> —效果文件中的变量名称</li>
<li>**&lt;defaultValue&gt;**—该变量的默认值。</li>
</ul>
<p>目前，受支持的artist-editable变量的类型有：</p>
<ul>
<li><strong>bool</strong></li>
<li><strong>float</strong></li>
<li><strong>float4</strong></li>
<li><strong>float4x4</strong></li>
<li><strong>int</strong></li>
<li><strong>texture</strong></li>
</ul>
<p>在任意一个工具中暴露变量的条件如下:</p>
<ul>
<li><p>如果artistEditable在FX文件中设置为true</p>
<p><strong>Exposed in Model Editor?</strong>: Yes</p>
<p><strong>Exposed in World Editor?</strong>: No</p>
</li>
<li><p>如果worldBuilderEditable在FX文件中设置为true</p>
<ul>
<li><p>如果在bigworld&#x2F;tools&#x2F; worlddeditor &#x2F;options.xml中materialOverrideMode设置为1</p>
<p><strong>Exposed in Model Editor?</strong>: No</p>
<p><strong>Exposed in World Editor?</strong>: No</p>
</li>
<li><p>如果在bigworld&#x2F;tools&#x2F; worlddeditor &#x2F;options.xml中materialOverrideMode设置为0</p>
<p><strong>Exposed in Model Editor?</strong>: No</p>
<p><strong>Exposed in World Editor?</strong>: Yes</p>
</li>
</ul>
</li>
</ul>
<h4 id="22-5-4-Multiple-layered-effects-per-material"><a href="#22-5-4-Multiple-layered-effects-per-material" class="headerlink" title="22.5.4. Multiple-layered effects per material"></a><strong>22.5.4. Multiple-layered effects per material</strong></h4><p>Moo::EffectMaterial类支持每个材质拥有多层D3DXEffects。</p>
<p>这对于需要使用标准顶点着色器的材质是有用的，但只对效果的像素着色器组件有轻微的改变。这些材质通常只会由资产转换器创建，因为Model Editor不支持为每个材质添加多个效果。</p>
<h4 id="22-5-5-Recording-material-states"><a href="#22-5-5-Recording-material-states" class="headerlink" title="22.5.5. Recording material states"></a><strong>22.5.5. Recording material states</strong></h4><p>材质状态可以通过类Moo::EffectMaterial通过在材质的begin()和end()对之间调用recordPass()来记录。</p>
<p>这个方法返回一个Moo::StateRecorder，用于存储当前渲染状态以延迟渲染。此对象只在当前渲染循环结束前有效，并且在此之后将不再可用。</p>
<h4 id="22-5-6-Using-BigWorld-fx-files-with-3ds-Max"><a href="#22-5-6-Using-BigWorld-fx-files-with-3ds-Max" class="headerlink" title="22.5.6. Using BigWorld .fx files with 3ds Max"></a><strong>22.5.6. Using BigWorld</strong> <strong>.fx</strong> <strong>files with 3ds Max</strong></h4><p>BigWorld .fx文件和3ds Max .fx文件不幸的是不是100%兼容的。然而，可以创建一个可以在两个应用程序中使用的.fx文件。</p>
<p>为了暴露可编辑参数，BigWorld着色器使用下面的注释:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> artistEditable = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>而3ds Max需要下面的注释字符串:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIName = &quot;name&quot;</span><br></pre></td></tr></table></figure>

<p>示例效果文件bigworld&#x2F;res&#x2F;shaders&#x2F;std_effects&#x2F;normalmap.fx将其参数正确地暴露给BigWorld和3ds Max。输出器也输出3ds Max材质面板中输入的值。</p>
<p>文件normalmap.Fx还使用了一个单独的技术，称为max_preview，以及额外的顶点和像素着色器。</p>
<p>这是由于两个原因:</p>
<ul>
<li>在BigWorld引擎和3ds Max中应用照明没有统一的方法。</li>
<li>3ds Max使用右手坐标系，而BigWorld使用左手坐标系。</li>
</ul>
<p>这本身不是一个大问题，但这意味着如果你想在3ds Max中预览你的着色器，就需要额外的着色器工作。</p>
<p>如果你还没有应用servicepack 1for 3ds Max 7，一个问题是它的材质面板在处理效果文件中的#include指令时非常糟糕。发生的情况是，如果你保存一个应用了法线贴图效果的材质，那么它并不总是会在3ds Max中被正确加载，这可能会给美工带来额外的困惑。这个问题已经在Service Pack 1中修复了，所以如果你想在3ds Max中使用.fx文件，应用它是很重要的。</p>
<p>在你决定让你的.fx文件与3dsMax兼容之前，注意这些问题是很重要的。</p>
<h3 id="22-6-Visual-channels"><a href="#22-6-Visual-channels" class="headerlink" title="22.6. Visual channels"></a><strong>22.6. Visual channels</strong></h3><p>视觉通道在Moo中实现了延迟渲染管道。</p>
<p>现在推行的标准渠道有五个:</p>
<ul>
<li>Sorted channel（排序通道）</li>
<li>Internal sorted channel（内部排序通道）</li>
<li>Shimmer channel（微光通道）</li>
<li>Sorted shimmer channel（排序微光通道）</li>
<li>Distortion channel（失真通道）</li>
</ul>
<p>通过覆盖Moo::VisualChannel接口并实现VisualChannel::addItem，应用程序可以创建任意数量的通道。</p>
<p>下面的小节描述了这些通道。</p>
<h4 id="22-6-1-Sorted-channel"><a href="#22-6-1-Sorted-channel" class="headerlink" title="22.6.1. Sorted channel"></a><strong>22.6.1. Sorted channel</strong></h4><p>排序通道用于需要以back-to-front顺序呈现的对象。</p>
<p>当可视性对象中的原语组添加到此通道时，其三角形不会在内部排序。</p>
<p>该通道主要用于添加对象，即目标混合为1的对象。</p>
<h4 id="22-6-2-Internal-sorted-channel"><a href="#22-6-2-Internal-sorted-channel" class="headerlink" title="22.6.2. Internal sorted channel"></a><strong>22.6.2. Internal sorted channel</strong></h4><p>内部排序通道用于需要back-to-front顺序呈现的对象，同时也需要back-to-front顺序呈现其三角形。</p>
<p>添加到此通道的对象也将根据已排序通道中的对象进行排序。</p>
<p>此通道对于alpha混合对象和任何没有目标混合对象的透明对象非常有用</p>
<h4 id="22-6-3-Shimmer-channel"><a href="#22-6-3-Shimmer-channel" class="headerlink" title="22.6.3. Shimmer channel"></a><strong>22.6.3. Shimmer channel</strong></h4><p>微光通道用于需要热微光的物体。</p>
<p>添加到此通道的任何对象都应该只写入帧缓冲区的alpha通道。</p>
<h4 id="22-6-4-Sorted-shimmer-channel"><a href="#22-6-4-Sorted-shimmer-channel" class="headerlink" title="22.6.4. Sorted shimmer channel"></a><strong>22.6.4. Sorted shimmer channel</strong></h4><p>排序的微光通道用于需要热微光的物体，也需要绘制颜色信息。添加到此通道的任何对象都应同时写入帧缓冲区的alpha通道（对于闪烁量）和颜色通道。</p>
<h4 id="22-6-5-Distortion-channel"><a href="#22-6-5-Distortion-channel" class="headerlink" title="22.6.5. Distortion channel"></a><strong>22.6.5. Distortion channel</strong></h4><p>失真通道用于那些想要直接进入最终场景作为纹理的对象。这可以用来实现折射效果(例如，水)。</p>
<h3 id="22-7-Textures"><a href="#22-7-Textures" class="headerlink" title="22.7. Textures"></a><strong>22.7. Textures</strong></h3><h4 id="22-7-1-Texture-detail-levels-x2F-compression"><a href="#22-7-1-Texture-detail-levels-x2F-compression" class="headerlink" title="22.7.1. Texture detail levels&#x2F;compression"></a><strong>22.7.1. Texture detail levels&#x2F;compression</strong></h4><p>纹理根据它们的文件名自动加载和压缩，文件名控制大小、格式转换和压缩级别。</p>
<p>关于该文件语法的详细信息，请参阅 File Grammar Guide’s section <em>.texformat</em>.</p>
<p>系统是通过类Moo::TextureDetailLevel实现的。纹理管理器存储一个纹理细节级别列表，并使用它们根据它们的文件名来调整和压缩纹理。仍然支持legacy .texformat系统。</p>
<p>TextureDetailLevel的属性分为两组:</p>
<ul>
<li>文件名匹配准则。</li>
<li>转换规则。</li>
</ul>
<p>属性的文件名匹配准则定义了用于检查当前TextureDetailLevel是否应用于正在检查的纹理的条件。它们的说明如下:</p>
<ul>
<li><p><strong>contains_</strong></p>
<p>匹配纹理文件名中包含的字符串。</p>
</li>
<li><p><strong>postFixes_</strong></p>
<p>匹配纹理文件名后缀的字符串。</p>
</li>
<li><p><strong>preFixes_</strong></p>
<p>匹配纹理文件名前缀的字符串。</p>
</li>
</ul>
<p>每个字符串列表中只有一个字符串必须与纹理名称匹配，以便TextureDetailLevel认为它是匹配的。如果其中一个列表中没有字符串，也将被视为匹配。</p>
<p>属性的转换规则集定义了如何转换匹配的纹理。它们的说明如下:</p>
<ul>
<li><p><strong>compressedFormat_</strong></p>
<p>纹理转换的格式(当启用纹理压缩时)</p>
</li>
<li><p><strong>format_</strong></p>
<p>纹理转换为的格式。</p>
</li>
<li><p><strong>lodMode_</strong></p>
<p>定义纹理如何响应纹理质量设置。</p>
<p>纹理质量通过TEXTURE_QUALITY图形设置设置。</p>
</li>
<li><p><strong>maxDim_</strong></p>
<p>纹理的 最大宽度&#x2F;高度 尺寸。</p>
</li>
<li><p><strong>minDim_</strong></p>
<p>纹理的 最小宽度&#x2F;高度 尺寸。</p>
</li>
<li><p><strong>noResize_</strong></p>
<p>确定纹理不会被缩放为2的幂次，并且不会有mipmapping、compression或一个.dds版本。</p>
</li>
<li><p><strong>reduceDim_</strong></p>
<p>禁用压缩时将纹理维度减半的次数。</p>
</li>
</ul>
<p>纹理细节级别可以从数据中读取，如下面的例子所示:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">prefix</span>&gt;</span> objects/ <span class="tag">&lt;/<span class="name">prefix</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">postfix</span>&gt;</span> tga <span class="tag">&lt;/<span class="name">postfix</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">postfix</span>&gt;</span> bmp <span class="tag">&lt;/<span class="name">postfix</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">contains</span>&gt;</span> norms <span class="tag">&lt;/<span class="name">contains</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">contains</span>&gt;</span> normals <span class="tag">&lt;/<span class="name">contains</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maxDim</span>&gt;</span> 512 <span class="tag">&lt;/<span class="name">maxDim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">minDim</span>&gt;</span> 128 <span class="tag">&lt;/<span class="name">minDim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">reduceDim</span>&gt;</span> 1 <span class="tag">&lt;/<span class="name">reduceDim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">format</span>&gt;</span> A8R8G8B8 <span class="tag">&lt;/<span class="name">format</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面的例子产生了从文件夹objects&#x2F;的子树中加载的任何纹理，扩展名为.tga或.bmp，它包含字符串规范或法线，只要最小维度不低于128，它的维度就会减半。如果格式不同，它将被更改为带有alpha的32位颜色。</p>
<p>默认的详细级别是:</p>
<ul>
<li><p>文件名以规范结尾的任何文件。tga或norms.bmp将被转换为A8R8G8B8纹理</p>
<p>(这样就不会压缩BigWorld的法线贴图)</p>
</li>
<li><p>其他任何.tga文件都被转换为DXT3格式。</p>
</li>
<li><p>其他任何.bmp文件都被转换为DXT1格式。</p>
</li>
</ul>
<p>默认情况下，如果它们的尺寸大于2048，纹理才会被缩小。</p>
<h4 id="22-7-2-Animated-textures"><a href="#22-7-2-Animated-textures" class="headerlink" title="22.7.2. Animated textures"></a><strong>22.7.2. Animated textures</strong></h4><p>Moo通过纹理交换支持简单的动画纹理。</p>
<p>当纹理管理器加载一个纹理时，它将查找与加载的文件同名，但扩展名为.texanim的文件。如果找到这样的文件，那么它将作为一个动画纹理加载。</p>
<p>.texanim文件是一个简单的XML文件，它引用了许多纹理，包含一个动画字符串和每秒帧数。</p>
<p>.texanim文件的格式如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> &lt;frames&gt; string &lt;/frames&gt;</span><br><span class="line"> &lt;fps&gt; .f &lt;/fps&gt;</span><br><span class="line">+&lt;texture&gt; TEXTURE_RESOURCE &lt;/texture&gt;</span><br></pre></td></tr></table></figure>

<p>下面是一个.texanim文件的示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;frames&gt; abcdefgh &lt;/frames&gt;</span><br><span class="line">&lt;fps&gt; 10.0 &lt;/fps&gt;</span><br><span class="line">&lt;texture&gt; maps/fx/fx_dirt01.tga &lt;/texture&gt;</span><br><span class="line">&lt;texture&gt; maps/fx/fx_dirt02.tga &lt;/texture&gt;</span><br><span class="line">&lt;texture&gt; maps/fx/fx_dirt03.tga &lt;/texture&gt;</span><br><span class="line">&lt;texture&gt; maps/fx/fx_dirt04.tga &lt;/texture&gt;</span><br><span class="line">&lt;texture&gt; maps/fx/fx_dirt05.tga &lt;/texture&gt;</span><br><span class="line">&lt;texture&gt; maps/fx/fx_dirt06.tga &lt;/texture&gt;</span><br><span class="line">&lt;texture&gt; maps/fx/fx_dirt07.tga &lt;/texture&gt;</span><br><span class="line">&lt;texture&gt; maps/fx/fx_dirt08.tga &lt;/texture&gt;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，动画纹理将以每秒10帧的速度按顺序播放fx_dirt纹理。</p>
<p>您可以通过更改frames标签来更改帧回放的顺序。标签值中的a指的是XML文件中存储的第一个纹理，b指的是存储的第二个纹理，以此类推。</p>
<h4 id="22-7-3-Applying-a-code-generated-texture-to-a-character"><a href="#22-7-3-Applying-a-code-generated-texture-to-a-character" class="headerlink" title="22.7.3. Applying a code-generated texture to a character"></a><strong>22.7.3. Applying a code-generated texture to a character</strong></h4><p>要将代码生成的纹理应用到模型中，请遵循以下步骤:</p>
<ol>
<li>创建一个自动的.fx变量(例如customTexture)。</li>
<li>更新角色的着色器，以便使用新的.fx变量进行渲染，而不是使用diffuseMap属性。</li>
<li>你将需要一个单独的TextureSetter，它是一个Moo::EffectConstantValue。这提供了“current custom texture”到.fx文件。</li>
<li>在绘制PyModel的实例时，编写一个PyFashion来设置“current custom texture”。</li>
<li>创建一个包含自定义纹理创建过程的Moo::BaseTexture。</li>
</ol>
<h5 id="22-7-3-1-Loading-textures-from-disk"><a href="#22-7-3-1-Loading-textures-from-disk" class="headerlink" title="22.7.3.1. Loading textures from disk"></a><strong>22.7.3.1. Loading textures from disk</strong></h5><p>当从磁盘加载纹理时，建议让加载线程在后台运行，这样它就不会中断渲染线程。</p>
<p>下面的例子演示了一个使用BackgroundTask和BGTaskManager类的纹理加载器。注意，代码提供了两个特性—线程纹理加载，以及将纹理提供给.fx文件系统。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cstdmf/bgtask_manager.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cstdmf/concurrency.hpp&quot;</span></span></span><br><span class="line"><span class="built_in">DECLARE_DEBUG_COMPONENT2</span>( <span class="string">&quot;romp&quot;</span>, <span class="number">0</span> );</span><br><span class="line"><span class="comment">// -------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Section: Texture Setter</span></span><br><span class="line"><span class="comment">// -----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This class sets textures on the device. It is also multi-threaded.</span></span><br><span class="line"><span class="comment"> * When it is told to use a new texture, it uses the background loading</span></span><br><span class="line"><span class="comment"> thread</span></span><br><span class="line"><span class="comment"> * to do so. While it is doing this, the textureName refers to the new</span></span><br><span class="line"><span class="comment"> * texture, but isLoading() will return true. And in this state, it will be</span></span><br><span class="line"><span class="comment"> * sneakily using the pre-existing texture until the new one is ready.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadedTextureSetter</span> : <span class="keyword">public</span> Moo::EffectConstantValue</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ThreadedTextureSetter</span>():</span><br><span class="line">    <span class="built_in">pTexture_</span>( <span class="literal">NULL</span> ),</span><br><span class="line">    <span class="built_in">bgLoader_</span>( <span class="literal">NULL</span> ),</span><br><span class="line">    <span class="built_in">textureName_</span>( <span class="string">&quot;&quot;</span> )</span><br><span class="line">    &#123; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This method is called by the effect system when a material needs</span></span><br><span class="line"><span class="comment"> * to draw using a texture with the given automatic semantic.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(ID3DXEffect* pEffect, D3DXHANDLE constantHandle)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">SimpleMutexHolder <span class="title">holder</span><span class="params">( mutex_ )</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (pTexture_ &amp;&amp; pTexture_-&gt;<span class="built_in">pTexture</span>())</span><br><span class="line">            pEffect-&gt;<span class="built_in">SetTexture</span>(constantHandle, pTexture_-&gt;<span class="built_in">pTexture</span>());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pEffect-&gt;<span class="built_in">SetTexture</span>(constantHandle, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This method sets our texture. If the texture is different then</span></span><br><span class="line"><span class="comment"> * the existing one, we schedule the new one for loading, and set</span></span><br><span class="line"><span class="comment"> * the textureName and the isLoading() flag. In an unspecified amount</span></span><br><span class="line"><span class="comment"> * of time, the new texture will be loaded and used.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">texture</span><span class="params">( <span class="type">const</span> std::string&amp; texName )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (textureName_ == texName)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;<span class="built_in">isLoading</span>())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        textureName_ = texName;</span><br><span class="line">        bgLoader_ = <span class="keyword">new</span> <span class="built_in">BackgroundTask</span>(</span><br><span class="line">            &amp;ThreadedTextureSetter::loadTexture, <span class="keyword">this</span>,</span><br><span class="line">            &amp;ThreadedTextureSetter::onLoadComplete, <span class="keyword">this</span> );</span><br><span class="line">        <span class="meta">#<span class="keyword">ifndef</span> EDITOR_ENABLED</span></span><br><span class="line">        BgTaskManager::<span class="built_in">instance</span>()-&gt;<span class="built_in">addTask</span>( *bgLoader_ );</span><br><span class="line">        <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        ThreadedTextureSetter::<span class="built_in">loadTexture</span>( <span class="keyword">this</span> );</span><br><span class="line">        ThreadedTextureSetter::<span class="built_in">onLoadComplete</span>( <span class="keyword">this</span> );</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This class-static method is called by the background loading thread</span></span><br><span class="line"><span class="comment"> * and allows us to load the texture resource in a blocking manner.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">loadTexture</span><span class="params">( <span class="type">void</span>* s )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ThreadedTextureSetter* setter = <span class="built_in">static_cast</span>&lt;ThreadedTextureSetter*&gt;(s);</span><br><span class="line">        Moo::BaseTexturePtr pTex = </span><br><span class="line">            Moo::TextureManager::<span class="built_in">instance</span>()-&gt;<span class="built_in">get</span>( setter-&gt;<span class="built_in">textureName</span>() );</span><br><span class="line">        setter-&gt;<span class="built_in">pTexture</span>(pTex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This class-static method is called when the background loading thread</span></span><br><span class="line"><span class="comment"> * has finished.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">onLoadComplete</span><span class="params">( <span class="type">void</span>* s )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ThreadedTextureSetter* setter = <span class="built_in">static_cast</span>&lt;ThreadedTextureSetter*&gt;(s);</span><br><span class="line">        setter-&gt;<span class="built_in">onBgLoadComplete</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This method returns the name of the texture we are currently</span></span><br><span class="line"><span class="comment"> * drawing with. If isLoading() is true, then the textureName</span></span><br><span class="line"><span class="comment"> * refers to the texture we would like to draw with (however we</span></span><br><span class="line"><span class="comment"> * will be actually drawing with the previous texture ptr).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">textureName</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> textureName_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This method returns true if we are currently waiting for the</span></span><br><span class="line"><span class="comment"> * background loading thread to load our texture.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isLoading</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">SimpleMutexHolder <span class="title">holder</span><span class="params">( mutex_ )</span></span>;</span><br><span class="line">        <span class="keyword">return</span> (bgLoader_ != <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//only called by the background loading thread</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pTexture</span><span class="params">( Moo::BaseTexturePtr pTex )</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="function">SimpleMutexHolder <span class="title">holder</span><span class="params">( mutex_ )</span></span>;</span><br><span class="line">        pTexture_ = pTex; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//only called by the background loading thread</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onBgLoadComplete</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">SimpleMutexHolder <span class="title">holder</span><span class="params">( mutex_ )</span></span>;</span><br><span class="line">        <span class="keyword">delete</span> bgLoader_;</span><br><span class="line">        bgLoader_ = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Moo::BaseTexturePtr pTexture_;</span><br><span class="line">    std::string textureName_; <span class="comment">//store a copy for use while loading.</span></span><br><span class="line">    BackgroundTask* bgLoader_; </span><br><span class="line">    SimpleMutex mutex_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><em>纹理加载器的例子</em></p>
<h5 id="22-7-3-2-Manipulate-individual-pixels-within-a-texture"><a href="#22-7-3-2-Manipulate-individual-pixels-within-a-texture" class="headerlink" title="22.7.3.2. Manipulate individual pixels within a texture"></a><strong>22.7.3.2. Manipulate individual pixels within a texture</strong></h5><ol>
<li><p>在托管池中创建纹理</p>
<p>这样就会有一个系统内存副本和一个显存副本。然后你可以锁定纹理并根据需要操作它- DirectX将更新视频内存的更改。</p>
<p>这个选项的唯一缺点是，在某些硬件配置上，系统内存纹理可能是swizzled存储的，这意味着锁操作必须在进行更改之前解除它的swizzled——这是一个潜在的昂贵的锁操作。</p>
<p>注意，要使用纹理，你需要mipmaps可用，所以当执行锁时，你必须:</p>
<ul>
<li><p>单独更新纹理的每个表面。</p>
<p>or</p>
</li>
<li><p>使用拉伸矩形从上表面提供mipmap链。</p>
</li>
</ul>
</li>
<li><p>在显存中创建纹理作为渲染目标</p>
<p>你将不得不使用着色器来写你的改变到纹理。</p>
<p>这种方法的缺点是，如果设备被重置，那么您的更改将丢失。如果发生这种情况，您将不得不处理CreateUnmanagedObjects回调(来自DeviceCallback接口)并重新创建自定义纹理。</p>
<p>不幸的是，您不能只是将数据复制到系统内存，因为CTRL+ALT+DEL将失去设备，而没有给您机会先保存显存数据。</p>
<p>再次注意，要使用纹理，需要有mipmaps可用。因此，也许在这个实例中，您可以在显存中创建一个单独的mipmap纹理，并使用stretch rect从源渲染目标提供mipmap链。源渲染目标可能是用于构建所有自定义角色纹理的“草稿板”。</p>
</li>
</ol>
<h5 id="22-7-3-3-Using-a-shader-to-build-a-custom-texture"><a href="#22-7-3-3-Using-a-shader-to-build-a-custom-texture" class="headerlink" title="22.7.3.3. Using a shader to build a custom texture"></a><strong>22.7.3.3. Using a shader to build a custom texture</strong></h5><p>关于如何实现这一点，最接近的例子是植物灯光贴图，它使用地形着色器的变化来渲染一个渲染目标的照明信息。详情请参见bigworld&#x2F;src&#x2F;lib&#x2F;romp&#x2F; flora_light_map.cpp</p>
<p>注意，要使用着色器，你将需要一个显存&#x2F;渲染目标表面，如上节所述。</p>
<h5 id="22-7-3-4-Dealing-with-the-texture-cache"><a href="#22-7-3-4-Dealing-with-the-texture-cache" class="headerlink" title="22.7.3.4. Dealing with the texture cache"></a><strong>22.7.3.4. Dealing with the texture cache</strong></h5><p>自定义纹理需要实现Moo::BaseTexture接口，以便它可以将自己添加到纹理管理器。然而，根据下面的步骤(将自定义纹理应用到模型)，你甚至可能不需要使用TextureManager，因为它只是提供了一个”通过名称检索纹理”访问纹理。</p>
<p>如果你正在为角色创建一些自定义纹理，那么你可能有一个内部(隐藏)命名方案，这将导致使用纹理缓存的最小好处。简单地使用智能指针来处理缓存就足够了。</p>
<h5 id="22-7-3-5-Assigning-custom-textures-to-a-model"><a href="#22-7-3-5-Assigning-custom-textures-to-a-model" class="headerlink" title="22.7.3.5. Assigning custom textures to a model"></a><strong>22.7.3.5. Assigning custom textures to a model</strong></h5><p>假设您有一个模型，希望多次显示，每个模型都有一个独特的自定义纹理，那么您必须实现一个派生自PyFashion类的类。</p>
<p>这样的类从Python创建，赋值给PyModel实例，并有机会改变共享模型的呈现方式(即，在模型上设置自定义纹理)。PyFashion类将成为脚本的主接口，因此在Python中，你可以用你想要组合的纹理的名称来构造PyFashion实例，然后通过简单地将fashion设置为其PyModel上的任何命名属性来将其分配给一个播放器的模型(PyModel::pySetAttribute自动检测当时尚被设置时，并将其合并到其渲染链中)。</p>
<p>要在模型上实际设置自定义纹理，我们建议创建一个派生自Moo::EffectConstantValue的类，它按名称为.fx文件提供自定义纹理。在.fx文件中，使用自动变量语义(例如Texture diffuseMap:customCharacterTexture)，而不是现有的artistEditable属性。</p>
<p>关于创建纹理设置器的示例代码，请参见 “Loading textures from disk” 。</p>
<h3 id="22-8-Vertex-declaration"><a href="#22-8-Vertex-declaration" class="headerlink" title="22.8. Vertex declaration"></a><strong>22.8. Vertex declaration</strong></h3><p>顶点声明被Direct3D用来将顶点流数据映射到顶点着色器。</p>
<p>Moo使用VertexDeclaration类来简化Direct3D使用顶点声明的处理。顶点声明以XML格式存储在磁盘上，并根据需要加载。存储在磁盘上的顶点声明可以通过调用VertexDeclaration::get()方法来检索。</p>
<p>默认情况下，顶点声明存储在bigworld&#x2F;res&#x2F;shaders&#x2F; format文件夹下。</p>
<p>两个声明可以使用VertexDeclaration::combine()组合在一起，只要两个声明的元素互斥。</p>
<h4 id="22-8-1-File-format"><a href="#22-8-1-File-format" class="headerlink" title="22.8.1. File format"></a><strong>22.8.1. File format</strong></h4><p>顶点声明文件的格式如下:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">    +<span class="tag">&lt;<span class="name">USAGE</span>&gt;</span> (usage index, optional defaults to 0)</span><br><span class="line">        ?<span class="tag">&lt;<span class="name">stream</span>&gt;</span> (strm #, opt, dflt is strm used by the prev elmnt) <span class="tag">&lt;/<span class="name">stream</span>&gt;</span></span><br><span class="line">        ?<span class="tag">&lt;<span class="name">offset</span>&gt;</span> (ofst into strm, opt, dflt is nxt ofst aft prev elmnt) <span class="tag">&lt;/<span class="name">offset</span>&gt;</span></span><br><span class="line">        ?<span class="tag">&lt;<span class="name">type</span>&gt;</span> (data type, opt, defaults to FLOAT3) <span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">USAGE</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>USAGE标签映射到枚举类型D3DDECLUSAGE，其可能的值如下所示:</p>
<p>• <strong>POSITION</strong></p>
<p>• <strong>BLENDWEIGHT</strong></p>
<p>• <strong>BLENDINDICES</strong></p>
<p>• <strong>NORMAL</strong></p>
<p>• <strong>PSIZE</strong></p>
<p>• <strong>TEXCOORD</strong></p>
<p>• <strong>TANGENT</strong></p>
<p>• <strong>BINORMAL</strong></p>
<p>• <strong>TESSFACTOR</strong></p>
<p>• <strong>POSITIONT</strong></p>
<p>• <strong>COLOR</strong></p>
<p>• <strong>FOG</strong></p>
<p>• <strong>DEPTH</strong></p>
<p>• <strong>SAMPLE</strong></p>
<p>在类型标记中输入的数据类型映射到枚举类型D3DDECLTYPE，其可能的值如下所示:</p>
<p>• <strong>D3DCOLOR</strong></p>
<p>• <strong>DEC3N</strong></p>
<p>• <strong>FLOAT1</strong></p>
<p>• <strong>FLOAT16_2</strong></p>
<p>• <strong>FLOAT16_4</strong></p>
<p>• <strong>FLOAT2</strong></p>
<p>• <strong>FLOAT3</strong></p>
<p>• <strong>FLOAT4</strong></p>
<p>• <strong>SHORT2</strong></p>
<p>• <strong>SHORT2N</strong></p>
<p>• <strong>SHORT4</strong></p>
<p>• <strong>SHORT4N</strong></p>
<p>• <strong>UBYTE4</strong></p>
<p>• <strong>UBYTE4N</strong></p>
<p>• <strong>UDEC3</strong></p>
<p>• <strong>USHORT2N</strong></p>
<p>• <strong>USHORT4N</strong></p>
<p>例如，xyznuv_d顶点格式的定义如下</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xyznuv_d.xml</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">POSITION</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">NORMAL</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TEXCOORD</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span> FLOAT2 <span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">TEXCOORD</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">COLOR</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">stream</span>&gt;</span> 1 <span class="tag">&lt;/<span class="name">stream</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">offset</span>&gt;</span> 0 <span class="tag">&lt;/<span class="name">offset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span> D3DCOLOR <span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">COLOR</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xyznuv_d.xml</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="22-9-Graphics-settings"><a href="#22-9-Graphics-settings" class="headerlink" title="22.9. Graphics settings"></a><strong>22.9. Graphics settings</strong></h3><p>为了让游戏客户端在最广泛的系统中尽可能平稳地运行，BigWorld的3D引擎暴露了几个参数。玩家可以根据自己特定的硬件配置调整这些内容，以实现视觉质量和游戏响应之间的最佳平衡。</p>
<p>这些参数被称为图形设置，如下所示:</p>
<ul>
<li><p><strong>FAR_PLANE</strong></p>
<p>可选:FAR、MEDIUM、NEAR”</p>
<p>修改观看距离。可视距离按空间定义，此图形选项将可视距离修改为一个因子。这些因素和选项可以在bigworld&#x2F;res&#x2F; system&#x2F;data&#x2F;graphics_settings.xml文件中配置</p>
</li>
<li><p><strong>FLORA_DENSITY</strong></p>
<p>可选:HIGH、MEDIUM、LOW”</p>
<p>将植物群详细信息对象的密度设置为一个因子。这些因素和选项可以在bigworld&#x2F;res&#x2F;system&#x2F;data&#x2F;graphics_settings.xml文件中配置。</p>
</li>
<li><p><strong>FOOT_PRINTS</strong></p>
<p>可选：ON,OFF</p>
<p>开关脚印，开和关</p>
</li>
<li><p><strong>OBJECT_LOD</strong></p>
<p>可选：HIGH,MEDIUM,LOW</p>
<p>对LOD转换的相对距离做一个调整。</p>
</li>
<li><p><strong>SHADER_VERSION_CAP</strong></p>
<p>可选：SHADER_MODEL_3,SHADER_MODEL_2,SHADER_MODEL_1,SHADER_MODEL_0</p>
<p>设置引擎可用的最大着色器模型版本。</p>
<p>如果客户端运行的图形卡只支持Shader Model 1，SHADER_MODEL_0是禁用的。</p>
<p>SHADER_MODEL_0需要具备顶点着色器2.0的能力，无论是软件还是硬件的顶点处理。SM1显卡，如nVidia TI4400，支持硬件顶点处理，但只支持顶点着色器1.1，所以SHADER_MODEL_0选项不能应用。</p>
</li>
<li><p><strong>SHADOWS_COUNT</strong></p>
<p>可用选项:从1到maxCount(定义在shadows.xml）</p>
<p>设置同时可见的动态实体阴影的数量。</p>
</li>
<li><p><strong>SHADOWS_QUALITY</strong></p>
<p>可选：HIGH,MEDIUM,LOW,OFF</p>
<p>设置实体阴影质量。HIGH使用12点滤镜来过滤阴影，MEDIUM使用4点滤镜来过滤阴影，LOW使用1点滤镜来过滤阴影，OFF将阴影关闭。</p>
</li>
<li><p><strong>SKY_LIGHT_MAP</strong></p>
<p>可选：ON,OFF</p>
<p>开启和关闭云阴影。</p>
</li>
<li><p><strong>TERRAIN_SPECULAR</strong></p>
<p>可选：ON,OFF</p>
<p>切换地形反射照明的开关</p>
</li>
<li><p><strong>TERRAIN_LOD</strong></p>
<p>可选：FAR,MEDIUM,NEAR</p>
<p>通过一个因子修改地形地理变形距离。这些因素和选项可以在bigworld&#x2F;res&#x2F;system&#x2F;data&#x2F;terrain2.xml文件中配置。</p>
</li>
<li><p><strong>TERRAIN_MESH_RESOLUTION</strong></p>
<p>可选：HIGH,MEDIUM,LOW</p>
<p>选择要使用的地形分辨率。HIGH使用最高的可用分辨率，MEDIUM使用可用分辨率的一半，LOW使用可用分辨率的四分之一。</p>
</li>
<li><p><strong>TEXTURE_COMPRESSION</strong></p>
<p>可选：ON,OFF</p>
<p>切换纹理压缩开关</p>
</li>
<li><p><strong>TEXTURE_FILTERING</strong></p>
<p>可选：ANISOTROPIC_16X,ANISOTROPIC_8X,ANISOTROPIC_4X,ANISOTROPIC_2X,TRILINEAR,BILINEAR,LINEAR,POINT</p>
<p>选择纹理过滤。通过使用自动变量MinMagFilter, MipFilter和MaxAnisotropy来设置MINFILTER, MAGFILTER, MipFilter和MaxAnisotropy的采样状态，着色器可以利用这个设置来修改。详情请参见bigworld&#x2F;res&#x2F;shaders&#x2F;speedtree&#x2F; speedtree.fx。</p>
</li>
<li><p><strong>TEXTURE_QUALITY</strong></p>
<p>可选：HIGH,MEDIUM,LOW</p>
<p>设置纹理质量等级</p>
</li>
<li><p><strong>SPEEDTREE_QUALITY</strong></p>
<p>可选：VERYHIGH,HIGH,MEDIUM,LOW,LOWEST</p>
<p>设置速度树(speed tree)渲染的质量。VERYHIGH在所有树的部分上启用每像素照明(法线映射)，HIGH只在树的分支上启用每像素照明(法线映射)，MEDIUM Trees使用简单的照明，LOW Trees使用简单的动画和照明，使用固定的功能管道。</p>
</li>
<li><p><strong>WATER_QUALITY</strong></p>
<p>可选：HIGH,MEDIUM,LOW,LOWEST</p>
<p>设置水反射渲染的质量。HIGH表示允许绘制所有对象类型，MEDIUM表示不允许绘制动态对象，LOW表示不允许绘制动态对象，将渲染目标分辨率减半。LOWEST只呈现镜面反射。</p>
</li>
<li><p><strong>WATER_SIMULATION</strong></p>
<p>可选：HIGH,MEDIUM,OFF</p>
<p>设置水模拟的质量。HIGH表示细胞间水分模拟，MEDIUM表示细胞间水分模拟，OFF表示关闭水分模拟。</p>
</li>
<li><p><strong>POST_PROCESSING</strong></p>
<p>可选：HIGH,MEDIUM,LOW,OFF</p>
<p>设置默认的后处理链。这些是从chains文件夹中选择的，例如:bigworld&#x2F;res&#x2F;system&#x2F;post_processing&#x2F;chains&#x2F;high_graphics_setting.xml。如果您想编辑默认的后处理，那么就在那里编辑三个链文件。每个链有两个版本，一个有FXAA，一个没有，请参阅下面的FXAA_PROCESSING</p>
</li>
<li><p><strong>FXAA_PROCESSING</strong></p>
<p>可选：ON,OFF</p>
<p>设置FXAA（快速近似抗混叠）是否在后处理链中</p>
</li>
<li><p><strong>MRT_DEPTH</strong></p>
<p>可选：ON,OFF</p>
<p>允许创建深度纹理(通过DepthTex语义向.fx文件公开)。这可以实现各种高级的后期处理效果，如景深和深度淡出，以及基于深度的水着色。</p>
</li>
</ul>
<h4 id="22-9-1-Customising-options"><a href="#22-9-1-Customising-options" class="headerlink" title="22.9.1. Customising options"></a><strong>22.9.1. Customising options</strong></h4><p>尽管大多数这些设置都在引擎中确定了它们的选项，但有些设置可以通过配置文件定制它们的选项。</p>
<p>这些设置及其自定义将在以下主题中讨论。</p>
<h5 id="22-9-1-1-TEXTURE-QUALITY-and-TEXTURE-COMPRESSION"><a href="#22-9-1-1-TEXTURE-QUALITY-and-TEXTURE-COMPRESSION" class="headerlink" title="22.9.1.1. TEXTURE_QUALITY and TEXTURE_COMPRESSION"></a><strong>22.9.1.1.</strong> <strong>TEXTURE_QUALITY</strong> <strong>and</strong> <strong>TEXTURE_COMPRESSION</strong></h5><p>TEXTURE_QUALITY和TEXURE_COMPRESSION的设置都是通过纹理格式(.texformat)和细节级别(texture_detail_level.xml)文件来定制的(关于该文件的语法，请参阅 File Grammar Guide’s section <em>.texformat</em>)。</p>
<p>降低纹理质量和使用压缩格式有助于通过减少存储纹理所需的内存数量来提高引擎性能。这意味着每帧需要发送到显卡的数据更少，最终提高了帧速率。</p>
<p>TEXURE_QUALITY通过阻止它的最高mipmap级别被加载来调整纹理的分辨率。这意味着，在最高的质量水平上，纹理将具有与原始纹理贴图相同的分辨率。在中等水平，它的规模将只有原来的一半，质量将是最低水平的四分之一。</p>
<p>在每个纹理的每个质量级别中跳过多少mipmap级别可以由纹理的detailLevel部分中的lodMode标记控制。</p>
<p>下表列出了lodMode可以假设的值，在每个纹理质量设置级别跳过mipmaps的数量旁边:</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Description</th>
<th>High quality</th>
<th>Medium quality</th>
<th>Low quality</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Normal</td>
<td>0</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>2</td>
<td>Low bias</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>High bias</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
</tbody></table>
<p><em>每个质量设 <strong>setting level</strong>&#x2F; <strong>LOD level</strong> 跳过mipmap的数量</em></p>
<p>TEXURE_COMPRESSION影响在内存中存储纹理贴图的格式。当纹理压缩被禁用时，所有的纹理都使用纹理detailLevel部分的format标签定义的格式存储。当启用纹理压缩时，将使用formatCompressed定义的格式。如果没有为纹理定义formatCompressed，则使用format，无论压缩设置是什么。</p>
<p>注意，对于format和formatCompressed使用的纹理格式没有限制，但是为了使纹理压缩设置产生显著的性能结果，formatCompressed应该定义一个比非压缩格式占用更少纹理内存的纹理格式。</p>
<p>关于如何设置纹理的细节级别的详细信息，请参阅Texture detail levels&#x2F;compression 关于配置文件语法的详细信息，请参见 File Grammar Guide’s section <em>.texfor.mat</em>.。</p>
<h5 id="22-9-1-2-SHADOWS-COUNT"><a href="#22-9-1-2-SHADOWS-COUNT" class="headerlink" title="22.9.1.2. SHADOWS_COUNT"></a><strong>22.9.1.2.</strong> <strong>SHADOWS_COUNT</strong></h5><p>SHADOWS_COUNT定义了场景中同时动态实体阴影投射的最大数量。</p>
<p>使用阴影缓冲区渲染阴影，因此消耗纹理内存。在每一帧填充缓冲区需要为每个阴影投射者重新渲染场景。减少同时动态阴影投射器的数量可以减少内存需求和用于更新每帧缓冲区的处理量。</p>
<p>取值范围从1到shadows.xml文件中指定的值maxCount ，通过两个步骤(定义在shadows.xml中-关于该文件语法的详细信息，请参阅File Grammar Guide’s section <em>shadows.xml</em>).。</p>
<h5 id="22-9-1-3-FLORA-DENSITY"><a href="#22-9-1-3-FLORA-DENSITY" class="headerlink" title="22.9.1.3. FLORA_DENSITY"></a><strong>22.9.1.3.</strong> <strong>FLORA_DENSITY</strong></h5><p>FLORA_DENSITY定义了用于渲染flora详细信息对象的顶点缓冲区的大小。</p>
<p>因为植物群绘制到相机的距离是固定的，定义顶点缓冲区的大小也决定了植物群的密度。因为它使用alpha混合，绘制植物群会对帧渲染时间产生负面影响，特别是在填充率性能有限的硬件上。在任何时候减少渲染的植物群数量可以帮助提高帧率。</p>
<p>Flora密度选项在<graphics_settings>.xml中定义(关于这个文件的语法细节，请参阅File Grammar Guide’s section “*<graphics_settings><em>.xml”) 作为顶点缓冲区的乘数，它的实际大小是在&lt; Flora &gt;.xml中每个空间定义的(关于这个文件的语法细节，请参阅File Grammar Guide’s section “</em>&lt;flora&gt;*.xml”).。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">graphics_settings.xml</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">flora</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span> HIGH <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span> 1.0 <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span> LOW <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span> 0.5 <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span> OFF <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span> 0 <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">flora</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">graphics_settings.xml</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><em>Example <graphics_settings>.xml — Configuring flora density</em></p>
<h5 id="22-9-1-4-FAR-PLANE"><a href="#22-9-1-4-FAR-PLANE" class="headerlink" title="22.9.1.4. FAR_PLANE"></a><strong>22.9.1.4.</strong> <strong>FAR_PLANE</strong></h5><p>FAR_PLANE定义了渲染3D世界时的最大观看距离。</p>
<p>减少观看距离会减少发送到渲染管道的几何图形数量，从而产生更高的帧率。</p>
<p>因为远平面距离可以在每个空间的基础上定义， FAR_PLANE实际上是乘以空间的特定远平面值，然后应用到相机上。</p>
<p>在<graphics_settings>.xml中指定(关于该文件语法的详细信息，请参阅File Grammar Guide’s section “*<graphics_settings>*.xml”),，远平面可以配置如下示例:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">graphics_settings.xml</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">farPlane</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span> 1.0 <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span> FAR <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span> 0.75 <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span> MEDIUM <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span> 0.5 <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span> NEAR <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">farPlane</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">graphics_settings.xml</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><em>Example <graphics_settings>.xml — Configuring far plane</em></p>
<h5 id="22-9-1-5-OBJECT-LOD"><a href="#22-9-1-5-OBJECT-LOD" class="headerlink" title="22.9.1.5. OBJECT_LOD"></a><strong>22.9.1.5.</strong> <strong>OBJECT_LOD</strong></h5><p>OBJECT_LOD定义在LOD转换发生之前到摄像机的相对距离。</p>
<p>对于标准的BigWorld模型，LOD距离是使用模型编辑器定义的。粒子编辑器用于设置粒子系统的LOD距离(系统仍然可见的最大距离)。SpeedTree的LOD级别和转换距离在SpeedTreeCAD中定义(尽管它们可以被SpeedTree的XML配置文件覆盖，该配置文件在resources.xml文件的speedTreeXML标记中指定。有关该文件的详细信息，请参阅resources.xml)。</p>
<p>OBJECT_LOD设置指定将在运行时修改这些距离的乘数，允许用户用一些视觉质量换取更好的性能。</p>
<p>LOD乘数在<graphics_settings>.xml中定义(关于该文件语法的详细信息，请参阅File Grammar Guide’s section “*<graphics_settings>*.xml”):</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">graphics_settings.xml</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">objectLOD</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span> 1.0 <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span> HIGH <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span> 0.66 <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span> MEDIUM <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span> 0.33 <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span> LOW <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">objectLOD</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">graphics_settings.xml</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><em>Example <graphics_settings>.xml — Configuring object LOD</em></p>
<h4 id="22-9-2-Using-settings"><a href="#22-9-2-Using-settings" class="headerlink" title="22.9.2. Using settings"></a><strong>22.9.2. Using settings</strong></h4><p>在启动时，客户端自动尝试从磁盘加载图形设置。所有图形设置都存储在resources.xml的engineConfigXML标记中指定的文件的preferences标记中指定的文件的graphicsPreferences部分(详细信息，请参阅“file &lt;preferences&gt;.xml”)。应用程序第一次运行时，当显卡或其驱动程序发生变化时，图形设置将尝试自动检测最适合设备的设置。</p>
<p>另一方面，保存不是自动执行的;必须从脚本控制，使用BigWorld.savePreferences 方法，它将保存图形设置和视频和脚本的首选项。</p>
<p>游戏脚本可以使用函数BigWorld.graphicsSettings 和 BigWorld.setGraphicsSettings 去查询和更改设置的当前状态(通常通过图形用户界面)。</p>
<h5 id="22-9-2-1-Auto-detecting-settings"><a href="#22-9-2-1-Auto-detecting-settings" class="headerlink" title="22.9.2.1. Auto-detecting settings"></a><strong>22.9.2.1. Auto-detecting settings</strong></h5><p>通过resources.xml中的标记graphicsSettingsPresets指定的xml配置文件，支持设置的自动检测。这个文件定义了匹配条件，试图将一组设置与特定的设备(显卡)匹配。有三种不同的方式将一组设置与设备匹配。所有的匹配都是针对D3DADAPTER_IDENTIFIER9结构完成的。自动检测本身在方法Moo::GraphicsSetting::init中执行</p>
<ul>
<li><p>GUID</p>
<p>将特定的设备类型和驱动程序版本匹配到一个设置组，当某个驱动程序&#x2F;设备对存在已知问题时，这是有用的，你可以相应地调整你的图形设置。</p>
</li>
<li><p>VendorID&#x2F;DeviceID pair</p>
<p>将特定的设备类型匹配到设置，当你知道特定设备的供应商和设备id时，这是有用的。</p>
</li>
<li><p>Device description string</p>
<p>将字符串匹配到设备描述，所有的字符串都需要匹配到要选择的设置</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">graphicsPreferences</span>&gt;</span> HIGH </span><br><span class="line">    <span class="tag">&lt;<span class="name">entry</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span> CLASSIC_TERRAIN_QUALITY <span class="tag">&lt;/<span class="name">label</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">activeOption</span>&gt;</span> 0 <span class="tag">&lt;/<span class="name">activeOption</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">GUIDMatch</span>&gt;</span> 01234567.89abcdef.01234567.89abcdef <span class="tag">&lt;/<span class="name">GUIDMatch</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">VendorDeviceIDMatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">VendorID</span>&gt;</span> 4318 <span class="tag">&lt;/<span class="name">VendorID</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">DeviceID</span>&gt;</span> 1554 <span class="tag">&lt;/<span class="name">DeviceID</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">VendorDeviceIDMatch</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">DeviceDescriptionMatch</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span> nvidia <span class="tag">&lt;/<span class="name">string</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span> 6800 <span class="tag">&lt;/<span class="name">string</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">DeviceDescriptionMatch</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">defaultSetting</span>&gt;</span> true <span class="tag">&lt;/<span class="name">defaultSetting</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">graphicsPreferences</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="22-9-2-2-GraphicsPresets-class"><a href="#22-9-2-2-GraphicsPresets-class" class="headerlink" title="22.9.2.2. GraphicsPresets class"></a><strong>22.9.2.2.</strong> <strong>GraphicsPresets</strong> <strong>class</strong></h5><p>还提供了一个简单的python图形预设类。该类有助于将多个图形设置分组在一起，以便您可以为特定硬件或性能级别的多个图形选项提供预定义设置。GraphicsPresets类可以在bigworld&#x2F;res&#x2F; scripts&#x2F;GraphicsPresets.py文件夹中找到。</p>
<h5 id="22-9-2-3-Delayed-settings"><a href="#22-9-2-3-Delayed-settings" class="headerlink" title="22.9.2.3. Delayed settings"></a><strong>22.9.2.3. Delayed settings</strong></h5><p>大多数设置在调用BigWorld.setGraphicsSettings后立即生效。但有些只是标记为延迟。这意味着在被设置之后，它们会被添加到待处理设置的列表中，并且只有当该列表被提交时，它们才会生效。</p>
<p>这样设计是为了让界面程序员有机会警告用户，在客户端应用程序阻塞几秒钟之前，处理新设置可能需要一段时间才能完成(目前，不支持在处理设置时显示进度条)。</p>
<p>以下函数允许脚本管理挂起的设置列表:</p>
<ul>
<li><strong>BigWorld.hasPendingGraphicsSettings</strong></li>
<li><strong>BigWorld.commitPendingGraphicsSettings</strong></li>
<li><strong>BigWorld.rollBackPendingGraphicsSettings</strong></li>
</ul>
<h5 id="22-9-2-4-Settings-that-require-restarting-the-client"><a href="#22-9-2-4-Settings-that-require-restarting-the-client" class="headerlink" title="22.9.2.4. Settings that require restarting the client"></a><strong>22.9.2.4. Settings that require restarting the client</strong></h5><p>某些设置只有在重新启动客户端应用程序后才会被应用。当客户端需要重新启动最近更改的设置以生效时，函数BigWorld.graphicsSettingsNeedRestart将返回true。</p>
<h3 id="22-10-Taking-Screenshots"><a href="#22-10-Taking-Screenshots" class="headerlink" title="22.10. Taking Screenshots"></a><strong>22.10. Taking Screenshots</strong></h3><p>BigWorld客户端能够截屏并将其保存为多种不同的格式。它通过在调用截图操作时检索后台缓冲区的当前内容来实现这一点。要在游戏中截图，请按下PrtScn按钮，或使用 BigWorld.screenShot(<em>extension</em>, <em>name</em>)Python API函数。</p>
<p>默认的图像类型、文件名前缀和输出位置都在engine_config.xml中配置(参见” <engine_config>.xml”)。&lt;screenShot&gt;标签的模式是:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">engine_config.xml</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">screenShot</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">path</span>&gt;</span> relativePath</span><br><span class="line">            <span class="tag">&lt;<span class="name">pathBase</span>&gt;</span> basePathName <span class="tag">&lt;/<span class="name">pathBase</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">path</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span> prefixName <span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">extension</span>&gt;</span> extension <span class="tag">&lt;/<span class="name">extension</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">screenShot</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">engine_config.xml</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>relativePath</strong></p>
<p>这是相对于basePath的输出路径(概述如下)。例如，如果relativePath是MY_DOCS，你可以设置它为“ “My Company&#x2F;Game Name&#x2F;Screenshots”。留空或指定”.&#x2F;“直接放置在basePathName中(这是默认行为)。</p>
</li>
<li><p><strong>basePathName</strong></p>
<ul>
<li><p>EXE_PATH </p>
<p>相对于客户端可执行文件位置的截图。如果没有提供，这是默认位置。</p>
</li>
<li><p>CWD</p>
<p>截图将相对于当前工作目录存储。注意，如果工作目录在运行时发生更改，它将保存在新的工作目录中。</p>
</li>
<li><p>ROAMING_APP_DATA</p>
<p>截图将相对于当前用户的roaming AppData目录存储。换句话说，如果用户在域上，当用户登录和退出Windows时，数据将与域控制器同步。</p>
</li>
<li><p>LOCAL_APP_DATA</p>
<p>截图将相对于当前用户的local AppData目录存储。</p>
</li>
<li><p>APP_DATA</p>
<p>这与ROAMING_APP_DATA相同。</p>
</li>
<li><p>MY_DOCS</p>
<p>截图将相对于当前用户的My Documents目录存储。</p>
</li>
<li><p>MY_PICTURES</p>
<p>截图将相对于当前用户的“我的图片”目录存储。</p>
</li>
<li><p>RES_TREE</p>
<p>截图将相对于paths.xml中找到的第一个资源路径存储。</p>
</li>
</ul>
<p>默认值为“EXE_PATH”。</p>
</li>
<li><p><strong>prefixName</strong></p>
<p>指定生成有编号的屏幕截图时使用的前缀。系统默认值为shot。</p>
</li>
<li><p><strong>extension</strong></p>
<p>指定保存屏幕截图时使用的文件格式。这可以是bmp，“jpg”、“tga”、“png”或“dds”。默认值为“bmp”。</p>
</li>
</ul>
<p>因此，生成的截图的完整路径将是basePathName&#x2F;relativePath&#x2F;prefixName_&lt;sequence&gt;。扩展，其中&lt;sequence&gt;是一个四位数非负整数，用前导零填充(例如，shot_0012.bmp)。屏幕捕获机制不会覆盖现有的文件。</p>
<h4 id="22-10-1-High-Resolution-Screenshots"><a href="#22-10-1-High-Resolution-Screenshots" class="headerlink" title="22.10.1. High Resolution Screenshots"></a><strong>22.10.1. High Resolution Screenshots</strong></h4><p>通常情况下，在全屏模式下，后台缓冲区的大小与窗口或屏幕分辨率相同。然而，当在窗口模式下运行时，有可能有一个比窗口本身更大的后缓冲区，从而增加屏幕截图的大小。</p>
<h3 id="22-11-Dynamic-Entity-Shadows"><a href="#22-11-Dynamic-Entity-Shadows" class="headerlink" title="22.11. Dynamic Entity Shadows"></a><strong>22.11. Dynamic Entity Shadows</strong></h3><p>客户端支持两种不同的方式来允许实体模型将阴影投射到场景中。您选择使用的方法取决于目标硬件，因为它们的成本差别很大。</p>
<p><strong>22.11.1. Splodges</strong></p>
<p>这个系统的工作原理是在实体模型脚下的几何图形上绘制一个特殊的“污渍”纹理，投影在太阳的方向(它们只有在外部块是可见的)。这是一个很好的低端解决方案，因为它们绘制起来很便宜，但是它们只会提供一个粗略的阴影近似值。</p>
<p>通过使用PySplodge API，可以将插件添加到实体模型中。PySplodge类是一种连接类型，连接到实体模型的脚(每脚一个)。例如:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lsplodge = BigWorld.Splodge()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rsplodge = BigWorld.Splodge()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>model.node( <span class="string">&quot;biped L Toe0&quot;</span> ).attach( lsplodge )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>model.node( <span class="string">&quot;biped R Toe0&quot;</span> ).attach( rsplodge )</span><br></pre></td></tr></table></figure>

<p>虽然所有的splodge都使用相同的材质来绘制(这可以通过修改resources.xml中的environment&#x2F;splodgeMaterial部分来配置)，每个PySplodge实例可以修改以下参数:</p>
<ul>
<li>距离相机的最大LOD距离，在此之后它们被剔除。默认为50米。</li>
<li>单个污迹的大小。</li>
</ul>
<p><em><strong>由于碰撞场景被用来确定在哪里绘制污损，只有固体物体会接收污损阴影。</strong></em></p>
<h4 id="22-11-2-Shadow-maps"><a href="#22-11-2-Shadow-maps" class="headerlink" title="22.11.2. Shadow maps"></a><strong>22.11.2. Shadow maps</strong></h4><p>实体模型可以被配置，这样它们就可以根据太阳光线的方向，利用动态阴影地图，将阴影投射到场景中。每一帧引擎将选择一组最接近相机的阴影投射实体，其数量通过SHADOWS_COUNT图形设置配置。对于每个阴影投射器，它会根据光线的方向将投射器渲染成纹理，然后通过重新渲染每个与阴影相交的物体将这个纹理投射到场景中(使用阴影贴图作为输入)。</p>
<p>为了投射阴影，实体必须显式地添加到实体阴影管理器中。提供了两个Python API:</p>
<ul>
<li><p>BigWorld.addShadowEntity </p>
<p>这通常从onEnterWorld实体回调调用</p>
</li>
<li><p>BigWorld.delShadowEntity</p>
<p>这通常从onLeaveWorld实体回调调用。</p>
</li>
</ul>
<p>全局阴影设置(如阴影贴图分辨率、强度和着色器)在阴影中配置</p>
<p>XML文件(定义在shadows.xml中)-关于该文件语法的详细信息，请参阅(File GrammarGuide’s section <em>shadows.xml</em>).</p>
<p>用户可控制的图形设置是SHADOWS_COUNT和SHADOWS_QUALITY。详情请参阅“Graphics settings”。</p>
<p><em><strong>阴影将投射到地形、实体模型和植物上。排序三角形(即半透明物体)将不会投射或接收阴影。</strong></em></p>
<p><em><strong>请记住，使用实体阴影的费用会随着渲染阴影实体的数量增加而增加，所以建议保持将SHADOWS_COUNT设置得尽可能低以保持性能。因此，这并不是一个通用的全场景阴影系统。</strong></em></p>
<h2 id="23-Post-Processing"><a href="#23-Post-Processing" class="headerlink" title="23. Post Processing"></a>23. <strong>Post Processing</strong></h2><p>后期处理效果广泛应用于所有现代游戏，并有许多应用-从HDR色调映射和颜色校正到卡通效果，可能性几乎是无限的。</p>
<p>BigWorld Technology支持后期处理链的完整用户定制，支持艺术家通过内置编辑工具，支持程序员通过提供对python中的每个参数的完全控制，并以DirectX&#x2F;HLSL效果文件的方式提供插入着色器。</p>
<p>然而，在你开始创建自己的新的时髦效果之前，你需要考虑一下。效果应该很好地结合在一起，它们应该在可能的情况下重用呈现目标，并且您需要监视性能。</p>
<h3 id="23-1-Pipeline-Overview"><a href="#23-1-Pipeline-Overview" class="headerlink" title="23.1. Pipeline Overview"></a><strong>23.1. Pipeline Overview</strong></h3><p>在不透明场景、半透明和镜头效果之后，在GUI绘制之前,PostProcessing::Manager绘制其当前链。链包含按顺序绘制的效果列表。在内部，每个效果都包含一个按顺序绘制的阶段列表。一个阶段通常使用效果文件将一个全屏四边形绘制到屏幕上，尽管也有其他转移网格可用。</p>
<p>后处理的实现分为三个部分。核心是用c++编写的，在bigworld&#x2F;src&#x2F; lib&#x2F;post_processing库中。所有的特性都通过_PostProcessing模块向python公开。</p>
<p>在Python中，PostProcessing模块存在于bigworld&#x2F;res&#x2F;scripts&#x2F;client&#x2F;PostProcessing中，并从PostProcessing导入所有的方法。这允许您重写或包装任何c++方法。因此，所有的python调用都应该指向PostProcessing，而不是PostProcessing。</p>
<p>默认情况下，PostProcessing模块注册3个图形设置。如果用户选择高&#x2F;中&#x2F;低，则加载适当的后处理链。这些在bigworld&#x2F;res&#x2F;system&#x2F;post_processing&#x2F; chains&#x2F;和**”High Graphics Setting.ppchain”, “Medium Graphics Setting.ppchain” and “Low Graphics Setting.ppchain”**因此，通过在World Editor中创建新链并保存在这些文件的顶部，开发人员可以很容易地重新定义默认的后处理链。</p>
<p> 一般来说，我们都希望游戏能够结合使用默认的后期处理链文件，并动态地将其与游戏玩法相关的效果混合在一起。为了实现这一点，请遵循PostProcessing模块中的示例。另外，看看PyMaterial的Python API，因为它将演示如何平稳地淡入&#x2F;淡出动态后期处理效果。</p>
<p>最后在世界编辑器，后期处理选项卡是一个功能齐全的编辑器和预览工具链。它加载并保存.ppchain文件。</p>
<h3 id="23-2-Creating-a-Custom-Post-Processing-Effect"><a href="#23-2-Creating-a-Custom-Post-Processing-Effect" class="headerlink" title="23.2. Creating a Custom Post-Processing Effect"></a><strong>23.2. Creating a Custom Post-Processing Effect</strong></h3><p>虽然《BigWorld》带有一套基本的后期处理着色器，阶段和效果，但你可能会发现自己需要执行一种独特的游戏效果。</p>
<p>对于这个例子，我们将创建一个后期处理，将反转屏幕上的所有颜色。</p>
<p>我们将创作一个后期处理效果，可以添加作为客户的整体后期处理链的一部分，我们将写一个自定义着色器，执行实际的颜色倒置。</p>
<h4 id="23-2-1-Creating-the-Custom-Pixel-Shader"><a href="#23-2-1-Creating-the-Custom-Pixel-Shader" class="headerlink" title="23.2.1. Creating the Custom Pixel Shader"></a><strong>23.2.1. Creating the Custom Pixel Shader</strong></h4><p>那么我们如何让GPU反转屏幕上所有的颜色呢?</p>
<p>因为BigWorld客户端支持插入DirectX Effect文件(.fx)，所以这一步相对简单。我们所需要做的就是编写一个.fx文件，它接受一个输入纹理，转换颜色，然后输出该值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">float4 <span class="title">ps_invert</span><span class="params">(PS_INPUT input)</span> : COLOR0</span></span><br><span class="line"><span class="function">&#123;</span></span><br><span class="line"> float4 map = <span class="built_in">tex2D</span>(inputTextureSampler, input.tc0);</span><br><span class="line"> float4 invMap = <span class="built_in">float4</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>) - map;</span><br><span class="line"> invMap.w = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">return</span> invMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，这是简单的部分。这个像素着色器假设了一些事情，即顶点着色器通过一组纹理坐标，有一个读取正确纹理映射的采样器，有一个定义好的PS_INPUT结构。</p>
<p>幸运的是，通过包括文件post_processing.fxh的效果，所有这些都得到了处理。(bigworld&#x2F;res&#x2F;shaders&#x2F;post_processing&#x2F;post_processing.fxh)</p>
<p>使用像素着色器的完整效果是相当直接的，看起来像这样:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;post_processing.fxh&quot;</span></span></span><br><span class="line"><span class="built_in">DECLARE_EDITABLE_TEXTURE</span>( inputTexture, inputSampler, CLAMP, CLAMP, LINEAR,<span class="string">&quot;Input texture/render target&quot;</span> )</span><br><span class="line"><span class="function">float4 <span class="title">ps_invert</span><span class="params">(PS_INPUT input)</span> : COLOR0</span></span><br><span class="line"><span class="function">&#123;</span></span><br><span class="line">    float4 map = <span class="built_in">tex2D</span>(inputSampler, input.tc0);</span><br><span class="line">    float4 invMap = <span class="built_in">float4</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>) - map;</span><br><span class="line">    invMap.w = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> invMap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">STANDARD_PP_TECHNIQUE</span>(compile vs_2_0 <span class="built_in">vs_pp_default</span>(), compile <span class="built_in">ps_2_0ps_invert</span>())</span><br></pre></td></tr></table></figure>

<p>着色器也可以在FX Composer中通过添加以下内容来编辑:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FX_COMPOSER 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;post_processing.fxh&quot;</span></span></span><br><span class="line"><span class="function">FX_COMPOSER_STANDARD_VARS</span></span><br><span class="line"><span class="function"><span class="title">DECLARE_EDITABLE_TEXTURE</span><span class="params">( inputTexture, inputSampler, CLAMP, CLAMP, LINEAR,<span class="string">&quot;Input texture/render target&quot;</span> )</span></span></span><br><span class="line"><span class="function">float4 <span class="title">ps_invert</span><span class="params">(PS_INPUT input)</span> : COLOR0</span></span><br><span class="line"><span class="function">&#123;</span></span><br><span class="line"> float4 map = <span class="built_in">tex2D</span>(inputSampler, input.tc0);</span><br><span class="line"> float4 invMap = <span class="built_in">float4</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>) - map;</span><br><span class="line"> invMap.w = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">return</span> invMap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">STANDARD_PP_TECHNIQUE</span>(compile vs_2_0 <span class="built_in">vs_pp_default</span>(), compile <span class="built_in">ps_2_0ps_invert</span>())</span><br><span class="line"><span class="built_in">STANDARD_FX_COMPOSER_TECHNIQUE</span>(compile vs_2_0 <span class="built_in">vs_pp_default</span>(), compile <span class="built_in">ps_2_0ps_invert</span>(), <span class="string">&quot;RenderColorTarget0=inputTexture;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>在FX Composer设置中，添加post_processing的路径。FXH和其他后期处理头到您的包括路径。注释#define FX_COMPOSER 1在客户端或世界编辑器中使用着色器。</p>
<h4 id="23-2-2-Previewing-the-Results"><a href="#23-2-2-Previewing-the-Results" class="headerlink" title="23.2.2. Previewing the Results"></a><strong>23.2.2. Previewing the Results</strong></h4><p>由于后处理链包含许多阶段，这些阶段通常写入中间的、不可见的呈现目标，因此通常希望看到后处理效果或链的中间结果。有两个方法可用于此目的，PostProcessing.debug()和World Editor的预览功能。</p>
<p>在客户端中，您可以用_PostProcessing模块注册一个任意大小的呈现目标，并让它记录所有中间步骤。然后可以通过在GUI中显示来查看这个呈现目标。一个辅助类，ChainView，在PostProcessing模块中可用，这将在屏幕上实时显示整个链。</p>
<p>在World Editor中，后处理编辑器中有一个预览按钮，它显示编辑图中每个阶段节点内的中间结果。</p>
<h4 id="23-2-3-Writing-a-Custom-Pixel-Shader-for-Previewing-the-Results"><a href="#23-2-3-Writing-a-Custom-Pixel-Shader-for-Previewing-the-Results" class="headerlink" title="23.2.3. Writing a Custom Pixel Shader for Previewing the Results"></a><strong>23.2.3. Writing a Custom Pixel Shader for Previewing the Results</strong></h4><p>有时候，这种简单的预览并不合适。默认情况下，预览直接显示每个阶段的像素着色器的输出。然而，通常中间步骤的输出被写入一个不直接映射到可见颜色范围的浮点呈现目标，其他时候以特定的方式编码的信息不是直接可见的。</p>
<p>以景深镜头模拟为例。一种可能的实现可能是解码深度缓冲，并将场景分为7个单独的区域，3级模糊在焦距前，对焦内和3级模糊后。该信息可以写入单组件浮点呈现目标，并包含-3到+3之间的值。</p>
<p>当一个像素着色器的输出不直接可见时，你可以创建另一个用于预览功能的像素着色器。要做到这一点，你需要为你的效果添加一种新技术。这种技术必须称为“预览”，如果可用，将在预览后处理链时代替主要技术。这种技术输出的数据在普通R8G8B8A8渲染目标上和在屏幕上查看时都是可见的。</p>
<p>在上面的例子中，您可以编写一个预览技术，在焦点范围前的模糊区域显示3个深浅的红色，在所有焦点区域显示全绿色，在焦点范围后的所有模糊区域显示3个深浅的蓝色。</p>
<h4 id="23-2-4-Authoring-a-Post-Processing-Effect-in-Python"><a href="#23-2-4-Authoring-a-Post-Processing-Effect-in-Python" class="headerlink" title="23.2.4. Authoring a Post-Processing Effect in Python"></a><strong>23.2.4. Authoring a Post-Processing Effect in Python</strong></h4><p>那么现在我们如何获得在后期处理时操纵屏幕的新效果呢?我们必须编写一个PostProcessing::Effect。大多数情况下，这将通过世界编辑器中的后期处理编辑器完成。世界编辑器保存.ppchain文件，这些文件包含效果和阶段链，可以简单地加载并设置为当前的后期处理链。然而，知道如何使用Python API也很有用，因为你确实可以访问整个链，通常你会想要将后期处理效果直接绑定到游戏逻辑。这也有助于理解发生了什么。</p>
<p>对于这个示例效果，我们必须用反向缓冲区中任何颜色的倒数来写入反向缓冲区中的每一个像素。</p>
<p>PC硬件无法读取正在写入的同一个纹理，所以我们需要首先抓取一个回缓冲区的副本，并将其存储在另一个纹理中。</p>
<p>这段python代码创建了一个CopyBackBuffer阶段，创建了一个与返回缓冲区大小相同的渲染目标，并将两者挂钩起来。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PostProcessing</span><br><span class="line">phase1 = PostProcessing.CopyBackBuffer()</span><br><span class="line">bbcRT = BigWorld.RenderTarget(<span class="string">&quot;backBufferCopy&quot;</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">phase1.renderTarget = bbcRT</span><br></pre></td></tr></table></figure>

<p>在世界编辑器中，我们可以简单地将“BackBufferCopy”阶段放入效果中，然后就完成了。</p>
<p>注意，在这种情况下，我们创建了一个新的渲染目标，但通常你想要在效果和阶段之间共享渲染目标，特别是像上面这样的全屏渲染目标。所以我们可以像这样使用RenderTargets模块，而不是创建一个渲染目标:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bbcRT = PostProcessing.RenderTargets.rt(<span class="string">&quot;backBufferCopy&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>现在我们有了一个后缓冲的副本，我们可以读取它作为纹理，现在是时候做我们的颜色反转了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">phase2 = PostProcessing.Phase()</span><br><span class="line">phase2.material = BigWorld.Material(<span class="string">&quot;shaders/post_processing/colour_invert.fx&quot;</span>)</span><br><span class="line">phase2.material.inputTexture = phase1.renderTarget.texture</span><br><span class="line">phase2.renderTarget = <span class="literal">None</span></span><br><span class="line">phase2.filterQuad = PostProcessing.TransferQuad()</span><br></pre></td></tr></table></figure>

<p>这个代码示例创建了一个新阶段，这次是一个通用的PyPhase对象。PyPhase对象有一个PyMaterial和一个FilterQuad。它使用这些来写入一个RenderTarget。</p>
<p>我们已经从“colour_invert.fx”创建了一个新的PyMaterial”，我们之前编写的着色器。</p>
<p>效果文件使用了一个名为“inputTexture”的纹理变量。因为我们在效果中将这个变量标记为’editable’，它会在python字典中显示。因此，我们可以将它直接设置为返回缓冲区复制渲染目标保存的纹理。</p>
<p>我们已经将这个阶段的renderTarget属性设置为None。具体来说，这意味着“不要设置渲染目标”，在实践中这意味着我们想要直接写入主场景的后台缓冲区，而不是屏幕外的渲染目标。</p>
<p>注意，每当我们写回缓冲区，我们改变它的内容，并且下一个后处理效果或阶段必须使用一个包含这些改变的新副本。BackBufferCopy阶段在内部检测自获取最后一个副本以来，back缓冲区是否被修改。因此，一直使用BackBufferCopy阶段是可以的，如果那个时候实际上不需要那个阶段，也不会有性能损失。</p>
<p>最后阶段使用一个FilterQuad来绘制;它们通常使用n组滤镜，在这种情况下，我们只想从源纹理中读取单个像素，对于输出渲染目标中的每个像素。因此，我们已经创建了一个PyTransferQuad，它只有一个样本点，并且没有偏移。如果我们想做一些纹理过滤，我们可以使用PyFilterQuad代替，并指定n个采样点-每个采样点表示(u-偏移texels, v-偏移texels，权重，未使用)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">colourInvert = PostProcessing.Effect()</span><br><span class="line">colourInvert.phases = [phase1, phase2]</span><br><span class="line">colourInvert.name = <span class="string">&quot;Invert Colours&quot;</span></span><br><span class="line">PostProcessing.chain([colourInvert])</span><br></pre></td></tr></table></figure>

<p>最后的代码示例将我们的两个阶段打包成一个Effect，并将Effect注册为后处理链。从这里开始，屏幕上的颜色将会颠倒。</p>
<h3 id="23-3-Render-Targets"><a href="#23-3-Render-Targets" class="headerlink" title="23.3. Render Targets"></a><strong>23.3. Render Targets</strong></h3><p>后处理链使用的主要资源之一是渲染目标。它们往往是后台缓冲区大小的倍数，并具有不同的表面格式和用途。BigWorld客户端公开了PyRenderTarget类，可用于按需创建自定义渲染目标。请参阅<em>Python Client API</em> 关于如何使用PyRenderTarget的详细说明。</p>
<p>注意，你可以创建尽可能多的渲染目标，因为实际的表面内存只在渲染目标首次用于绘制时分配(通过RenderTarget.push)。因此，您可以定义实际未使用的渲染目标，开销可以忽略不计。但是对于正在使用的渲染目标来说，视频内存会迅速增加，所以在设计后期处理链时需要格外小心。任何特定链使用的总内存可以在世界编辑器中查看，或者通过调用函数PostProcessing.RenderTargets.reportMemoryUsage()。</p>
<p> 在Python中，PostProcessing模块有自己的RenderTargets模块，位于bigworld&#x2F;res&#x2F;scripts&#x2F;client&#x2F;PostProcessing&#x2F;RenderTargets中。如果您想添加更多的呈现目标供后处理链使用，那么请将它们添加到这里的呈现目标列表中。这样做是必要的，因为这是World Editor获取可用后处理呈现目标列表的地方。</p>
<h3 id="23-4-Performance"><a href="#23-4-Performance" class="headerlink" title="23.4. Performance"></a><strong>23.4. Performance</strong></h3><p>在创建后处理链时，需要注意两个主要的性能指标。这些是:内存使用(主要是由渲染目标);以及花在GPU上的时间。渲染目标及其相关的内存使用在前一章中有描述。与往常一样，动态创建的PostProcessing资源应该在后台线程中加载，以避免渲染线程停止。</p>
<h4 id="23-4-1-Measuring-the-Time-Spent-on-the-GPU"><a href="#23-4-1-Measuring-the-Time-Spent-on-the-GPU" class="headerlink" title="23.4.1. Measuring the Time Spent on the GPU"></a><strong>23.4.1. Measuring the Time Spent on the GPU</strong></h4><p>后处理链往往具有较低的CPU成本——包括通过效果和阶段进行的简单迭代和简单的几何设置——但GPU成本较高，使用复杂的像素着色器执行全屏传递和每个像素获取许多纹理。因此，主要的开销通常是GPU带宽:填充率和纹理读取。</p>
<p>BigWorld客户端有一个python API函数，PostProcessing.profile(迭代)，用来测量GPU所花费的时间。参数迭代通常应该在10左右，以确保测量到一个准确的值。由于主要的成本是填充率和纹理获取，这个值取决于屏幕的分辨率，所以需要在不同的gpu和不同的分辨率下进行profile。注意，World Editor在后处理面板上还附带了一个工具栏按钮，该按钮也对链进行了概要分析。</p>
<h4 id="23-4-2-Background-Loading"><a href="#23-4-2-Background-Loading" class="headerlink" title="23.4.2. Background Loading"></a><strong>23.4.2. Background Loading</strong></h4><p>没有直接支持在后台创建.ppchain文件，因为库使用了许多只能在主线程中创建的PyObject指针。相反，可以通过postprocessing .prerequisites()方法来实现对.ppchain文件后台加载的支持。这将从XML文件中提取适当的资源(主要是效果材料)，并返回所需资源的列表，然后可以直接将这些资源传递给BigWorld.loadResourceListBG()。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">filename = <span class="string">&quot;system/post_processing/chains/underwater.ppchain&quot;</span></span><br><span class="line">BigWorld.loadResourceListBG(PostProcessing.prerequisites(filename), onLoadBG)</span><br></pre></td></tr></table></figure>

<p>通过SFX系统加载的后处理链会在后台自动加载。</p>
<p>因为收集PostProcessing先决条件依赖于已经加载的.ppchain文件数据部分，所以建议预先加载所有.ppchain XML文件。</p>
<h2 id="24-Job-System"><a href="#24-Job-System" class="headerlink" title="24. Job System"></a><strong>24. Job System</strong></h2><p><strong>24.1. Overview</strong></p>
<p>Job System允许多核系统中的额外核心执行代码并计算数据，以便及时呈现。它还将D3D命令的问题移动到自己的核心上，而主线程就可以简单地记录它们，以便在下一帧中执行。</p>
<p>一帧的渲染被分成几个块。块按顺序呈现。每个块只有在前一个块完成后才开始。</p>
<p>每个块包含任何D3D渲染命令和相关的顶点和索引缓冲区，纹理，着色常量或任何其他数据。该块可以结合来自主线程的传统D3D渲染和在分配给运行作业的核心上并行运行的作业的输出来生成。</p>
<p>任何数量的jobs都可以产生一个块的输入。由于一次只渲染一个块，并且作业是并行执行的，你应该使用至少与核心数量相同的job，否则会有空闲的核心。一个块中的jobs可以以任何顺序完成，但在所有job完成之前，块不会被呈现。当job执行时，D3D执行前一个块。因此，job核心和D3D核心一直在工作，而同时主线程正在准备另一帧的块和它们对应的job。</p>
<h3 id="24-2-Under-the-Hood"><a href="#24-2-Under-the-Hood" class="headerlink" title="24.2. Under the Hood"></a><strong>24.2. Under the Hood</strong></h3><p>所有渲染命令和jobs都存储在命令缓冲区中。这是通过包装D3D来完成的。所有D3D函数调用都转到包装器，包装器记录下它们在下一帧执行，而与此同时，上一帧的命令在D3D核心的另一个线程中执行。</p>
<p>当刷新时，D3D核心首先会停止读取第一个区块的job结果。与此同时，job集群中的每个核心开始从区块中抢夺job。没有中央分派机制。核心获取任务，并在写完结果后自动为该块减少一个计数器。请注意，job是按顺序获取的，但不一定是按顺序完成的。例如，如果第一个任务需要很长时间，那么第二个任务可能会先完成，这个核心可以开始另一个任务。这意味着在最后一个job完成并将计数器减为零之前，不能保证输出是连续的。</p>
<p>只有这样，D3D核心才能开始处理第一个块的结果，而集群开始操作第二个块，将结果输出到另一个缓冲区。</p>
<p>如果D3D内核先完成，它就会退出缓冲区并暂停，直到下一个缓冲区准备好。如果集群先完成，它就会暂停，直到D3D内核回收它正在消耗的缓冲区，以便接收来自集群的输出。</p>
<h3 id="24-3-Wrapper-API"><a href="#24-3-Wrapper-API" class="headerlink" title="24.3. Wrapper API"></a><strong>24.3. Wrapper API</strong></h3><p>除了包装D3D，包装器还有一个小的API来控制它的行为。</p>
<p>DX::newBlock():启动一个新块。所有来自前一个块(block)的渲染将在这个块开始之前完成，所有用于渲染前一个块的job输出将不再可访问。这意味着所有为这个块产生输出的job必须在下一次调用DX::newBlock()之前分配。</p>
<p>DX::setWrapperFlags()和DX::getWrapperFlags():这些函数获取和设置控制包装器行为的标志。</p>
<p>IMMEDIATE_LOCK:刷新命令缓冲区，然后在主线程中执行锁。如果您不打算填充整个锁定区域，则这是必需的。这是一种非常昂贵的锁定方式，应该尽可能避免。</p>
<p>DEFERRED_LOCK:该标志用于锁定将被作业填充的缓冲区。锁返回的指针只能用于存储到作业中，然后在作业执行时访问。实际的锁在作业执行的下一帧发生。</p>
<h3 id="24-4-Job-System-API"><a href="#24-4-Job-System-API" class="headerlink" title="24.4. Job System API"></a><strong>24.4. Job System API</strong></h3><p>这个Job System API 是通过 JobSystem 单例来访问的. 它通过withJobSystem::instance()获得.</p>
<p>allocJob():该方法将job放入当前块的job列表中，并返回从job派生的用户实现类。它有一个名为execute()的虚函数，实际执行任务。派生类存储job执行所需的任何东西。注意，块中的job不会按顺序执行。</p>
<p>allocOutput():这个job需要产生输出，这是通过allocOutput()预先分配的。它从主线程调用，其结果放置在Job对象中。此时并没有实际分配用于输出的内存，但是在下一帧执行job时，内存就已经准备好了。</p>
<p>在一个块中，可以使用job和输出分配的任意组合。例如，您可以分配一个输出，并将其分配给多个job，反之亦然，或者您喜欢的任何组合。唯一的规则是输出和job必须都来自同一个块。</p>
<h3 id="24-5-An-Example"><a href="#24-5-An-Example" class="headerlink" title="24.5. An Example"></a><strong>24.5. An Example</strong></h3><p>让我们想象一下，我们正在更新和渲染一个简单的粒子系统。这将在一个块内完成。粒子系统由4096个点组成，每个点将被更新并生成一个顶点到顶点缓存中用于渲染。</p>
<p>我们的区块将包括设置一个顶点缓冲区并在其上调用DrawPrimitive。顶点缓冲区将使用job填充。顶点缓冲区将被分为8个部分，每个部分包含512个顶点。每个部分将填写一个job。</p>
<p>主线程：</p>
<ul>
<li>新建Block</li>
<li>使用DEFERRED_LOCK标志锁定4096个点的顶点缓冲区</li>
<li>设置8个job，每个job填写512顶点</li>
<li>设置渲染状态</li>
<li>绘制</li>
<li>重置包装标志</li>
</ul>
<p>以上所有步骤都不是立即执行的，而是在下一帧执行时被记录下来。</p>
<p>Jobs和D3D核心:</p>
<p>在下一帧中，默认块呈现，直到到达粒子的新块。同时执行填充顶点缓冲区的8个job。当到达新的区块和工作完成时，粒子被渲染。与此同时，执行下一个块的job。</p>
<h3 id="24-6-Implementing-it"><a href="#24-6-Implementing-it" class="headerlink" title="24.6. Implementing it"></a><strong>24.6. Implementing it</strong></h3><p>既然我们理解了这个示例的工作原理，那么我们就可以完成实现它的步骤了。</p>
<p>首先，我们需要实现我们的job对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PointSpriteParticleJob</span> : <span class="keyword">public</span> Job</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">( Particle* particles, Moo::VertexXYZDP* pVertex, uint nPoints )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    Particle* particles_;</span><br><span class="line">    Moo::VertexXYZDP* pVertex_;</span><br><span class="line">    uint nPoints_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>job对象继承了虚拟execute()方法，该方法在下一帧被调用，就在D3D内核需要使用作业输出之前。</p>
<p>我们还实现了一个set()方法，该方法从主线程调用并存储execute()中所需的所有信息。</p>
<p>execute()方法将做两件事。它将更新粒子的位置，并将新位置输出到顶点缓冲区。每个给定的任务对象只会对粒子系统和顶点缓冲区的一部分执行此操作，这样整个任务就可以被分成几个任务，并在几个核心上并行执行。</p>
<p>现在我们可以在呈现代码中使用job类了。</p>
<p>我们从一个新的区块开始。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DX::<span class="built_in">newBlock</span>();</span><br></pre></td></tr></table></figure>

<p>现在我们已经准备好对呈现命令进行排队了。</p>
<p>首先，我们需要锁定一个延迟的顶点缓冲区，为此，我们需要在锁定之前设置适当的包装器标志。</p>
<p>通常在锁定时，你会得到一个指针，可以立即使用它来写入顶点数据。然而，我们的顶点数据将在下一帧由job计算，所以锁实际上必须在那个时候发生。因此，我们使用延迟锁，它现在返回一个指针，但直到需要时才执行锁。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uint32 oldFlags = DX::<span class="built_in">getWrapperFlags</span>();</span><br><span class="line">DX::<span class="built_in">setWrapperFlags</span>( DX::WRAPPER_FLAG_DEFERRED_LOCK );</span><br><span class="line">Moo::DynamicVertexBufferBase2&lt;Moo::VertexXYZDP&gt;&amp; vb =</span><br><span class="line">    Moo::DynamicVertexBufferBase2&lt;Moo::VertexXYZDP&gt;::<span class="built_in">instance</span>();</span><br><span class="line">Moo::VertexXYZDP* pVertex = vb.<span class="built_in">lock2</span>( <span class="number">4096</span> );</span><br></pre></td></tr></table></figure>

<p>现在我们准备分配和设置我们的工作。锁中的指针用于设置作业。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( uint i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++ )</span><br><span class="line">&#123;</span><br><span class="line"> job = jobSystem.<span class="built_in">allocJob</span>&lt;UpdateParticlesJob&gt;();</span><br><span class="line"> job.<span class="built_in">set</span>( particles + i*<span class="number">512</span>, vertices + i*<span class="number">512</span>, <span class="number">512</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，我们可以解锁缓冲区，重置包装标志和渲染。</p>
<p>此时，我们可以将分配和设置的job渲染为完成的状态，因为在此之前不会执行以下呈现命令。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vb.<span class="built_in">unlock</span>();</span><br><span class="line">uint32 lockIndex = vb.<span class="built_in">lockIndex</span>();</span><br><span class="line">DX::<span class="built_in">setWrapperFlags</span>( oldFlags );</span><br><span class="line">vb.<span class="built_in">set</span>( <span class="number">0</span> );</span><br><span class="line">Moo::<span class="built_in">rc</span>().<span class="built_in">drawPrimitive</span>( D3DPT_POINTLIST, lockIndex, nPoints );</span><br></pre></td></tr></table></figure>

<h2 id="25-Debugging"><a href="#25-Debugging" class="headerlink" title="25. Debugging"></a><strong>25. Debugging</strong></h2><p>本节介绍BigWorld客户端的一些调试特性。</p>
<p>调试是任何开发过程的重要组成部分，客户端有许多功能，有助于及早发现bug、游戏内调试、远程调试，以及无需重新启动即可立即应用更改。</p>
<p>许多调试功能都是通过一个特殊定义的调试键访问的。默认情况下，调试映射到键盘上的grave (~)键，但是可以通过编辑引擎configuration.XML文件来重新配置。</p>
<h3 id="25-1-Build-configuration-—-conditional-feature-inclusion"><a href="#25-1-Build-configuration-—-conditional-feature-inclusion" class="headerlink" title="25.1. Build configuration — conditional feature inclusion"></a><strong>25.1. Build configuration — conditional feature inclusion</strong></h3><p>BigWorld提供了许多有助于运行时调试的特性，例如调试菜单和telnet Python服务。</p>
<p>要从客户端的最终版本中删除这些特性，需要存在许多编译保护。它们由src&#x2F;lib&#x2F;cstdmf&#x2F;config.hpp中的以下定义共同控制。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONSUMER_CLIENT_BUILD 0</span></span><br></pre></td></tr></table></figure>

<p>如果CONSUMER_CLIENT_BUILD为0，那么将编译开发特性。</p>
<p>各个特性被封装在各自的编译保护中，可以使用上面的定义进行切换。也可以通过将相应的强制启用定义设置为非零值来启用单个特性。</p>
<p>下面的例子说明了这一点:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONSUMER_CLIENT_BUILD 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FORCE_ENABLE_DEBUG_KEY_HANDLER 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENABLE_DEBUG_KEY_HANDLER (!CONSUMER_CLIENT_BUILD \</span></span><br><span class="line"><span class="meta"> || FORCE_ENABLE_DEBUG_KEY_HANDLER)</span></span><br></pre></td></tr></table></figure>

<h3 id="25-2-Watchers"><a href="#25-2-Watchers" class="headerlink" title="25.2. Watchers"></a><strong>25.2. Watchers</strong></h3><p>监视器是一个对象，它将变量或函数结果包装到程序中，并将其转换为字符串。</p>
<p>监视器可以是读写或只读的，可以以各种方式查看。它们的层次结构通常是由功能组织的。还有一些观察器可以动态匹配不断变化的数据，例如序列或映射的内容。</p>
<h4 id="25-2-1-Watcher-types"><a href="#25-2-1-Watcher-types" class="headerlink" title="25.2.1. Watcher types"></a><strong>25.2.1. Watcher types</strong></h4><p>最简单的监视器类型是DirectoryWatcher，它允许创建其他监视器(包括DirectoryWatcher)的目录。这是建立层次结构的一种方式。例如，在BigWorld客户端中由降雨系统绘制的降雨量的一个浮点值被指定在’ Client Settings&#x2F;Rain&#x2F; amount’.它使用三个DirectoryWatchers:根目录、Client Settings目录和Rain目录。</p>
<p>对于任何可以流到std::stream对象上的数据类型，也有模板化的监视器。它们有两种类型，一种是变量的DataWatchers，另一种是类成员函数的结果(或唯一参数)的MemberWatchers。</p>
<p>DataWatchers和MemberWatchers也可以接受一个’base object’参数，它们所指向的数据被认为是该参数的成员。当与更复杂类型的观察者(如SequenceWatcher)结合使用时，这是非常有用的。</p>
<p>SequenceWatcher和MapWatcher看起来与DirectoryWatcher相同，但是它们监视任何支持STL序列或映射方法的类。它们只有一个客户端监视器，但是它们呈现的子容器的数量与包装容器的元素数量相同。调用子观察器时，将其“基对象”设置为容器的元素。为了处理这些容器中的指针，还有BaseDereferenceWatcher，它不提供额外的层次结构，而是解除对其基对象的引用，并使用该值调用唯一的子watcher。子进程可以通过静态列表来命名，也可以通过在子进程监视器中请求某个值(例如name)来命名。</p>
<h4 id="25-2-2-Using-watchers"><a href="#25-2-2-Using-watchers" class="headerlink" title="25.2.2. Using watchers"></a><strong>25.2.2. Using watchers</strong></h4><p>从上面的类型可以看出，可以设置一个监视器层次结构，既可以公开简单的设置，也可以跟踪复杂的结构。</p>
<p>制作监视器的最简单方法是使用MF_WATCH宏。这个宏接受监视器的路径名，以及一个变量或成员函数来获取&#x2F;设置它的值。它扩展为添加适当的监视器的代码。</p>
<p>要更改值(作为字符串)的解析或显示，不需要编写新的监视程序。相反，可以使用成员函数以字符串的形式获取和设置值。这就是’Client Settings&#x2F;Time of day’值的工作原理-有简单的访问器timeOfDayAsString，格式化一天的时间为’小时:分钟’，并从相同的格式解析回来。设置一个观察者也可以用来触发一个命令—例如，只要设置了一天中的时间，服务器就会收到通知(仅用于调试目的)。</p>
<p>要跟踪复杂的结构，必须直接创建适当的监视器，并将其插入到监视器层次结构中。参与这种安排的类通常会实现一个getWatcher()静态方法，该方法返回一个监视对象，当“基对象”被设置为该类的一个实例时，该监视对象就会工作。同一个监视器可以被类的所有实例共享，并且通常是DataWatchers和MemberWatchers的DirectoryWatcher类型。</p>
<p>这是在客户端使用实体管理器维护的实体映射完成的。实体由它们的ID命名。</p>
<p>客户机的大部分c++状态也可以通过显式添加的监视程序获得，因为调试的某些阶段已经需要它们了。</p>
<h4 id="25-2-3-Watcher-Console"><a href="#25-2-3-Watcher-Console" class="headerlink" title="25.2.3. Watcher Console"></a><strong>25.2.3. Watcher Console</strong></h4><p>观看者控制台提供了从游戏内部进入观看者系统的权限。它可以在任何时候打开，并将游戏屏幕覆盖为当前观察者目录的列表。</p>
<p>可以在后面跟着目录类条目，可以通过选择任何可写监视器，按Enter，然后输入一个新值来设置它的值。</p>
<p>还有一些键可以通过1、10、100或1000来调整数值。</p>
<h4 id="25-2-4-Remote-watcher-access"><a href="#25-2-4-Remote-watcher-access" class="headerlink" title="25.2.4. Remote watcher access"></a><strong>25.2.4. Remote watcher access</strong></h4><p>watcher系统使用一个非常简单的基于udp的watcher消息协议从客户端导出。服务器为了自己的调试需要广泛地使用这个协议。</p>
<p>这与Mercury无关，尽管它可以(目前是)连接到它的输入回路。当客户端启动时，它广播一个watcher nub通知包，通告它的watcher nub正在监听的端口(当它干净地关闭时，它发送一个类似的消息)。</p>
<p>要访问watcher值，可以使用许多工具，但到目前为止最有用的是UNIX守护进程“watcher”。这个守护进程监听任何广播监视器数据包，并从内部列表中添加或删除它们。</p>
<p>守护进程的另一端向它所知道的所有监视节点提供一个HTTP接口。它将观察者节点的名称(包含在注册消息中，例如’client of John’， ‘cell14’等……)插入到观察者超级层次结构的顶层。它将每个观察器树表示为这个顶级目录的分支。请求URL中的路径被转换为监视器值请求路径。该接口可以获取和设置值。</p>
<p>因此，通过使用任何web浏览器连接到这个守护进程，就可以看到本地网络上所有正在运行的客户机，然后调查或操作它们，甚至可以更改实体中Python变量的值。Python变量可以设置为任意Python，在客户端执行该变量以查找其值。如果需要的话，客户端还可以将其watcher nub通知发送给另一个外部地址，因此即使是远程客户端也可以通过这种方式访问。</p>
<p><strong>25.3. Memory tracking</strong></p>
<p>内存跟踪系统可以用来确定分配给类或模块的内存数量。ResourceCounters类是用于执行跟踪的主要类。</p>
<h3 id="25-4-Scripts"><a href="#25-4-Scripts" class="headerlink" title="25.4. Scripts"></a><strong>25.4. Scripts</strong></h3><p>使用BigWorld客户端实现游戏可能涉及许多脚本。这些脚本将相互作用，并具有实时的需求和依赖性，因为它们是网络游戏的一部分——在某些情况下，游戏不能简单地停止并逐步通过，而不影响正在调试的客户端的行为。</p>
<p>因此，编写脚本必须以与任何其他编码相同的方式进行，而不是作为c++编码的糟糕替代品。必须正确地设计脚本，并且必须考虑适当地使用类层次结构和其他语言概念。</p>
<h4 id="25-4-1-Python-Console"><a href="#25-4-1-Python-Console" class="headerlink" title="25.4.1. Python Console"></a><strong>25.4.1. Python Console</strong></h4><p>Python控制台可以在游戏期间的任何时候启动。</p>
<p>这是一个看起来和操作都完全像Python解释器的控制台，因此可以在其中输入任意Python。所有的c++模块都可以被访问，因此环境与脚本执行的环境是相同的。</p>
<p>脚本本身没有捕捉到的Python错误和异常(在它们到达c++调用点之前)会输出到控制台，因此是输入到Python控制台本身的命令产生的错误。当游戏中出现错误时，控制台是第一个访问的地方。</p>
<p>Python控制台支持多行命令的方式与标准Python解释器相同，它还支持像UNIX shell一样的宏。宏调用以美元符号($)开始，它们的扩展包含在人格文件中的字典中(参见fantasydemo人格脚本中的示例)。它实现了BWPersonality.expandMacros()回调函数。</p>
<p>该控制台还提供了自动代码完成的功能。按Tab，它试图将当前单词与引用上下文定义的属性匹配，从而自动完成当前单词。如果找到唯一匹配，则在插入点之后添加到它。如果存在多个匹配，则按Tab键循环所有匹配。</p>
<h4 id="25-4-2-Remote-Python-Console"><a href="#25-4-2-Remote-Python-Console" class="headerlink" title="25.4.2. Remote Python Console"></a><strong>25.4.2. Remote Python Console</strong></h4><p>Python控制台提供的服务也可以通过网络远程使用。</p>
<p>客户端在TCP端口50001上接受使用telnet协议的连接。支持许多telnet选项，例如模拟行编辑。</p>
<h4 id="25-4-3-Script-reloading"><a href="#25-4-3-Script-reloading" class="headerlink" title="25.4.3. Script reloading"></a><strong>25.4.3. Script reloading</strong></h4><p>所有的脚本可以重新加载按Caps Lock+F11。</p>
<p>现有的实体类实例将被更新，以便它们是新类的实例，而不会丢失它们的字典。实体脚本类可以提供一个reload方法来重新获取在重新加载后更改的存储函数引用。例如，player脚本中的reload函数重新计算其键绑定，否则将继续引用旧版本的类中的函数。</p>
<p>当服务器向脚本发送更新时，只有该脚本被重新加载，只有它的实例被更新。</p>
<h4 id="25-4-4-Common-errors"><a href="#25-4-4-Common-errors" class="headerlink" title="25.4.4. Common errors"></a><strong>25.4.4. Common errors</strong></h4><p>下面列出了一些常见的脚本错误:</p>
<ul>
<li><p>找不到类&lt;entity&gt;</p>
<p>在&lt;res&gt;&#x2F;scripts&#x2F;client&#x2F;&lt;entity&gt;.py文件中有一个Python错误。检查当前工作文件夹中的python.log文件。</p>
</li>
<li><p>app::init: BigWorldClientScript: init()失败</p>
<p>Python脚本与&lt;res&gt;&#x2F;scripts&#x2F;entity_defs&#x2F;&lt;entity&gt;.def之间不匹配。</p>
</li>
<li><p>EntityType:: init: EntityDescriptionMap:解析失败</p>
<p>在文件&lt;res&gt;&#x2F;scripts&#x2F;entity_defs&#x2F;&lt;entity&gt;.def或&lt; res &gt; &#x2F;scripts&#x2F; entity_defs &#x2F; alias.xml文件中使用了未定义的数据类型。</p>
</li>
</ul>
<p>关于实体定义和Python脚本文件的详细信息，请参见 Server Programming Guide’s sections <em>Directory Structure for Entity Scripting</em> → “The Entity Definition File” and <em>Directory Structure for Entity</em> <em>Scripting</em> → “The Entity Script Files。</p>
<h3 id="25-5-Script-interactive-debugging"><a href="#25-5-Script-interactive-debugging" class="headerlink" title="25.5. Script interactive debugging"></a><strong>25.5. Script interactive debugging</strong></h3><p>您可以将BigWorld Client作为Python扩展模块运行，而不是作为可执行文件运行。这将允许你使用第三方交互式调试器(如Wing IDE和Komodo)，或Python的内置调试模块(pdb)来调试你的游戏脚本。</p>
<h3 id="25-6-Client-Access-Tool-CAT"><a href="#25-6-Client-Access-Tool-CAT" class="headerlink" title="25.6. Client Access Tool (CAT)"></a><strong>25.6. Client Access Tool (CAT)</strong></h3><p>CAT提供了一个图形界面，可以在远程或本地客户机上更改监视器值并运行Python控制台命令。它通过客户端提供的远程Python Console服务来实现</p>
<h4 id="25-6-1-Connecting-to-the-client"><a href="#25-6-1-Connecting-to-the-client" class="headerlink" title="25.6.1. Connecting to the client"></a><strong>25.6.1. Connecting to the client</strong></h4><p>为了连接到客户端，你必须提供它运行的计算机名和&#x2F;或IP地址。</p>
<p>如果您同时提供计算机名和IP地址，CAT首先尝试使用计算机名连接，如果连接失败，则使用IP地址。指定本地主机为IP地址中的计算机名或127.0.0.1，以连接到本地客户端。</p>
<p>CAT在启动时自动重新连接到最后一个客户机。</p>
<h4 id="25-6-2-CAT-Scripts"><a href="#25-6-2-CAT-Scripts" class="headerlink" title="25.6.2. CAT Scripts"></a><strong>25.6.2. CAT Scripts</strong></h4><p>CAT在文件夹&lt;res&gt;&#x2F;..&#x2F;tools&#x2F;cat&#x2F;scripts，其中&lt;res&gt;是资源文件夹列表中的一个条目。</p>
<p>例如，如果&lt;res&gt;中的一个条目是C:&#x2F;mf&#x2F;fantasydemo&#x2F;res，那么CAT将在C:&#x2F;mf&#x2F;fantasydemo&#x2F;tools&#x2F; CAT &#x2F;scripts文件夹下寻找脚本。然后，它将呈现脚本的树形视图。</p>
<p>CAT脚本允许查看和操作客户机监视器值，并允许在客户机的Python控制台中执行命令。有关如何创建自己的脚本的信息，请参阅文件夹fantasydemo&#x2F;tools&#x2F;cat&#x2F; scripts中提供的示例。</p>
<p><strong>25.7. Timing</strong></p>
<p>BigWorld库提供了许多用于分析游戏性能的计时工具。其中最重要的一个就是DogWatch计时器类。</p>
<p>当创建DogWatch时，它被注册在一个全局列表中。无论何时启动计时器，它都会根据启动时正在运行的其他计时器自动进入计时统计层次结构。如果同一个计时器在不同的上下文中运行多次，那么它在层次结构中可以有多个实例。</p>
<p>根计时器被称为帧，并且总是在每一帧的整个帧时间内运行。所有其他计时器实例都是这个计时器实例的子实例。在框架边界处要小心，以确保没有时间不知去向。计时器甚至可以跨帧边界运行。如果是这种情况，它们将暂时停止，然后在下一帧的时间切片中重新开始。</p>
<p>调试控制台中显示了DogWatch计时器层次结构的视图，其中显示了</p>
<p>调试控制台中显示了DogWatch计时器层次结构的视图，其中显示了过去一秒DogWatch时间的平均值。用户可以在层次结构中导航和下钻，该层次结构在单个控制台页面上使用缩进显示。任何计时器实例也可以被绘制成图形，并且可以根据需要同时显示尽可能多的图形。缺省情况下，客户端保留120帧DogWatch计时器历史记录。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/06/bigworld_06_01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Avatar.png">
      <meta itemprop="name" content="华">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keep Running">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Keep Running">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/11/06/bigworld_06_01/" class="post-title-link" itemprop="url">BIGWORLD 服务端编程指南01</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-11-06 11:20:31" itemprop="dateCreated datePublished" datetime="2024-11-06T11:20:31+08:00">2024-11-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-11-07 09:22:54" itemprop="dateModified" datetime="2022-11-07T09:22:54+08:00">2022-11-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/BigWorld/" itemprop="url" rel="index"><span itemprop="name">BigWorld</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="BIGWORLD-Server-Programming-Guide-01"><a href="#BIGWORLD-Server-Programming-Guide-01" class="headerlink" title="BIGWORLD_Server Programming Guide_01"></a><strong>BIGWORLD_Server Programming Guide_01</strong></h1><h2 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a><strong>1. Overview</strong></h2><p>这部分文档包含了为BigWorld服务器创建实体和用户数据对象的技术信息。它是描述整个BigWorld系统的更大文档集的一部分。</p>
<h2 id="2-Directory-Structure-for-Entity-Scripting"><a href="#2-Directory-Structure-for-Entity-Scripting" class="headerlink" title="2. Directory Structure for Entity Scripting"></a><strong>2. Directory Structure for Entity Scripting</strong></h2><p>实体是组成游戏世界的对象。使用实体，你可以在游戏中创建玩家、npc、战利品、聊天室和许多其他互动元素。</p>
<h3 id="2-1-The-entities-xml-File"><a href="#2-1-The-entities-xml-File" class="headerlink" title="2.1. The entities.xml File"></a><strong>2.1. The entities.xml File</strong></h3><p>BigWorld引擎使用&lt;res&gt;&#x2F;scripts&#x2F;entities.xml文件来确定可用的实体类型。</p>
<p>这个文件中的每个标签代表一个实体类型，并且在&lt;res&gt;&#x2F;scripts&#x2F;entity_defs目录中必须有一个对应的定义文件，以及&lt;res&gt;&#x2F;scripts&#x2F;base或&lt;res&gt;&#x2F;scripts&#x2F;cell目录下的至少一个Python脚本文件。它也可能在&lt;res&gt;&#x2F;scripts&#x2F;client中有也有一个脚本文件。</p>
<p>在此文件中声明实体类型的顺序与与每个实体类型关联的最终实体ID相对应。</p>
<h3 id="2-2-The-Entity-Definition-File"><a href="#2-2-The-Entity-Definition-File" class="headerlink" title="2.2. The Entity Definition File"></a><strong>2.2. The Entity Definition File</strong></h3><p>实体定义文件&lt;res&gt;&#x2F;scripts&#x2F;entity_defs&#x2F;&lt;entity&gt;.def决定了脚本在BigWorld中的通信方式。这允许BigWorld系统将发送和接收消息的任务抽象为简单地调用实体上的不同脚本方法。在某种意义上，定义文件提供了一个到实体的接口，Python脚本提供了实现。</p>
<h3 id="2-3-The-Entity-Script-Files"><a href="#2-3-The-Entity-Script-Files" class="headerlink" title="2.3. The Entity Script Files"></a><strong>2.3. The Entity Script Files</strong></h3><p>BigWorld Technology将游戏世界中的实体处理划分为三种不同的执行环境:</p>
<table>
<thead>
<tr>
<th><strong>Entity type</strong></th>
<th><strong>Script file location</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Cell</td>
<td><em>&lt;res&gt;</em>&#x2F;scripts&#x2F;cell</td>
<td>负责实体中影响其周围空间的部分。处理在服务器集群上进行。</td>
</tr>
<tr>
<td>Base</td>
<td><em>&lt;res&gt;</em>&#x2F;scripts&#x2F;base</td>
<td>负责实体中不影响其周围空间的部分(以及可能充当玩家的代理)。处理在服务器集群上进行。</td>
</tr>
<tr>
<td>Client</td>
<td><em>&lt;res&gt;</em>&#x2F;scripts&#x2F;client</td>
<td>负责一个实体中需要高度了解周围环境的部分。</td>
</tr>
</tbody></table>
<p>有些实体实例可能没有这三个部分中的一个。此外，一些实体类型可能不支持拥有这些部分中的一个。对于每种实体类型，如果该类型支持该执行环境，每个CellApp、BaseApp和Client都有一个脚本文件。</p>
<p>这些脚本文件以实体类型命名，扩展名为’.py’。此文件必须包含一个名称为实体类型的类。</p>
<p>例如，如果您有一个实体类型Seat，它可以有cell、base和client执行环境，那么将有三个脚本文件，每个都有类的实现:</p>
<table>
<thead>
<tr>
<th><strong>Script file execution context</strong></th>
<th><strong>Entity’s base class</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Cell</td>
<td>BigWorld.Entity</td>
</tr>
<tr>
<td>Base</td>
<td>BigWorld.Base or BigWorld.Proxy</td>
</tr>
<tr>
<td>Client</td>
<td>BigWorld.Entity</td>
</tr>
</tbody></table>
<p>Seat实体的脚本的开头可以实现如下:</p>
<p>• <strong>Cell script file</strong> ‐ <strong>&lt;res&gt;&#x2F;scripts&#x2F;cell&#x2F;Seat.py</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> BigWorld</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Seat</span>( BigWorld.Entity ):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"> self </span>):</span><br><span class="line">        BigWorld.Entity.__init__( self )</span><br></pre></td></tr></table></figure>

<p>• <strong>Base script file</strong> ‐ <strong>&lt;res&gt;&#x2F;scripts&#x2F;base&#x2F;Seat.py</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> BigWorld</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Seat</span>( BigWorld.Base ):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"> self </span>):</span><br><span class="line">        BigWorld.Base.__init__( self )</span><br></pre></td></tr></table></figure>

<p>• <strong>Client script file</strong> ‐ <strong>&lt;res&gt;&#x2F;scripts&#x2F;client&#x2F;Seat.py</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> BigWorld</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Seat</span>( BigWorld.Entity ):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"> self </span>):</span><br><span class="line">        BigWorld.Entity.__init__( self )</span><br></pre></td></tr></table></figure>

<h2 id="3-Directory-Structure-for-Service-Scripting"><a href="#3-Directory-Structure-for-Service-Scripting" class="headerlink" title="3. Directory Structure for Service Scripting"></a><strong>3. Directory Structure for Service Scripting</strong></h2><p>Services类似于基础实体的脚本对象。它们被设计为与游戏服务器集成额外的功能。该功能通常涉及外部流程。</p>
<p>每个服务类型都被实现为Python脚本的集合，以及将这些脚本联系在一起的基于xml的定义文件。这些脚本位于文件夹脚本下的资源树中(例如，&lt;res&gt;&#x2F; scripts，其中&lt;res&gt;是定义的虚拟树~&#x2F;.bwmachine .conf)。</p>
<p>下面的列表总结了&lt;res&gt;中服务的重要文件和目录:</p>
<ul>
<li><strong>&lt;res&gt;</strong> ‐ 在~&#x2F;.bwmachine .conf中定义的资源树。<ul>
<li><strong>scripts</strong> - 包含所有服务文件的文件夹。<ul>
<li><strong>services.xml</strong> -  列出启动时要加载到服务器中的所有服务。</li>
<li><strong>base</strong> - 文件夹包含带有base组件的实体的Python脚本。</li>
<li><strong>common</strong> - 所有组件的Python搜索路径中列出的文件夹。用于普通游戏代码。<ul>
<li><strong>lib</strong> - 所有组件的Python搜索路径中列出的文件夹。用于普通游戏代码。</li>
</ul>
</li>
<li><strong>service</strong> - 文件夹包含要在ServiceApps上运行的服务的Python脚本。</li>
<li><strong>service_defs</strong> - 为&lt;res&gt;&#x2F;scripts&#x2F; services.xml文件中列出的每个服务包含一个XML .def文件。<ul>
<li><strong>&lt;service&gt;.def</strong> - 服务定义文件。对于&lt;res&gt;&#x2F; scripts&#x2F;services.xml中定义的每个服务，都有一个这样的文件。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-1-The-services-xml-File"><a href="#3-1-The-services-xml-File" class="headerlink" title="3.1 The services.xml File"></a><strong>3.1 The services.xml File</strong></h3><p>BigWorld引擎使用&lt;res&gt;&#x2F;scripts&#x2F;services.xml文件来确定可用的服务类型。</p>
<p>这个文件包含了一个Services元素列表，作为根节点的子节点:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Service1</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Service2</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-The-Service-Definition-File"><a href="#3-2-The-Service-Definition-File" class="headerlink" title="3.2. The Service Definition File"></a><strong>3.2. The Service Definition File</strong></h3><p>每个服务类型都有一个对应的定义文件，以服务的类型名称命名，扩展名为’.def’。例如，一个NoteStore服务类型会有一个名为NoteStore.def的文件。</p>
<p>以下文件是一个“最小”服务定义文件，以帮助快速定义一个新服务:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;root&gt;</span><br><span class="line">	&lt;Methods&gt;</span><br><span class="line">		&lt;!-- declaration --&gt;</span><br><span class="line">	&lt;/Methods&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-The-Service-Script-Files"><a href="#3-3-The-Service-Script-Files" class="headerlink" title="3.3. The Service Script Files"></a><strong>3.3. The Service Script Files</strong></h3><p>BigWorld技术处理服务执行环境中所有服务的处理。因此，为这个环境提供了每个服务类型的脚本文件。</p>
<p>例如，一个NoteStore服务将有一个包含类实现的脚本文件，位于<em>&lt;res&gt;</em>&#x2F;scripts&#x2F;service&#x2F;NoteStore.py</p>
<p>脚本文件中定义的服务基类是BigWorld.Service，因为文件表示服务执行环境。</p>
<p>NoteStore服务脚本的开头可以实现如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> BigWorld</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NoteStore</span>( BigWorld.Service ):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"> self </span>):</span><br><span class="line">        BigWorld.Service.__init__( self )</span><br></pre></td></tr></table></figure>

<p><strong>4. Directory Structure for User Data Object Scripting</strong></p>
<p>用户数据对象是在Chunk文件中嵌入用户定义数据的一种方法。每个用户数据对象类型都被实现为一个Python脚本集合，以及一个将这些脚本绑定在一起的基于xml的定义文件。这些脚本位于文件夹脚本下的资源树中(例如，&lt;res&gt;&#x2F;scripts，其中&lt;res&gt;是定义的虚拟树~&#x2F;.bwmachine .conf)。</p>
<p>用户数据对象与实体的区别在于它们是不可变的(即它们的属性不会改变)，而且它们不会传播到其他cell或客户端。这使得它们比实体轻得多。</p>
<p>用户数据对象的一个关键特性是它们的可链接性。实体能够链接到用户数据对象，而用户数据对象能够链接到其他用户数据对象。这是通过在希望链接到另一个用户数据对象的用户数据对象或实体的定义文件中包含UDO_REF属性来实现的。</p>
<p>下面的列表总结了&lt;res&gt;中用户数据对象的重要文件和目录:</p>
<ul>
<li><strong>&lt;res&gt;</strong> - 在~&#x2F;. bwmachinedconf中定义的资源树。<ul>
<li><strong>scripts</strong> - 包含所有实体文件的文件夹。<ul>
<li><strong>user_data_objects.xml</strong>  - 列出启动时要加载到客户机或服务器中的所有用户数据对象。</li>
<li><strong>base</strong> - 文件夹包含带有基本组件的用户数据对象的Python脚本。</li>
<li><strong>cell</strong> - 文件夹包含用于带有单元格组件的用户数据对象的Python脚本。</li>
<li><strong>client</strong> - 文件夹包含带有客户端组件的用户数据对象的Python脚本。</li>
<li><strong>common</strong> - 所有组件的Python搜索路径中列出的文件夹。用于普通游戏代码。<ul>
<li><strong>lib</strong> - 所有组件的Python搜索路径中列出的文件夹。用于普通游戏代码。</li>
</ul>
</li>
<li><strong>user_data_object_defs</strong> - 包含用户数据对象定义文件。<ul>
<li><strong><user_data_object_defs></strong> - 用户数据对象定义文件。对于&lt;res&gt;&#x2F;scripts&#x2F;user_data_objects.xml中定义的每个用户数据对象，都有一个这样的文件。</li>
<li><strong>interfaces</strong> - 用户数据对象接口定义文件。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-1-The-user-data-objects-xml-File"><a href="#4-1-The-user-data-objects-xml-File" class="headerlink" title="4.1. The user_data_objects.xml File"></a><strong>4.1. The user_data_objects.xml File</strong></h2><p>BigWorld引擎使用&lt;res&gt;&#x2F;scripts&#x2F;user_data_objects.xml文件来确定可用的用户数据对象的类型。</p>
<p>文件结构与&lt;res&gt;&#x2F;entities&#x2F;entities.xml匹配。</p>
<h3 id="4-2-The-User-Data-Object-Definition-File"><a href="#4-2-The-User-Data-Object-Definition-File" class="headerlink" title="4.2. The User Data Object Definition File"></a><strong>4.2. The User Data Object Definition File</strong></h3><p>用户数据对象定义文件&lt;res&gt;&#x2F;scripts&#x2F;user_data_object_defs&#x2F;<user_data_object>.def决定了它将存储并使BigWorld用户数据对象可访问的属性。用户数据对象定义文件还指定应该在服务器中还是客户机中创建用户数据对象。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Domain</span>&gt;</span> the execution context for this user <span class="tag">&lt;/<span class="name">Domain</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">Parent</span>&gt;</span> optional parent entity <span class="tag">&lt;/<span class="name">Parent</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">Implements</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- interface references --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Implements</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Properties</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- properties --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-3-The-User-Data-Object-Script-Files"><a href="#4-3-The-User-Data-Object-Script-Files" class="headerlink" title="4.3. The User Data Object Script Files"></a><strong>4.3. The User Data Object Script Files</strong></h3><p>BigWorld Technology根据其Domain将游戏世界中用户数据对象的处理划分为三种不同的执行环境:</p>
<ul>
<li><strong>User Data Object Domain: Cell — Script File Location: &lt;res&gt;&#x2F;scripts&#x2F;cell</strong></li>
<li><strong>User Data Object Domain: Base — Script File Location: &lt;res&gt;&#x2F;scripts&#x2F;base</strong></li>
<li><strong>User Data Object Domain: Clien — Script File Location: &lt;res&gt;&#x2F;scripts&#x2F;client</strong></li>
</ul>
<p>用户数据对象的大多数实现将只存在于计算单元或客户端中。关于驻留在计算单元中的用户数据对象的示例，请参阅&lt;res&gt;&#x2F;scripts文件夹中的PatrolNode用户数据对象脚本和定义文件。对于仅针对客户机的用户数据对象的示例，请在相同的位置查找CameraNode用户数据对象的脚本和定义文件。</p>
<h2 id="5-Properties"><a href="#5-Properties" class="headerlink" title="5. Properties"></a><strong>5. Properties</strong></h2><p>属性描述实体的状态。像传统的对象系统一样，BigWorld属性有一个类型和一个名称。与传统的对象系统不同，属性还具有分布属性，影响它在系统中的分布位置和分布频率。</p>
<p>属性在实体的定义文件中声明(命名为&lt;res&gt;&#x2F;scripts&#x2F;entity_defs&#x2F;&lt;entity&gt;.def)，在一个名为Properties的节中。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">propertyName</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- type of this property --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Type</span>&gt;</span> TYPE_NAME <span class="tag">&lt;/<span class="name">Type</span>&gt;</span> </span><br><span class="line">            <span class="comment">&lt;!-- Method of distribution --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Flags</span>&gt;</span> DISTRIBUTION_FLAGS <span class="tag">&lt;/<span class="name">Flags</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- Default value (optional) --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Default</span>&gt;</span> DEFAULT_VALUE <span class="tag">&lt;/<span class="name">Default</span>&gt;</span> </span><br><span class="line">            <span class="comment">&lt;!-- Is the property editable? (true/false) (optional) --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Editable</span>&gt;</span> [true|false] <span class="tag">&lt;/<span class="name">Editable</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- Level of detail for this property (optional) --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">DetailLevel</span>&gt;</span> LOD <span class="tag">&lt;/<span class="name">DetailLevel</span>&gt;</span> </span><br><span class="line">            <span class="comment">&lt;!-- Is the property persistent? --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Persistent</span>&gt;</span> [true|false] <span class="tag">&lt;/<span class="name">Persistent</span>&gt;</span> </span><br><span class="line">            <span class="comment">&lt;!-- Is the property indexed? --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Indexed</span>&gt;</span> [true|false] </span><br><span class="line">                <span class="comment">&lt;!-- Is the property index unique? --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Unique</span>&gt;</span> [true|false] <span class="tag">&lt;/<span class="name">Unique</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Indexed</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- Is at most one change sent to clients in a packet? --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">SendLatestOnly</span>&gt;</span> [true|false] <span class="tag">&lt;/<span class="name">SendLatestOnly</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- Is change sent reliably? --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">IsReliable</span>&gt;</span> [true|false] <span class="tag">&lt;/<span class="name">IsReliable</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">propertyName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-1-Property-Types"><a href="#5-1-Property-Types" class="headerlink" title="5.1. Property Types"></a><strong>5.1. Property Types</strong></h3><p>BigWorld需要在其各个组件之间通过网络有效地传输数据。为了这个目的,BigWorld定义文件描述了实体的每个属性的类型(尽管BigWorld的脚本使用的是Python —— 一种无类型语言)。</p>
<h4 id="5-1-1-Primitive-Types"><a href="#5-1-1-Primitive-Types" class="headerlink" title="5.1.1. Primitive Types"></a><strong>5.1.1. Primitive Types</strong></h4><p>下面的列表总结了BigWorld属性可用的基本类型:</p>
<ul>
<li><p><strong>BLOB</strong> <strong>— Size (bytes):</strong> <strong>N+K</strong></p>
<p>二进制数据。类似于字符串，但可以包含NULL字符。</p>
<p>在XML中，例如在XML数据库中，以base-64编码存储。</p>
<p>N是blob中的字节数，k&#x3D;4。</p>
</li>
<li><p><strong>FLOAT32</strong> <strong>— Size (bytes): 4</strong></p>
<p>32位浮点数。</p>
</li>
<li><p><strong>FLOAT64</strong> <strong>— Size (bytes): 8</strong></p>
<p>64位浮点数。</p>
</li>
<li><p><strong>INT8</strong> <strong>— Size (bytes): 1 — Range: From: -128 To: 127</strong></p>
<p>带符号的8位整形</p>
</li>
<li><p><strong>INT16</strong> <strong>— Size (bytes): 2 — Range: From: -32,768 To: 32,767</strong></p>
<p>带符号的16位整形</p>
</li>
<li><p><strong>INT32</strong> <strong>— Size (bytes): 4 — Range: From: -2,147,483,648 To: 2,147,483,647</strong></p>
<p>带符号的32位整形</p>
</li>
<li><p><strong>INT64</strong> <strong>— Size (bytes): 8 — Range: From: -9,223,372,036,854,775,808 To: 9,223,372,036,854,775,807</strong></p>
<p>带符号的64位整形</p>
</li>
<li><p><strong>MAILBOX</strong> <strong>— Size (bytes): 12</strong></p>
<p>一个BinWorld的邮箱。</p>
<p>将实体传递给MAILBOX参数会自动将其转换为MAILBOX。</p>
</li>
<li><p><strong>PYTHON</strong> <strong>— Size(bytes): Size of pickled string, as per</strong> <strong>STRING</strong></p>
<p>使用Python 拾取程序将任何Python类型打包到一个字符串中，并传输结果。</p>
<p>这不应该在客户端和服务器之间使用，因为它是不安全的和低效的。</p>
<p>建议在生产代码中使用用户数据类型。</p>
</li>
<li><p><strong>STRING</strong> <strong>— Size (bytes):</strong> <strong>N+K</strong></p>
<p>字符串(unicode)。</p>
<p>N是字符串中的字符数，k&#x3D;4。</p>
</li>
<li><p><strong>UINT8</strong> <strong>— Size(bytes): 1 - Range: From: 0 To: 255</strong></p>
<p>无符号8位整数</p>
</li>
<li><p><strong>UINT16</strong> <strong>— Size(bytes): 2 — Range: From: 0 To: 65,535</strong></p>
<p>无符号16位整数</p>
</li>
<li><p><strong>UINT32</strong> <strong>— Size(bytes): 4 — Range: From: 0 To: 4,294,967,295</strong></p>
<p>无符号32位整数</p>
</li>
<li><p><strong>UINT64</strong> <strong>— Size(bytes): 8 — Range: From: 0 To: 18,446,744,073,709,551,615</strong></p>
<p>无符号64位整数</p>
</li>
<li><p><strong>UNICODE_STRING</strong> <strong>— Size (bytes): Up to 4N+K</strong></p>
<p>字符串(Unicode)。</p>
<p>N是字符串中的字符数，k&#x3D;4。stream为utf - 8。</p>
</li>
<li><p><strong>VECTOR2</strong> <strong>— Size(bytes): 8</strong></p>
<p>二维32位浮点向量。在Python中表示为两个数字的元组(或Math.Vector2)。</p>
</li>
<li><p><strong>VECTOR3</strong> <strong>— Size(bytes): 12</strong></p>
<p>二维32位浮点向量。在Python中表示为三个数字的元组(或Math.Vector3)。</p>
</li>
<li><p><strong>VECTOR4</strong> <strong>— Size(bytes): 16</strong></p>
</li>
</ul>
<p>  二维32位浮点向量。在Python中表示为四个数字的元组(或Math.Vector4)。</p>
<h4 id="5-1-2-Composite-Types"><a href="#5-1-2-Composite-Types" class="headerlink" title="5.1.2. Composite Types"></a><strong>5.1.2. Composite Types</strong></h4><p>以下部分描述了BigWorld中可用的复合类型</p>
<h4 id="5-1-2-1-ARRAY-and-TUPLE-Types"><a href="#5-1-2-1-ARRAY-and-TUPLE-Types" class="headerlink" title="5.1.2.1. ARRAY and TUPLE Types"></a><strong>5.1.2.1. ARRAY and TUPLE Types</strong></h4><p>BigWorld还有ARRAY和TUPLE类型，它们可以创建任何BigWorld原语类型的值数组。</p>
<p>ARRAY类型的属性的字节大小由下面的公式计算:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">N*t +k</span><br></pre></td></tr></table></figure>

<ul>
<li>N - 数组中的元素数。</li>
<li>t - 数组中所包含的类型的大小</li>
<li>k - 常量</li>
</ul>
<p>BigWorld TUPLE类型在脚本中由Python元组类型表示，而BigWorld ARRAY类型在脚本中由Python列表类型表示。</p>
<p>元组（Tuples）的指定如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Type&gt; TUPLE &lt;of&gt; [TYPE_NAME|TYPE_ALIAS] &lt;/of&gt; [&lt;size&gt; n &lt;/size&gt;] &lt;/Type&gt;</span><br></pre></td></tr></table></figure>

<p>数组(Arrays)指定如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Type&gt; ARRAY &lt;of&gt; [TYPE_NAME|TYPE_ALIAS] &lt;/of&gt; [&lt;size&gt; n &lt;/size&gt;] &lt;/Type&gt;</span><br></pre></td></tr></table></figure>

<p>如果指定了ARRAY或TUPLE的大小，那么它必须声明n个元素。不允许向固定大小的ARRAY或TUPLE添加或删除元素。如果没有指定默认值，那么一个固定大小的ARRAY或TUPLE将包含n个元素类型的默认值。</p>
<p>数组(Arrays)有一个名为equals_seq()的特殊方法，可用于对任意Python序列(包括Python列表和元组)执行元素布尔相等性测试。例如:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">self.myList = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">self.myList.equals_seq( [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] )</span><br><span class="line"><span class="comment"># should return True</span></span><br><span class="line">self.myList.equals_seq( (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) )</span><br><span class="line"><span class="comment"># should return True</span></span><br><span class="line">self.myList.equals_seq( (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>) )</span><br><span class="line"><span class="comment"># should return False</span></span><br></pre></td></tr></table></figure>

<p>数组(Arrays)有效地传播更改。这包括对单个元素的赋值、追加、扩展、移除、弹出和切片赋值。</p>
<p>数组不仅可以包含有别名的数据类型，而且本身也可以有别名。</p>
<h4 id="5-1-2-2-FIXED-DICT-Data-Type"><a href="#5-1-2-2-FIXED-DICT-Data-Type" class="headerlink" title="5.1.2.2. FIXED_DICT Data Type"></a><strong>5.1.2.2. FIXED_DICT Data Type</strong></h4><p>FIXED_DICT数据类型允许使用一组固定的字符串键定义类似字典的属性。键和键值的类型是预定义的。</p>
<p>FIXED_DICT的声明如下所示:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Type</span>&gt;</span> FIXED_DICT</span><br><span class="line">    <span class="tag">&lt;<span class="name">Parent</span>&gt;</span> ParentFixedDictTypeDeclaration <span class="tag">&lt;/<span class="name">Parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Type</span>&gt;</span> FieldTypeDeclaration <span class="tag">&lt;/<span class="name">Type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">AllowNone</span>&gt;</span> true|false <span class="tag">&lt;/<span class="name">AllowNone</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Type</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个数据类型可以在任何类型声明可能出现的地方声明，例如，在&lt;res&gt;&#x2F;scripts&#x2F;entity_defs&#x2F; alias.xml,在&lt;res&gt;&#x2F;scripts&#x2F;entity_defs&#x2F;&lt;entity&gt;.def，作为方法调用参数，等等。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TradeLog</span>&gt;</span> FIXED_DICT</span><br><span class="line">        <span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dbIDA</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Type</span>&gt;</span> INT64 <span class="tag">&lt;/<span class="name">Type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dbIDA</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">itemsTypesA</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Type</span>&gt;</span> ARRAY <span class="tag">&lt;<span class="name">of</span>&gt;</span> ITEM <span class="tag">&lt;/<span class="name">of</span>&gt;</span> <span class="tag">&lt;/<span class="name">Type</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">itemsTypesA</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goldPiecesA</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Type</span>&gt;</span> GOLDPIECES <span class="tag">&lt;/<span class="name">Type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goldPiecesA</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">TradeLog</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>FIXED_DICT的实例可以像Python字典一样被访问和修改，但有以下例外:</p>
<ul>
<li>Keys不能添加或删除</li>
<li>Value的类型必须与声明匹配。</li>
</ul>
<p> 例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> entity.TradeLog[ <span class="string">&quot;dbIDA&quot;</span> ] == <span class="number">0</span>:</span><br><span class="line"> entity.TradeLog[ <span class="string">&quot;dbIDA&quot;</span> ] = <span class="number">100</span></span><br></pre></td></tr></table></figure>

<p>另外，它还支持以下内容</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> entity.TradeLog.dbIDA == <span class="number">0</span>:</span><br><span class="line"> entity.TradeLog.dbIDA = <span class="number">100</span></span><br></pre></td></tr></table></figure>

<p><em><strong>使用struct语法可能会导致与FIXED_DICT方法的名称冲突问题。</strong></em></p>
<p>FIXED_DICT实例可以使用具有所需键的超集(superset)的Python字典来设置。字典中任何不必要的键都会被忽略。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">entity.TradeLog = &#123; <span class="string">&quot;dbIDA&quot;</span> : <span class="number">100</span>, <span class="string">&quot;itemsTypesA&quot;</span> : [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ], </span><br><span class="line"> <span class="string">&quot;goldPiecesA&quot;</span> : <span class="number">1000</span>, <span class="string">&quot;redundantKey&quot;</span> : <span class="number">12345</span> &#125;</span><br></pre></td></tr></table></figure>

<p>FIXED_DICT值的更改将有效地传播到整个属性的更改将被传播的任何地方，例如，到ghost和客户端-包括ownClients。</p>
<p>FIXED_DICT数据类型的默认值可以在实体属性级别指定。例如:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Properties</span>&gt;</span> FIXED_DICT</span><br><span class="line">        <span class="tag">&lt;<span class="name">someProperty</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Type</span>&gt;</span> TradeLog <span class="tag">&lt;/<span class="name">Type</span>&gt;</span> <span class="comment">&lt;!-- From last example --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Default</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dbIDA</span>&gt;</span> 0 <span class="tag">&lt;/<span class="name">dbIDA</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">itemsTypesA</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">item</span>&gt;</span> 101 <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">item</span>&gt;</span> 102 <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">itemsTypesA</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goldPiecesA</span>&gt;</span> 100 <span class="tag">&lt;/<span class="name">goldPiecesA</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Default</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">someProperty</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果&lt;Default&gt;部分没有指定，那么FIXED_DICT数据类型的默认值将依赖于&lt;allowNone&gt;标签的值，如下所示:</p>
<p>表没有部分的FIXED_DICT的默认值</p>
<table>
<thead>
<tr>
<th><strong>&lt;AllowNone&gt;</strong></th>
<th><strong>FIXED_DICT</strong> <strong>默认值</strong></th>
</tr>
</thead>
<tbody><tr>
<td>True</td>
<td>python中 Node 对象</td>
</tr>
<tr>
<td>False</td>
<td>具有类型定义中指定的键的Python字典。<br>每个键值将根据其类型有一个默认值。例如，INT类型的键值的默认值为0。</td>
</tr>
</tbody></table>
<h4 id="5-1-3-Custom-User-Types"><a href="#5-1-3-Custom-User-Types" class="headerlink" title="5.1.3. Custom User Types"></a><strong>5.1.3. Custom User Types</strong></h4><p>有两种方法将用户定义的Python类合并到BigWorld实体中:<strong>包装FIXED_DICT数据类型</strong>，或<strong>实现USER_TYPE</strong>。</p>
<p>FIXED_DICT数据类型支持被用户定义的Python类型包装。当一个FIXED_DICT被包装时，BigWorld将实例化用户定义的Python类型来代替FIXED_DICT实例。这允许用户定制FIXED_DICT数据类型的行为。</p>
<p>类型系统也可以使用USER_TYPE类型进行任意扩展。与包装的FIXED_DICT类型不同，USER_TYPE类型的结构对BigWorld是完全不透明的。因此，USER_TYPE类型的实现就更加复杂了。类型操作的实现是由用户编写的Python对象（例如类的实例）执行的。Python对象作为该类型实例的工厂和序列化器，它可以选择使用它认为合适的任何该类型的Python表示——它可以像整数一样简单，也可以是Python类的实例。</p>
<h4 id="5-1-4-Alias-of-Data-Types"><a href="#5-1-4-Alias-of-Data-Types" class="headerlink" title="5.1.4. Alias of Data Types"></a><strong>5.1.4. Alias of Data Types</strong></h4><p>BigWorld还允许创建类型的别名。别名是一个类似于c++类型定义的概念，列在XML文件&lt;res&gt;&#x2F;scripts&#x2F;entity_defs&#x2F;alias.xml中。格式如下:</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;root&gt;</span><br><span class="line"> 	... other alias definitions ...</span><br><span class="line"> 	&lt;ALIAS_NAME&gt; TYPE_TO_ALIAS [&lt;Default&gt; Value &lt;/Default&gt;] &lt;/ALIAS_NAME&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure>

<p>下面列出了一些有用别名的例子:</p>
<table>
<thead>
<tr>
<th>Alias</th>
<th>Maps to</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>ANGLE</td>
<td>FLOAT32</td>
<td>以弧度度量的角</td>
</tr>
<tr>
<td>BOOL</td>
<td>INT8</td>
<td>布尔类型(编码为零&#x3D;假，非零&#x3D;真)<br>映射到INT8，最小的BigWorld类型。</td>
</tr>
<tr>
<td>INFO</td>
<td>UNIT16</td>
<td>关于任务的信息元素。</td>
</tr>
<tr>
<td>MISSIN_STATS</td>
<td>ARRAY &lt;of&gt; INFO &lt;&#x2F;of&gt;</td>
<td>任务信息数据元素数组(即INFO类型别名)。<br>注意，这是一个别名数组，其元素的类型也是别名类型。</td>
</tr>
<tr>
<td>OBJECT_ID</td>
<td>INT32</td>
<td>另一个实体的句柄。该名称表明该属性包含实体的句柄。</td>
</tr>
<tr>
<td>STATS_MATRIX</td>
<td>ARRAY &lt;of&gt; MISSION_STATS &lt;&#x2F;of&gt;</td>
<td>任务信息数据元素矩阵(即INFO类型别名)。<br>注意，这是一个别名数组，其元素的类型是另一个别名数组。</td>
</tr>
</tbody></table>
<p>使用上面描述的别名定义的语法，我们有以下文件:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Aliased data types --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">OBJECT_ID</span>&gt;</span> INT32 <span class="tag">&lt;/<span class="name">OBJECT_ID</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">BOOL</span>&gt;</span> INT8 <span class="tag">&lt;/<span class="name">BOOL</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ANGLE</span>&gt;</span> FLOAT32 <span class="tag">&lt;/<span class="name">ANGLE</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">INFO</span>&gt;</span> UINT16 <span class="tag">&lt;/<span class="name">INFO</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Aliased arrays ?--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">MISSION_STATS</span>&gt;</span> ARRAY <span class="tag">&lt;<span class="name">of</span>&gt;</span> INFO <span class="tag">&lt;/<span class="name">of</span>&gt;</span> <span class="tag">&lt;/<span class="name">MISSION_STATS</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">STATS_MATRIX</span>&gt;</span> ARRAY <span class="tag">&lt;<span class="name">of</span>&gt;</span> MISSION_STATS <span class="tag">&lt;/<span class="name">of</span>&gt;</span> <span class="tag">&lt;/<span class="name">STATS_MATRIX</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过别名，还可以定义自定义Python数据类型，这些数据类型在网络上有自己的流语义。我们在&lt;res&gt;&#x2F;scripts&#x2F;entity_defs&#x2F;alias.xml文件中声明这些类型如下:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ALIAS_NAME</span>&gt;</span> </span><br><span class="line">        USER_TYPE</span><br><span class="line">        <span class="tag">&lt;<span class="name">implementedBy</span>&gt;</span> UserDataType.instance <span class="tag">&lt;/<span class="name">implementedBy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ALIAS_NAME</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-2-Server-to-Client-bandwidth-usage-of-Property-updates"><a href="#5-2-Server-to-Client-bandwidth-usage-of-Property-updates" class="headerlink" title="5.2. Server to Client bandwidth usage of Property updates"></a><strong>5.2. Server to Client bandwidth usage of Property updates</strong></h3><p>当服务器向客户端发送一个属性更新时，它通常包含一个表示流数据长度的字节。但是，如果服务器能够确定特定属性的大小在流到客户机时始终相同，则可以删除该字节。</p>
<p>如果一个属性是以下任意组合，服务器会认为它是固定大小的类型:</p>
<ul>
<li>具有常量大小的基本类型。</li>
<li>具有声明大小并包含固定大小类型的ARRAY或TUPLE。</li>
<li>FIXED_DICT不能为None，它只包含固定大小的类型，并且没有封装在实现addToStream的类中。</li>
</ul>
<p>对ARRAY元素的切片赋值以及对单个ARRAY或TUPLE元素或FIXED_DICT值的更新不能从这种固定大小类型的优化中获益。</p>
<p>通过确保同时更新的值大小固定，并捆绑到FIXED_DICT结构中，可以优化服务器和客户机的带宽使用。如果一次性更新整个FIXED_DICT，那么只需要发送一条消息，不需要表示消息长度的字节。</p>
<p>通常单独更新的属性最好不捆绑到FIXED_DICTs中，因为更新FIXED_DICT的单个元素比更新顶级属性使用更多的带宽。</p>
<p>尽可能避免将大小可变的属性传播到客户端。不过，可变大小属性的代价只有一个字节，因此，例如，只有当ARRAY的长度始终是这个长度时，才应该指定它的大小，而不是指定感兴趣的最大长度。</p>
<p>另一件事需要注意的是，有一个数量有限的标识符属性传播到客户端，如果你有更多的属性为一个给定的实体类型，多余的属性将发送稍微低效率（通常每个值更新一个字节），而且它们的大小是可变的。服务器倾向于使用这种“溢出”机制发送大的固定大小或可变大小的属性。</p>
<p><strong>dumpEntityDescription</strong> DBMgr配置选项可用于检查您的实体属性和方法的客户端到服务器的带宽需求。</p>
<h3 id="5-3-Default-Values"><a href="#5-3-Default-Values" class="headerlink" title="5.3. Default Values"></a><strong>5.3. Default Values</strong></h3><p>当一个实体被创建时，它的属性被初始化为它们的默认值。可以在属性级别(在实体定义文件中)或类型级别(在alias.xml中)重写默认值。</p>
<p> 每种类型的默认值和覆盖它的语法如下所示:</p>
<ul>
<li><p><strong>ARRAY</strong> <strong>— Default:</strong> <strong>[]</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Default</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span>&gt;</span> Health potion <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span>&gt;</span> Bear skin <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span>&gt;</span> Wooden shield <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Default</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>构造等价于Pyhton列表 [ ‘Health potion’, ‘Bear skin’, ‘Wooden shield’ ]. </p>
</li>
<li><p><strong>TUPLE</strong> <strong>— Default:</strong> <strong>()</strong></p>
<p>和ARRAY类似</p>
</li>
<li><p><strong>BLOB</strong> <strong>— Default:</strong> <strong>‘’</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Default</span>&gt;</span> SGVsbG8gV29ybGQhB <span class="tag">&lt;/<span class="name">Default</span>&gt;</span>1</span><br><span class="line">&lt;!-Hello World! --&gt;</span><br></pre></td></tr></table></figure>

<p>1:必须指定base6编码的字符串值。</p>
</li>
<li><p><strong>FIXED_DICT</strong></p>
</li>
<li><p><strong>FLOAT32</strong> <strong>— Default:</strong> <strong>0.0</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Default</span>&gt;</span> 1.234 <span class="tag">&lt;/<span class="name">Default</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>FLOAT64</strong> <strong>— Default:</strong> <strong>0.0</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Default</span>&gt;</span> 1.23456789 <span class="tag">&lt;/<span class="name">Default</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>INT8</strong>, <strong>INT16</strong>, <strong>INT32</strong>, <strong>INT64</strong> <strong>— Default:</strong> <strong>0</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Default</span>&gt;</span> 99 <span class="tag">&lt;/<span class="name">Default</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>MAILBOX</strong> <strong>— Default:</strong> <strong>None</strong></p>
<p>默认值不能被重写。</p>
</li>
<li><p><strong>PYTHON</strong> <strong>— Default:</strong> <strong>None</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Default&gt;</span><br><span class="line"> &#123; &quot;Strength&quot;: 90, &quot;Agility&quot;: 77 &#125;</span><br><span class="line">&lt;/Default&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>STRING</strong> <strong>— Default:</strong> <strong>‘’</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Default&gt; Hello World! &lt;/Default&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>UINT8</strong>, <strong>UINT16</strong>, <strong>UINT32</strong>, <strong>UINT64</strong> <strong>— Default:</strong> <strong>0</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Default&gt; 99 &lt;/Default&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>UNICODE_STRING</strong> <strong>— Default:</strong> <strong>u’’</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Default&gt; Hello World! (this is a UTF-8 string) &lt;/Default&gt;</span><br></pre></td></tr></table></figure>

<p>值必须不带引号，并且必须编码为UTF-8</p>
</li>
<li><p><strong>USER_TYPE</strong> ——默认值:用户定义的defaultValue()函数的返回值</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Default</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intVal</span>&gt;</span> 100 <span class="tag">&lt;/<span class="name">intVal</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">strVal</span>&gt;</span> opposites <span class="tag">&lt;/<span class="name">stringVal</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dictVal</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">key</span>&gt;</span> good <span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span> bad <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dictValue</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Default</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>VECTOR2</strong> ——默认值：PyVector的适当长度为0.0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Default&gt; 3.142 2.71 &lt;/Default&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>VECTOR3</strong> ——默认值：PyVector的适当长度为0.0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Default&gt; 3.142 2.71 1.4 &lt;/Default&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>VECTOR4</strong> ——默认值：PyVector的适当长度为0.0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Default&gt; 3.142 2.71 1.4 3.8 &lt;/Default&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-4-Data-Distribution"><a href="#5-4-Data-Distribution" class="headerlink" title="5.4. Data Distribution"></a><strong>5.4. Data Distribution</strong></h3><p>属性表示实体的状态。一些状态只与单元相关，其他状态只与基状态相关，还有一些状态只与客户机相关。然而，有些属性与以上的每一个都有关联。</p>
<p>每个属性都有一个分布类型，它向BigWorld指定哪个执行环境(单元、基或客户端)负责更新属性，以及在系统中的何处传播其值。</p>
<p>数据分布是通过在文件&lt;res&gt;&#x2F;scripts&#x2F;entity_defs&#x2F;.def中指定&lt;Properties&gt;的&lt;Flags&gt;来设置的。</p>
<h4 id="5-4-1-Valid-Data-Distribution-Combinations"><a href="#5-4-1-Valid-Data-Distribution-Combinations" class="headerlink" title="5.4.1. Valid Data Distribution Combinations"></a><strong>5.4.1. Valid Data Distribution Combinations</strong></h4><p>下面的列表描述了上述位标志的有效组合:</p>
<ul>
<li><p>ALL_CLIENTS</p>
<p>属性对cell和client上的所有实体可用。</p>
<p>例子包括:</p>
<ul>
<li><p>球员的名字。</p>
</li>
<li><p>玩家或生物的生命状况。</p>
</li>
</ul>
</li>
<li><p>BASE</p>
<p>属性仅在base可用。</p>
<p>例如</p>
<ul>
<li>聊天室成员名单</li>
<li>角色库存物品</li>
</ul>
</li>
<li><p>BASE_AND_CLIENT</p>
<p>属性在base和自己客户端可用</p>
<p>只有在创建客户端实体时才同步此类型的属性。当属性更改时，客户机和基库都不会自动更新。方法必须用于传播新值，这很简单，因为只有一个玩家需要接收它。</p>
</li>
<li><p>CELL_PRIVATE</p>
<p>属性仅对其实体可用，且仅对单元格可用。</p>
<p>例子包括:</p>
<ul>
<li><p>AI算法中npc“思想”的属性。</p>
</li>
<li><p>与游戏玩法相关的玩家属性，但让玩家看到很危险(例如，战斗后的治疗时间)</p>
</li>
</ul>
</li>
<li><p>CELL_PUBLIC</p>
<p>属性仅在单元格和其他单元格上可用，并可用于其他实体。</p>
<p>例子包括:</p>
<ul>
<li><p>玩家的法力值(只能被敌人看到，其他玩家看不到)。</p>
</li>
<li><p>敌人NPC组队的呼号。</p>
</li>
</ul>
</li>
<li><p>CELL_PUBLIC_AND_OWN</p>
<p>属性可用于单元格上的其他实体，以及单元格和客户端上的这个实体。与OWN_CLIENT不同，这些数据也会被ghost，因此可以使用单元格上的其他实体。</p>
</li>
<li><p>EDITOR_ONLY</p>
<p>在使用BaseApp中的BigWorld.fetchEntitiesFromChunks时，这个值可能很有用。它可以用来以编程方式决定是否应该加载一个特定的实体。例如，您可以将一个难度级别与每个实体关联起来，因此，只有当任务的难度级别足够高时，该实体才会被加载。</p>
</li>
<li><p>OTHER_CLIENTS</p>
<p>属性从客户端可用于非该玩家角色的实体。其他实体也可在单元上使用。</p>
<p>例子包括:</p>
<ul>
<li><p>动态世界道具的状态(如门，战利品容器和按钮)。</p>
</li>
<li><p>粒子系统效应的类型。</p>
</li>
<li><p>当前坐在座位上的玩家。</p>
</li>
</ul>
</li>
<li><p>OWN_CLIENT</p>
<p>属性仅对计算单元和客户端上的此实体可用。</p>
<p>例子包括:</p>
<ul>
<li><p>玩家的角色类别。</p>
</li>
<li><p>玩家的经验值。</p>
</li>
</ul>
</li>
</ul>
<h4 id="5-4-2-Using-Distribution-Flags"><a href="#5-4-2-Using-Distribution-Flags" class="headerlink" title="5.4.2. Using Distribution Flags"></a><strong>5.4.2. Using Distribution Flags</strong></h4><p>在为属性选择分布标志时，考虑以下几点:</p>
<ul>
<li>哪些方法需要该属性?</li>
<li>该属性是否需要由其他实体访问？</li>
<li>客户端是否直接对这个值感兴趣?</li>
<li>一个玩家会因为看到这个属性而作弊吗？</li>
<li>任何属性只能有一个主值</li>
</ul>
<h4 id="5-4-3-Data-Propagation"><a href="#5-4-3-Data-Propagation" class="headerlink" title="5.4.3. Data Propagation"></a><strong>5.4.3. Data Propagation</strong></h4><p>数据传播发生在首次创建实体时。对属性的后续修改将仅局限于组件，除非修改发生在CellApp中，在这种情况下，更改将自动传播到所有感兴趣的各方。例如，CELL_PUBLIC属性被传播到具有实体虚影的所有其他CellApps, OTHER_CLIENTS属性被传播到在其AoI中具有实体的所有客户端，等等。</p>
<p>当更改CellApp以外的组件中的属性值时，可以使用远程方法调用手动传播更改。</p>
<h4 id="5-4-3-1-Property-Callbacks-On-Ghosted-Entities"><a href="#5-4-3-1-Property-Callbacks-On-Ghosted-Entities" class="headerlink" title="5.4.3.1. Property Callbacks On Ghosted Entities"></a><strong>5.4.3.1. Property Callbacks On Ghosted Entities</strong></h4><p>当修改一个属性，将传播到一个实体的幽灵在相邻的单元，即为CELL_PUBLIC, OTHER_CLIENTS和ALL_CLIENTS属性，可选的回调可以在单元实体类上实现，以响应那些ghost单元实体的属性更新。它们类似于客户端回调:</p>
<ul>
<li><p>@bwdecorators.callableOnGhost</p>
<p>def set_<em>&lt;property name&gt;</em>( self, oldValue )</p>
<p>当属性发生更改时，将调用此方法。oldValue参数是属性的旧值，新值已经设置。</p>
<p>如果更改是嵌套的，并且实现了setNested_&lt;属性名&gt;，则不会调用此方法。类似地，如果更改是切片更改，并且实现了setSlice_&lt;属性名&gt;，则不会调用此方法。</p>
</li>
<li><p>@bwdecorators.callableOnGhost</p>
<p>def setNested_<em>&lt;property name&gt;</em>( self, changePath, oldValue )</p>
<p>对嵌套属性更改调用此方法，例如当数组元素或FIXED_DICT子属性发生更改时。如果此方法不存在，则将调用set_回调。</p>
<p>changePath参数包含更改的路径，对于ARRAY值，使用数组中的索引，对于FIXED_DICT，使用键的字符串作为路径组件。</p>
<p>例如，假设我们有如下属性定义:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">myProperty</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Type</span>&gt;</span> ARRAY <span class="tag">&lt;<span class="name">of</span>&gt;</span> </span><br><span class="line">        FIXED_DICT </span><br><span class="line">        <span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Type</span>&gt;</span> ARRAY <span class="tag">&lt;<span class="name">of</span>&gt;</span> INT32 <span class="tag">&lt;/<span class="name">Type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">b</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Type</span>&gt;</span> STRING <span class="tag">&lt;/<span class="name">Type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">of</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">Type</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">Flags</span>&gt;</span> CELL_PUBLIC <span class="tag">&lt;/<span class="name">Flags</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">myProperty</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>假设以下声明cell实体运行:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>entity.myProperty[<span class="number">3</span>].a[<span class="number">5</span>] = <span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>这将导致调用setNested_myProperty，并将changePath设置为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3, &#x27;a&#x27;, 5]</span><br></pre></td></tr></table></figure>
</li>
<li><p>@bwdecorators.callableOnGhost</p>
<p>def setSlice_<em>&lt;property name&gt;</em>( self, changePath, oldValue )</p>
<p>当对ARRAY属性进行切片更改时，将调用此方法。如果这个方法不存在，set_&lt;property&gt;回调函数将被调用，如果它存在的话。</p>
<p>Examples of slice changes are below:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>entity.myProperty.append[<span class="number">3</span>].a.append( <span class="number">10</span> )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>entity.myProperty[<span class="number">3</span>:<span class="number">9</span>] = [<span class="number">50</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure></li>
</ul>
<p>请注意，这些回调永远不会调用真正的单元实体。因为它们可以在ghosted单元格实体上调用，所以必须使用bwdecorators模块中的callableOnGhost decorator函数来装饰它们</p>
<h4 id="5-4-3-2-Forcing-Data-Propagation-for-Python-and-Custom-User-Types"><a href="#5-4-3-2-Forcing-Data-Propagation-for-Python-and-Custom-User-Types" class="headerlink" title="5.4.3.2. Forcing Data Propagation for Python and Custom User Types"></a><strong>5.4.3.2. Forcing Data Propagation for Python and Custom User Types</strong></h4><p>对python和自定义用户类型属性的更改不会自动传播，除非已对该属性进行重新分配。</p>
<p>这种行为主要影响像字典、数组和类这样的复合Python类型，因为对对象的修改不会导致数据传播，除非该属性被重新分配给自己。</p>
<p>例如，如果实体e具有如下所示的属性:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pythonProp</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Type</span>&gt;</span> PYTHON <span class="tag">&lt;/<span class="name">Type</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">pythonProp</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>将新值赋给pythonProp将导致数据传播:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.pythonProp = &#123;<span class="string">&#x27;gold&#x27;</span>:<span class="number">100</span>&#125;</span><br></pre></td></tr></table></figure>

<p>但是，修改该值不会导致数据传播:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e.pythonProp[ <span class="string">&#x27;gold&#x27;</span> ] = <span class="number">50</span></span><br><span class="line">e.pythonProp[ <span class="string">&#x27;arrows&#x27;</span> ] = <span class="number">200</span></span><br></pre></td></tr></table></figure>

<p>实体的不同部分会看到不同的pythonProp值，除非通过将该属性重新赋值给自身来手动触发数据传播:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.pythonProp = e.pythonProp</span><br></pre></td></tr></table></figure>

<h3 id="5-5-Implementing-Custom-Property-Data-Types"><a href="#5-5-Implementing-Custom-Property-Data-Types" class="headerlink" title="5.5. Implementing Custom Property Data Types"></a><strong>5.5. Implementing Custom Property Data Types</strong></h3><p>自定义数据类型对于实现具有复杂行为的数据结构非常有用，这些数据结构在不同的组件之间共享，或者必须附加到单元实体（在这种情况下，它们必须能够从一个单元转移到另一个单元）。</p>
<h4 id="5-5-1-Wrapping-a-FIXED-DICT-Data-Type"><a href="#5-5-1-Wrapping-a-FIXED-DICT-Data-Type" class="headerlink" title="5.5.1. Wrapping a FIXED_DICT Data Type"></a><strong>5.5.1. Wrapping a FIXED_DICT Data Type</strong></h4><p>默认情况下，FIXED_DICT数据类型的行为类似于Python字典。可以通过将类字典的FIXED_DICT类型替换为另一种Python类型(在本文档中称为包装器类型)来更改此行为。</p>
<p>为此,指定一个类型转换对象在&lt; implementedBy &gt;部分FIXED_DICT类型声明。例如:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Type</span>&gt;</span> </span><br><span class="line">    FIXED_DICT</span><br><span class="line">    <span class="tag">&lt;<span class="name">implementedBy</span>&gt;</span> CustomTypeConverterInstance <span class="tag">&lt;/<span class="name">implementedBy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Properties</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">Type</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>CustomTypeConverterInstance必须是一个在FIXED_DICT实例和包装器实例之间转换的Python对象。</p>
<p>它必须实现以下方法:</p>
<p>表格应该由包装器类型实现的方法。</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>addToStream( <em>self</em>, <em>obj</em> )</td>
<td>可选方法，将包装器实例转换为适合通过网络传输的字符串。<br>obj参数是一个包装器实例。这个方法应该返回一个obj的字符串表示。通常，这是使用cPickle模块完成的。<br>如果该方法存在，则createFromStream也必须存在。<br>如果这个方法不存在，那么包装器实例将通过网络传输，首先使用getDictFromObj方法将它们转换为FIXED_DICT实例，然后使用createObjFromDict方法在接收端重新创建。</td>
</tr>
<tr>
<td>createFromStream( <em>self</em>, <em>stream</em> )</td>
<td>可选方法，从其字符串网络形式创建包装器类型的实例。<br>stream参数是通过调用addToStream方法获得的Python字符串。此方法应该返回一个包装器实例由数据流。<br>如果存在此方法，则必须提供addToStream。</td>
</tr>
<tr>
<td>createObjFromDict( <em>self</em>, <em>dict</em> )</td>
<td>将FIXED_DICT实例转换为包装器实例方法。<br>关键字参数是FIXED_DICT实例。这个方法应该返回从dict中的信息构造的包装器实例。</td>
</tr>
<tr>
<td>getDictFromObj( <em>self</em>, <em>obj</em> )</td>
<td>将包装器实例转换为FIXED_DICT实例的方法。<br>obj参数是一个包装器实例。这个方法应该返回一个Python字典(或类字典对象)，它包含与FIXED_DICT实例相同的一组键。</td>
</tr>
<tr>
<td>isSameType( <em>self</em>, <em>obj</em> )</td>
<td>方法检查对象是否为包装器类型。<br>任意Python对象中的obj形参。如果obj是一个包装器实例，这个方法应该返回True。</td>
</tr>
</tbody></table>
<h4 id="5-5-1-1-Example-of-Wrapping-FIXED-DICT-with-a-Class"><a href="#5-5-1-1-Example-of-Wrapping-FIXED-DICT-with-a-Class" class="headerlink" title="5.5.1.1. Example of Wrapping FIXED_DICT with a Class"></a><strong>5.5.1.1. Example of Wrapping FIXED_DICT with a Class</strong></h4><p>通常需要包装FIXED_DICT数据类型与一个类来促进面向对象编程</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cPickle</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCustomType</span>( <span class="title class_ inherited__">object</span> ): <span class="comment"># wrapper type</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"> self, <span class="built_in">dict</span> </span>):</span><br><span class="line">        self.a = <span class="built_in">dict</span>[ <span class="string">&quot;a&quot;</span> ]</span><br><span class="line">        self.b = <span class="built_in">dict</span>[ <span class="string">&quot;b&quot;</span> ]</span><br><span class="line">        ... <span class="comment"># other MyCustomType methods</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCustomTypeConverter</span>( <span class="title class_ inherited__">object</span> ): <span class="comment"># type converter class</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getDictFromObj</span>(<span class="params"> self, obj </span>):</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="string">&quot;a&quot;</span>: obj.a, <span class="string">&quot;b&quot;</span>: obj.b &#125;</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">createObjFromDict</span>(<span class="params"> self, <span class="built_in">dict</span> </span>):</span><br><span class="line">        <span class="keyword">return</span> MyCustomType( <span class="built_in">dict</span> )</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSameType</span>(<span class="params"> self, obj </span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isinstance</span>( obj, MyCustomType )</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addToStream</span>(<span class="params"> self, obj </span>): <span class="comment"># optional</span></span><br><span class="line">        <span class="keyword">return</span> cPickle.dumps( obj )</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">createFromStream</span>(<span class="params"> self, stream </span>): <span class="comment"># optional</span></span><br><span class="line">        <span class="keyword">return</span> cPickle.loads( stream )</span><br><span class="line">instance = MyCustomTypeConverter() <span class="comment"># type converter object</span></span><br></pre></td></tr></table></figure>

<p><em>&lt;res&gt;</em>&#x2F;scripts&#x2F;common&#x2F;MyCustomTypeImpl.py — 包装器类型和类型转换器对象</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Type</span>&gt;</span> </span><br><span class="line">    FIXED_DICT</span><br><span class="line">    <span class="tag">&lt;<span class="name">implementedBy</span>&gt;</span> MyCustomTypeImpl.instance <span class="tag">&lt;/<span class="name">implementedBy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">b</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">Type</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>封装的FIXED_DICT类型声明的摘录</p>
<p>上面的示例使FIXED_DICT类型表现为具有成员a和b的类，而不是具有相同键的字典。</p>
<p>为了确保实体e的所有副本都有更新的值，该属性必须设置为MyCustomType的一个不同的实例，并使用更新的值:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.custType = MyCustomType( &#123; <span class="string">&quot;a&quot;</span>: <span class="number">100</span>, <span class="string">&quot;b&quot;</span>: <span class="number">200</span> &#125; )</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MemberProxy</span>( <span class="title class_ inherited__">object</span> ): <span class="comment"># descriptor class</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"> self, memberName </span>):</span><br><span class="line">        self.memberName = memberName</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params"> self, instance, owner </span>):</span><br><span class="line">        <span class="keyword">return</span> instance.fixedDict[ self.memberName ]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params"> self, instance, value </span>):</span><br><span class="line">        instance.fixedDict[ self.memberName ] = value</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__delete__</span>(<span class="params"> self, instance </span>):</span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError( self.memberName )</span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCustomType</span>( <span class="title class_ inherited__">object</span> ): <span class="comment"># wrapper class</span></span><br><span class="line">    a = MemberProxy( <span class="string">&quot;a&quot;</span> )</span><br><span class="line">    b = MemberProxy( <span class="string">&quot;b&quot;</span> )</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"> self, <span class="built_in">dict</span> </span>):</span><br><span class="line">        self.fixedDict = <span class="built_in">dict</span></span><br><span class="line">        ... <span class="comment"># other MyCustomType methods</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCustomTypeConverter</span>( <span class="title class_ inherited__">object</span> ): <span class="comment"># type converter class</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getDictFromObj</span>(<span class="params"> self, obj </span>):</span><br><span class="line">        <span class="keyword">return</span> obj.fixedDict <span class="comment"># must return original instance</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">createObjFromDict</span>(<span class="params"> self, <span class="built_in">dict</span> </span>):</span><br><span class="line">        <span class="keyword">return</span> MyCustomType( <span class="built_in">dict</span> )</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSameType</span>(<span class="params"> self, obj </span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isinstance</span>( obj, MyCustomType )</span><br><span class="line">    <span class="comment"># addToStream and createFromStream cannot be implemented</span></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，MyCustomType在其fixedDict成员中引用了原始FIXED_DICT实例。对成员a或b的访问将通过描述符类重定向到fixedDict成员。当对FIXED_DICT实例的更新自动传播到其他组件时，对成员a和b的更新也会自动传播。</p>
<p>这种方法的缺点是不可能定制流媒体。如果实现了addToStream和createFromStream方法，则直接从流创建自定义对象。由于在Python脚本中不可能实例化FIXED_DICT对象，因此自定义对象不可能引用将传播部分更改的FIXED_DICT对象。</p>
<h4 id="5-5-1-2-Implementing-a-USER-TYPE-Data-Type"><a href="#5-5-1-2-Implementing-a-USER-TYPE-Data-Type" class="headerlink" title="5.5.1.2. Implementing a USER_TYPE Data Type"></a><strong>5.5.1.2. Implementing a USER_TYPE Data Type</strong></h4><p>USER_TYPE数据类型早于FIXED_DICT数据类型，它的大部分功能可以通过包装FIXED_DICT数据类型来实现。但是，USER_TYPE数据类型还允许将其表示定制为&lt;DataSection&gt;。</p>
<p>USER_TYPE数据类型由以下几部分组成:</p>
<ul>
<li><p>实现USER_TYPE数据类型的Python实例的声明。例如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Type&gt; USER_TYPE &lt;implementedBy&gt; UserType.instance &lt;/implementedBy&gt; &lt;/Type&gt;</span><br></pre></td></tr></table></figure>

<p>但是，建议在&lt;res&gt;&#x2F;scripts&#x2F;entity_defs&#x2F;alias.xml中声明USER_TYPE数据类型，我们可以在实体定义文件中使用它(命名&lt;res&gt;&#x2F;scripts&#x2F;entity_defs &#x2F;&lt;entity&gt;. def)。</p>
</li>
<li><p>一个类，它定义了从不同位置读取和写入此数据类型的方法。</p>
</li>
<li><p>一个模块，包含上面的类和该类的一个实例，将用于序列化和反序列化自定义数据类型。</p>
</li>
</ul>
<p>这个自定义数据类型也可以在运行时声明一个表示该类型的Python类。Python列表、字典或其他本地Python数据类型也可以表示它。</p>
<p>我们实现的类提供了方法来序列化我们用来表示概念的任何Python类型。这意味着我们可以通过网络传输类并将其序列化到数据库，只需在该类中编写适当的方法。</p>
<h3 id="5-6-Volatile-Properties"><a href="#5-6-Volatile-Properties" class="headerlink" title="5.6. Volatile Properties"></a><strong>5.6. Volatile Properties</strong></h3><p>有些属性比其他属性更新得更频繁，因此几乎所有实体都有一组属性需要特别处理。这些属性称为volatile属性，是由BigWorld引擎预先定义的。</p>
<p>通常，用OTHER_CLIENTS(或ALL_CLIENTS)标记的属性只在属性更改时发送给适当的客户机应用程序。这些更改是可靠发送的。每次AoI(通过其优先级队列机制)考虑实体时，被认为是易失性的属性就会发送给客户端。这些是不可靠地发送的，因为在下一次考虑该实体时将发送更新的值。</p>
<p>BigWorld定义的默认volatile属性如下:</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>position</td>
<td>实体的(x,y,z)位置。在Python中表示为三个浮点数的元组。</td>
</tr>
<tr>
<td>yaw</td>
<td>(-180,180)y轴的旋转偏移</td>
</tr>
<tr>
<td>pitch</td>
<td>(-90,90)x轴的旋转偏移</td>
</tr>
<tr>
<td>roll</td>
<td>(-180,180)z轴的旋转偏移</td>
</tr>
</tbody></table>
<p>这些属性通过客户端和服务器之间使用的优化协议进行更新，以最小化带宽。</p>
<p>不稳定的属性分别列出的正常属性文件 <em>&lt;res&gt;</em>&#x2F;scripts&#x2F;entity_defs&#x2F;<em>&lt;entity&gt;</em>.def.</p>
<p>每个实体都可以决定自动更新这些volatile属性中的哪一个。此外，它们可以有优先级。该优先级决定了该属性不再发送的实体与实体之间的距离。</p>
<p>语法如下:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">Volatile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">position</span>/&gt;</span> | <span class="tag">&lt;<span class="name">position</span>&gt;</span> float <span class="tag">&lt;/<span class="name">position</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">yaw</span>/&gt;</span> | <span class="tag">&lt;<span class="name">yaw</span>&gt;</span> float <span class="tag">&lt;/<span class="name">yaw</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">pitch</span>/&gt;</span> | <span class="tag">&lt;<span class="name">pitch</span>&gt;</span> float <span class="tag">&lt;/<span class="name">pitch</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">roll</span>/&gt;</span> | <span class="tag">&lt;<span class="name">roll</span>&gt;</span> float <span class="tag">&lt;/<span class="name">roll</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">Volatile</span>&gt;</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<ul>
<li>如果一个易变状态没有被指定，它将永远不会被更新(BigWorld.VOLATILE_NEVER)。</li>
<li>如果指定了易变状态：<ul>
<li>如果未指定优先级，则无论与实体的距离如何，属性将始终被更新(BigWorld.VOLATILE_ALWAYS).</li>
<li>如果指定了优先级，则该值将用作与实体的属性的最大距离（单位为米），该属性仍将被更新。</li>
</ul>
</li>
</ul>
<p>假设一个实体的易变性定义如下:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">Volatile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">position</span>/&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">yaw</span>&gt;</span> 30.0 <span class="tag">&lt;/<span class="name">yaw</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">pitch</span>&gt;</span> 25.0 <span class="tag">&lt;/<span class="name">pitch</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">Volatile</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对于上面的例子，我们为每个属性设置了如下代码:</p>
<ul>
<li>position - 总是更新</li>
<li>yaw - 更新到30米</li>
<li>pitch - 更新到25米</li>
<li>roll - 没有更新(BigWorld.VOLATILE_NEVER)</li>
</ul>
<p>只有定义不移动的实体时才应该没有volatile属性。</p>
<h3 id="5-7-LOD-Level-of-Detail-on-Properties"><a href="#5-7-LOD-Level-of-Detail-on-Properties" class="headerlink" title="5.7. LOD (Level of Detail) on Properties"></a><strong>5.7. LOD (Level of Detail) on Properties</strong></h3><p>有时，通过不将信息分发给遥远的客户端，可以优化带宽使用。我们可以通过将&lt;DetailLevel&gt;标记附加到属性来实现这一点。这个标记决定了属性更改之后不会发送到客户端的距离。</p>
<p>请注意，这纯粹是对属性的优化。只有在带宽使用率过高的情况下才应该使用此选项。如果该属性启用了这一功能，那么你必须非常仔细地测试它，以检查游戏玩法所获得的结果是否符合你的预期。</p>
<p>文件&lt;res&gt;&#x2F;scripts&#x2F;entity_defs&#x2F;中属性的LOD(详细级别)的定义&lt;entity&gt;.def的描述如下:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line"> ...</span><br><span class="line"> <span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"> <span class="tag">&lt;<span class="name">modelNumber</span>&gt;</span></span><br><span class="line"> ...</span><br><span class="line"> 	<span class="tag">&lt;<span class="name">DetailLevel</span>&gt;</span> NEAR <span class="tag">&lt;/<span class="name">DetailLevel</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">modelNumber</span>&gt;</span></span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>

<p>上面的例子为属性声明了一个标记为NEAR的LOD。NEAR的实际值在实体文件中&lt;LodLevels&gt;节的&lt;level&gt;子节中定义。</p>
<p>例如，要将AoI细分为NEAR、MEDIUM和FAR(当实体在彼此的AoI中时，远于FAR的内容将被传输)，实体的定义文件将包括以下几行:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">LODLevels</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span>&gt;</span> 20  <span class="tag">&lt;<span class="name">label</span>&gt;</span> NEAR 	<span class="tag">&lt;/<span class="name">label</span>&gt;</span> <span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span>&gt;</span> 100 <span class="tag">&lt;<span class="name">label</span>&gt;</span> MEDIUM 	<span class="tag">&lt;/<span class="name">label</span>&gt;</span> <span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span>&gt;</span> 250 <span class="tag">&lt;<span class="name">label</span>&gt;</span> FAR    	<span class="tag">&lt;/<span class="name">label</span>&gt;</span> <span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LODLevels</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在上面的例子文件中为实体指定的lod如下所示:</p>
<p><img src="/image%5Cbigworld%5C06_01.png" alt="06_01"></p>
<p>Detail levels继承自父定义文件。任何与父级具有相同标签的级别都将修改该级别，并添加任何新的级别。</p>
<h4 id="5-7-1-LOD-and-Hysteresis"><a href="#5-7-1-LOD-and-Hysteresis" class="headerlink" title="5.7.1. LOD and Hysteresis"></a><strong>5.7.1. LOD and Hysteresis</strong></h4><p>除了参数&lt;label&gt;外，&lt;level&gt;子节还可以有&lt;hyst&gt;参数。</p>
<p>它的定义如下所示:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">LODLevels</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span>&gt;</span> 20 <span class="tag">&lt;<span class="name">label</span>&gt;</span> NEAR <span class="tag">&lt;/<span class="name">label</span>&gt;</span> <span class="tag">&lt;<span class="name">hyst</span>&gt;</span> 4 <span class="tag">&lt;/<span class="name">hyst</span>&gt;</span> <span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span>&gt;</span> 100 <span class="tag">&lt;<span class="name">label</span>&gt;</span> MEDIUM <span class="tag">&lt;/<span class="name">label</span>&gt;</span> <span class="tag">&lt;<span class="name">hyst</span>&gt;</span> 10 <span class="tag">&lt;/<span class="name">hyst</span>&gt;</span> <span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span>&gt;</span> 250 <span class="tag">&lt;<span class="name">label</span>&gt;</span> FAR <span class="tag">&lt;/<span class="name">label</span>&gt;</span> <span class="tag">&lt;<span class="name">hyst</span>&gt;</span> 20 <span class="tag">&lt;/<span class="name">hyst</span>&gt;</span> <span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LODLevels</span>&gt;</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>这个参数定义了一个从LOD的外边界开始向外移动的迟滞区域。他可以防止频繁更改属性的LOD，从而节省了单元格的大量处理时间，因为属性不必经常更改它们的优先级。为此&lt;hyst&gt;指定LOD级别边界周围的缓冲区，实体在更改为更低的LOD之前必须完全通过该缓冲区。</p>
<p>&lt;hyst&gt;参数的声明是可选的，如果没有声明，它将默认为10米。</p>
<p>举个例子，假设一个静止的实体，和另一个实体穿过点A、B、C、D、E，最后回到a，如下图所示:</p>
<p><img src="/image%5Cbigworld%5C06_02.png" alt="06_02"></p>
<p>表格实体在另一个实体的lod周围移动。</p>
<table>
<thead>
<tr>
<th>位置</th>
<th>LOD</th>
<th>Reason</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>NEAR</td>
<td>不受滞后影响</td>
</tr>
<tr>
<td>B</td>
<td>NEAR</td>
<td>实体已经从NEAR移动到MEDIUM，但还没有完全通过滞后。</td>
</tr>
<tr>
<td>C</td>
<td>MEDIUM</td>
<td>实体已经从NEAR移动到MEDIUM，并且完全通过滞后</td>
</tr>
<tr>
<td>D</td>
<td>MEDIUM</td>
<td>实体仍然在MEDIUM中。</td>
</tr>
<tr>
<td>E</td>
<td>MEDIUM</td>
<td>实体仍然在MEDIUM中。</td>
</tr>
<tr>
<td>A</td>
<td>NEAR</td>
<td>实体已经从MEDIUM移动到NEAR。</td>
</tr>
</tbody></table>
<h3 id="5-8-Bandwidth-Optimisation-Send-Latest-Only"><a href="#5-8-Bandwidth-Optimisation-Send-Latest-Only" class="headerlink" title="5.8. Bandwidth Optimisation: Send Latest Only"></a><strong>5.8. Bandwidth Optimisation: Send Latest Only</strong></h3><p>当实体的OTHER_CLIENTS属性更改时，将创建一个事件对象，并将其添加到事件历史记录中。当更新在其AoI中具有此实体的客户端应用程序时，将使用此事件历史记录。当考虑此实体时，自上次考虑此实体以来添加的任何事件都将发送给客户端。在一次更新中可能会发送对单个属性的多个更改。</p>
<p>如果在属性上设置了SendLatestOnly标志，则事件历史中只保留最新的更改。这样可以避免发送多个更改。这可以节省发送到客户端的带宽，并可以在属性频繁更改的cellapp上保存一些内存。</p>
<p>此数值默认为false。客户端方法也有此标志。</p>
<p>注意，如果属性是SendLatestOnly，应该避免更改ARRAY和FIXED_DICT数据类型实例的内容，因为这需要重新发送整个属性。</p>
<h3 id="5-9-Bandwidth-Optimisation-Is-Reliable"><a href="#5-9-Bandwidth-Optimisation-Is-Reliable" class="headerlink" title="5.9. Bandwidth Optimisation: Is Reliable"></a><strong>5.9. Bandwidth Optimisation: Is Reliable</strong></h3><p>当实体的OTHER_CLIENTS属性发生更改时，将向适当的客户端应用程序发送一条消息，以更新它们对该实体的视图。默认情况下，此消息是可靠发送的，因此即使有丢包情况也能接收到更改。在极少数情况下，发送这些不可靠的信息可能是首选。这通常只与“SendLatestOnly”选项和连续更改的属性一起使用。</p>
<p>将SendLatestOnly设置为true, IsReliable设置为false，并在每个游戏tick中改变一个值会导致类似于volatile position和direction值的行为。</p>
<p>注意，如果属性IsReliable设置为false，应该避免更改ARRAY和FIXED_DICT数据类型实例的内容，因为这需要重新发送整个属性。</p>
<h3 id="5-10-Detailed-Position"><a href="#5-10-Detailed-Position" class="headerlink" title="5.10. Detailed Position"></a><strong>5.10. Detailed Position</strong></h3><p>发送给客户端的实体位置更新通常是相对于客户端位置的。这些值的大小被限制在maxAoIRadius，这允许它们被压缩以节省带宽。</p>
<p>但是，如果一个实体没有任何volatile属性，它将隐式地将其详细位置发送给感兴趣的客户端。详细位置由空间上的绝对坐标组成。由于该位置没有被归类为volatile，所以每当它的值发生变化时，它将被发送给所有对该实体感兴趣的客户端。</p>
<p>对于具有volatile属性的实体类型，可以使用DetailedPosition选项将详细位置发送给感兴趣的客户端。如果一个实体的位置更新需要比通常的压缩值更高的精度，这个选项是有用的。但是，应该谨慎地使用它，因为它使用更大的类型，因此使用更多的带宽。</p>
<p>DetailedPosition选项可以有一个SendLatestOnly标志，如果没有指定，默认为false。</p>
<p>DetailedPosition选项的语法如下所示:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">DetailedPosition</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">SendLatestOnly</span>&gt;</span> value <span class="tag">&lt;/<span class="name">SendLatestOnly</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">DetailedPosition</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-11-Appeal-Radius"><a href="#5-11-Appeal-Radius" class="headerlink" title="5.11. Appeal Radius"></a><strong>5.11. Appeal Radius</strong></h3><p>有时希望将来自客户端AoI外部实体的属性发送给客户端。例如，一条巨龙可能在许多公里外都能看到。将AoI半径增加到一个更大的值远非理想，因为来自更多实体的不必要更新会大幅增加带宽使用。</p>
<p>非零的AppealRadius值指定实体周围的区域。如果这个区域与客户的相交属性更新将被发送到客户端，就像实体在其AoI中一样。例如，如果客户端的aoiRadius是500米，而一个实体的AppealRadius设置为1500米，那么玩家将能够看到2000米以内的这个实体。具体来说，如果角色和实体之间的距离小于aoiRadius和实体的AppealRadius之和(在X轴和Z轴上)，客户端将收到实体的属性更新。</p>
<p><img src="/image%5Cbigworld%5C06_03.png" alt="06_03"></p>
<p>设置AppealRadius的实体类型将隐式地设置DetailedPosition&#x2F;SendLatestOnly选项。通常为一个实体发送的相对位置更新仅限于客户的AoI中的值，使得这个区域以外的实体太远，无法表示它们的位置。</p>
<h3 id="5-12-Temporary-Properties"><a href="#5-12-Temporary-Properties" class="headerlink" title="5.12. Temporary Properties"></a><strong>5.12. Temporary Properties</strong></h3><p>临时属性(Temporary properties)可用于不需要备份或与实体一起卸载的属性。</p>
<p>临时属性定义的语法如下所示:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">TempProperties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tempPropertyName1</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tempPropertyName2</span>/&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">TempProperties</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这些属性通常很少见，但对于不能流化的属性很有用，例如套接字或在恢复时重新创建的属性。这些都适用于单元格实体和基本实体。</p>
<h3 id="5-13-Persistent"><a href="#5-13-Persistent" class="headerlink" title="5.13. Persistent"></a><strong>5.13. Persistent</strong></h3><p>通常情况下，游戏实体数据库中至少有一个数据库表与每个实体类型相关联。这是该类型的实体可以持久化的地方。通常，有些实体类型永远不需要持久化。</p>
<p>通过将表的Persistent属性设置为false，可以避免在数据库中创建表。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">Persistent</span>&gt;</span>false<span class="tag">&lt;/<span class="name">Persistent</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>默认为true。将此设置为false的唯一真正好处是减少创建的表的数量。没有实际的性能影响。</p>
<h3 id="5-14-User-Data-Object-Linking-With-UDO-REF-Properties"><a href="#5-14-User-Data-Object-Linking-With-UDO-REF-Properties" class="headerlink" title="5.14. User Data Object Linking With UDO_REF Properties"></a><strong>5.14. User Data Object Linking With</strong> <strong>UDO_REF</strong> <strong>Properties</strong></h3><p>有一种特殊的属性类型，UDO_REF，可以在实体和用户数据对象中使用。通过此属性类型，可以在实体和用户数据对象之间或两个用户数据对象之间创建连接。这种属性类型是用户数据对象的一个关键特性，因为它允许创建由不同类型的用户数据对象和实体组成的复杂图形，实体脚本可以根据需要使用这些对象和实体。UDO_REF属性只不过是对用户数据对象的引用。</p>
<p>此属性类型最重要的示例是PatrolNode用户数据对象。旧的巡逻路径系统，包括旧的PATROL_PATH属性类型，已经被弃用。Patrol功能现在通过PatrolNode用户数据对象实现，可以通过UDO_REF属性数组将其链接到其他PatrolNode对象。希望在PatrolNode对象图中巡逻的实体只需要有一个链接到PatrolNode的UDO_REF属性。</p>
<h2 id="6-Methods"><a href="#6-Methods" class="headerlink" title="6. Methods"></a><strong>6. Methods</strong></h2><p>方法允许在实体的不同执行环境(即单元、基础、客户端)之间以及不同实体之间传播事件。BigWorld根据执行环境将实体方法划分为不同的类别。</p>
<p>一般来说，方法不应该用于传播状态。为此建议使用属性。例如，持枪的玩家应该是属性，而射击的玩家应该是方法。</p>
<p>这些方法的类别包括：</p>
<table>
<thead>
<tr>
<th>Category</th>
<th>Runs on</th>
<th>Common uses</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;BaseMethods&gt;</td>
<td>BaseApp</td>
<td>更新基类上的属性。<br>作为根点，向相关事物传播消息。</td>
</tr>
<tr>
<td>&lt;CellMethods&gt;</td>
<td>CellApp</td>
<td>通知单元的变化，以响应玩家的互动。<br>允许相邻实体之间的通信。</td>
</tr>
<tr>
<td>&lt;ClientMethods&gt;</td>
<td>Clients</td>
<td>通知客户端事件，以便玩家能够看到它们。隐式set_<property_name>方法不需要声明</td>
</tr>
</tbody></table>
<p>方法声明的语法如下:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;[ClientMethods|CellMethods|BaseMethods]&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">method_name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Exposed</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Args</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">arg1_name</span>&gt;</span> data_type <span class="tag">&lt;/<span class="name">arg1_name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">arg2_name</span>&gt;</span> data_type <span class="tag">&lt;/<span class="name">arg2_name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Args</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ReturnValues</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ret1_name</span>&gt;</span> data_type <span class="tag">&lt;/<span class="name">ret2_name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ret2_name</span>&gt;</span> data_type <span class="tag">&lt;/<span class="name">ret2_name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ReturnValues</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Only send one call to clients if called repeatedly --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">SendLatestOnly</span>&gt;</span> [true|false] <span class="tag">&lt;/<span class="name">SendLatestOnly</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Send the call reliably --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">IsReliable</span>&gt;</span> [true|false] <span class="tag">&lt;/<span class="name">IsReliable</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">method_name</span>&gt;</span></span><br><span class="line">    &lt;/[ClientMethods|CellMethods|BaseMethods]&gt;</span><br></pre></td></tr></table></figure>

<h3 id="6-1-Basic-Method-Specification"><a href="#6-1-Basic-Method-Specification" class="headerlink" title="6.1. Basic Method Specification"></a><strong>6.1. Basic Method Specification</strong></h3><p>所有类别中的所有方法都有一些基本的共同特征。它们在&lt;res&gt;&#x2F;scripts&#x2F;entity_defs&#x2F;&lt;entity&gt;.def文件的相关部分声明，每个方法都有一个XML标记。</p>
<p>该方法的参数和返回值(如果有的话)也在文件中定义，其类型的指定方式与属性类型相同。</p>
<p>为了在单元格上声明一个名为yell的方法，该方法接收一个名为phrase的字符串参数，我们需要如下代码行:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">CellMethods</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">yell</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Args</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">phrase</span>&gt;</span> STRING <span class="tag">&lt;/<span class="name">phrase</span>&gt;</span> <span class="comment">&lt;!-- phrase to exclaim --&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Args</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">yell</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">CellMethods</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>一旦声明了方法，还需要在适当的Python实现文件中声明它。每个执行环境(单元、基础和客户端)都有一个包含每个实体脚本的文件夹。</p>
<p>在我们的示例中，该方法被添加到&lt;CellMethods&gt;部分，因此将在cell实体上执行。</p>
<p>这个实体的单元格脚本名为&lt;res&gt;&#x2F;scripts&#x2F;cell&#x2F;&lt;entity&gt;.py，需要定义yell方法，如下图所示:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> BigWorld</span><br><span class="line">...</span><br><span class="line"><span class="keyword">class</span> &lt;entity&gt;(BigWorld.Entity):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        BigWorld.Entity.__init__(self)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">yell</span>(<span class="params">self, phrase</span>):</span><br><span class="line">        <span class="comment"># insert code to implement yell here</span></span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<h3 id="6-2-Two-way-calls"><a href="#6-2-Two-way-calls" class="headerlink" title="6.2. Two-way calls"></a><strong>6.2. Two-way calls</strong></h3><p>远程双向方法调用可用于从进程间的Python调用中获取返回值。实体方法的返回值声明格式与实体定义文件中的方法参数相同，只是它们列在ReturnValues标签下而不是Args下。例如，Avatar的webCreateAuction Base方法有如下定义:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">webCreateAuction</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Args</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">itemSerial</span>&gt;</span> ITEMSERIAL <span class="tag">&lt;/<span class="name">itemSerial</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">expiry</span>&gt;</span> UINT32 <span class="tag">&lt;/<span class="name">expiry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">startBid</span>&gt;</span> GOLDPIECES <span class="tag">&lt;/<span class="name">startBid</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">buyout</span>&gt;</span> GOLDPIECES <span class="tag">&lt;/<span class="name">buyout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Args</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ReturnValues</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">auctionID</span>&gt;</span> AUCTIONID <span class="tag">&lt;/<span class="name">auctionID</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ReturnValues</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">webCreateAuction</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此方法接受多个参数，其中包含auction的物品的详细信息，并返回唯一的auctionID。但是，这个方法对可能在另一个进程上的实体进行远程调用，这阻止我们以通常的方式接收返回值。相反，该方法将返回一个Twisted Deferred对象，该对象将在接收到返回值后作为参数发送给回调方法。</p>
<h4 id="6-2-1-Twisted-Deferred-Objects"><a href="#6-2-1-Twisted-Deferred-Objects" class="headerlink" title="6.2.1. Twisted Deferred Objects"></a><strong>6.2.1. Twisted Deferred Objects</strong></h4><p>为了获得双向方法的返回值，使用Twisted Deferred对象。调用方法时，返回Deferred对象。然后可以将两种回调方法添加到该对象中:用于成功调用的回调方法，以及用于发生错误的errback方法。当方法被执行后，它将调用两个回调方法中的一个，这取决于调用的成功与否。也可以为成功和失败链接多个回调。</p>
<p>例如，我们将实现remoteTakeDamage，这是一个使Avatar失去一些生命值并返回其剩余生命值的基础方法。这个方法将调用takeDamage，这是Avatar的Cell方法之一。</p>
<p>takeddamage将以伤害数量作为参数，并返回两个值:实体的剩余生命值和最大生命值。这些值将被打印，而剩余的健康值将作为Deferred对象的最终值从remoteTakeDamage返回。</p>
<p>由于Avatar的Base实体和Cell实体位于不同的进程上，因此调用将使用Deferred对象来有效地实现异步双向调用。这些方法在实体定义文件Avatar.def中有以下定义:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">BaseMethods</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">remoteTakeDamage</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Args</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">damage</span>&gt;</span> INT32 <span class="tag">&lt;/<span class="name">damage</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Args</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ReturnValues</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">health</span>&gt;</span> INT32 <span class="tag">&lt;/<span class="name">health</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ReturnValues</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">remoteTakeDamage</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">BaseMethods</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">CellMethods</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">takeDamage</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Args</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">damage</span>&gt;</span> INT32 <span class="tag">&lt;/<span class="name">damage</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Args</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ReturnValues</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">health</span>&gt;</span> INT32 <span class="tag">&lt;/<span class="name">health</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHealth</span>&gt;</span> INT32 <span class="tag">&lt;/<span class="name">maxHealth</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ReturnValues</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">takeDamage</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">CellMethods</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>remoteTakeDamage在fantasydemo&#x2F;res&#x2F;scripts&#x2F;base&#x2F;Avatar.py中有以下实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># base/Avatar.py</span></span><br><span class="line"><span class="keyword">from</span> twisted.internet <span class="keyword">import</span> defer</span><br><span class="line">...</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">remoteTakeDamage</span>(<span class="params"> self, damage </span>):</span><br><span class="line">    deferred = self.cell.takeDamage( damage )</span><br><span class="line">    deferred.addCallback( partial( self.onDamageTaken, damage ) )</span><br><span class="line">    <span class="keyword">return</span> deferred</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">onDamageTaken</span>(<span class="params"> self, damage, healthArgs </span>):</span><br><span class="line">    health, maxHealth = healthArgs[ <span class="number">0</span> ], healthArgs[ <span class="number">1</span> ]</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Avatar &#x27;s&#x27; took %d damage, reducing its health to %d/%d&quot;</span> % \</span><br><span class="line">    (self.basePlayerName, damage, health, maxHealth)</span><br><span class="line">    <span class="keyword">return</span> (health,)</span><br></pre></td></tr></table></figure>

<p>因为对takeddamage的调用是异步的，所以我们不会立即收到返回值。相反，将返回Deferred引用的Deferred对象。一旦结果可用，它将以包含返回值的元组的形式存储在Deferred对象中。由于我们无法立即接收和使用这些值，所以一旦它们可用，我们可以使用这些值作为参数指定一个要调用的方法。</p>
<p><strong>addCallback</strong>方法用于指定在此结果可用时调用的方法。这个方法的参数是结果元组。在我们的示例中，一旦结果在Deferred对象，它将作为最后一个参数发送给onDamageTaken方法。如果使用addCallback指定了其他回调方法，则将依次调用它们。每个回调函数的结果将作为新的结果存储在Deferred对象中，并作为列表中的下一个回调方法的参数发送。这叫做”回调链”。</p>
<p>当链中没有其他回调方法时，最终结果将存储在Deferred对象中。此时，添加的任何其他回调函数都将立即被调用，因为已经有了一个可用的结果。</p>
<p>最后，onDamageTaken的结果将存储在Deferred对象中，并发送给remoteTakeDamage的调用者。</p>
<p>还可以指定方法，以便在远程方法调用失败时调用。这是使用addErrback方法完成的，例如:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deferred.addErrback( onError )</span><br></pre></td></tr></table></figure>

<p>如果调用返回一个error对象，它将被用作onError的参数。</p>
<p>通过多次调用addErrback, Errbacks可以像回调一样被链接起来。addCallbacks方法向延迟对象同时添加回调和errback，但与使用addCallback和addErrback分别添加这两个对象相比，它的行为略有不同。addCallbacks将这两个方法添加到调用链中的同一级别，而分别添加它们将使每个方法处于自己的级别。</p>
<p>在cell&#x2F;Avatar.py中，takeDamage的实现如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cell/Avatar.py</span></span><br><span class="line"><span class="keyword">import</span> CustomErrors</span><br><span class="line"><span class="keyword">from</span> twisted.internet <span class="keyword">import</span> defer</span><br><span class="line">...</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">takeDamage</span>(<span class="params"> self, damage </span>):</span><br><span class="line">    <span class="keyword">if</span> (damage &lt; <span class="number">0</span>):</span><br><span class="line">        <span class="comment"># Goes to errback which </span></span><br><span class="line">        <span class="keyword">return</span> defer.fail( CustomErrors.InvalidFieldError(</span><br><span class="line">            <span class="string">&quot;Avatar can not take negative damage&quot;</span> ) )</span><br><span class="line">    self.health = self.health - damage</span><br><span class="line">    <span class="keyword">if</span> (self.health &lt; <span class="number">0</span>):</span><br><span class="line">        self.health = <span class="number">0</span></span><br><span class="line">        <span class="comment"># Goes to onDamageTaken callback</span></span><br><span class="line">    <span class="keyword">return</span> (self.health, self.maxHealth)</span><br></pre></td></tr></table></figure>

<p>以这种方式调用的方法必须返回包含返回值的元组或Deferred对象。如果一个元组从takeDamage返回，它的值将被存储在remoteTakeDamage方法中，并作为参数发送到它的回调方法onDamageTaken，如上所述。但是，如果返回一个Deferred对象，它的结果元组和为它指定的任何回调将被传播到remoteTakeDamage的Deferred对象，onDamageTaken回调将被添加到链的末尾。</p>
<p>对于创建Deferred对象的远程方法的例子，添加回调和错误回调到它们并返回它们，参考FantasyDemo的Avatar和AuctionHouse实体中的web接口Base方法，位于FantasyDemo &#x2F;res&#x2F;scripts&#x2F;base。</p>
<p>在我们的takeDamage实现中，一个错误会导致CustomErrors。InvalidFieldError对象(从Exception派生的自定义错误)使用deferred .fail返回。这个方法创建一个特殊的错误对象:一个已经调用errback的Deferred对象。使用此方法是向原始调用者返回错误的一种简单方法。一旦错误对象被原始调用者接收，如果有errback方法，它将被用作第一个errback方法的参数。而不是叫defer。失败，则会引发异常:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">raise</span> CustomErrors.InvalidFieldError( <span class="string">&quot;Avatar can not take negative damage&quot;</span> )</span><br></pre></td></tr></table></figure>

<p>这将与使用defer返回错误对象的结果相同。失败，并将错误的调用堆栈发送给MessageLogger。</p>
<p>在本例中，我们使用CustomErrors对象。这些自定义错误派生自BWError，是在双向调用中发送错误的推荐方式。</p>
<h4 id="6-2-2-Error-objects"><a href="#6-2-2-Error-objects" class="headerlink" title="6.2.2. Error objects"></a><strong>6.2.2. Error objects</strong></h4><p>如果双向调用失败，它将向Deferred对象发送一个错误对象，如果指定了errback方法，则调用第一个errback方法。该节点是Exception的实例。</p>
<p>在bigworld&#x2F;res&#x2F;scripts&#x2F;server_common&#x2F;BWTwoWay.py中定义了许多自定义异常类BWError派生的错误类型。这些可以被扩展以适应游戏脚本中可能出现的错误。BWError的两个子类被定义:BWStandardError，主要用于作为服务器二进制文件中出现错误的基类;BWCustomError，用于作为游戏脚本中出现错误的基类。</p>
<h4 id="6-2-2-1-BWStandardError"><a href="#6-2-2-1-BWStandardError" class="headerlink" title="6.2.2.1. BWStandardError"></a><strong>6.2.2.1. BWStandardError</strong></h4><p>源自服务器二进制文件的错误对象派生自BWStandardError类型，并在bigworld&#x2F;res&#x2F;scripts&#x2F;server_common&#x2F;BWTwoWay.py中声明。这些错误类型如下:</p>
<ul>
<li><p>BWAuthenticateError</p>
<p>玩家不能使用他们提供的凭证进行身份验证</p>
</li>
<li><p>BWInternalError</p>
<p>服务器遇到了一个由内部导致的错误。</p>
</li>
<li><p>BWInvalidArgsError</p>
<p>使用无效参数调用方法。</p>
</li>
<li><p>BWMercuryError</p>
<p>没有收到对请求的回应。</p>
</li>
<li><p>BWNoSuchCellEntityError</p>
<p>无法找到一个单元格实体。</p>
</li>
<li><p>BWNoSuchEntityError</p>
<p>找不到实体。</p>
</li>
</ul>
<h4 id="6-2-2-2-BWCustomError"><a href="#6-2-2-2-BWCustomError" class="headerlink" title="6.2.2.2. BWCustomError"></a><strong>6.2.2.2. BWCustomError</strong></h4><p>应该实现新的错误类型，以使错误尽可能有帮助。BWCustomError应该被用作游戏脚本特定的错误类范围的基类。例如，FantasyDemo为它的拍卖行实现的双向调用定义了许多自定义错误类，例如InsufficientGoldError和InvalidItemError。</p>
<p>自定义错误声明在&lt;res&gt;&#x2F;scripts&#x2F;server_common&#x2F;CustomErrors.py中。上面remoteTakeDamage的实现展示了一个自定义错误是如何作为延迟对象而不是返回值返回的:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> defer.fail( CustomErrors.&lt;Error <span class="type">Type</span>&gt;( &lt;Args&gt; ) )</span><br></pre></td></tr></table></figure>

<h2 id="6-3-Service-Methods"><a href="#6-3-Service-Methods" class="headerlink" title="6.3. Service Methods"></a><strong>6.3. Service Methods</strong></h2><p>服务方法的定义方式与基本方法、单元方法和客户端方法非常相似。但是，这里有一些细微的区别，因为与其他类别不同，服务不是实体。服务方法在&lt;res&gt;&#x2F;scripts&#x2F;service_defs&#x2F;&lt; Service &gt;.def文件中声明，每个方法都有一个XML标记。</p>
<p>服务方法属于methods标签下，而不是属于特定的类别，如BaseMethods或CellMethods。</p>
<p>为了在服务上声明一个名为addNote的方法，该方法接收一个名为newNote的字符串参数，我们将有以下几行:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">Methods</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">addNote</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Args</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">newNote</span>&gt;</span> STRING <span class="tag">&lt;/<span class="name">newNote</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Args</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ReturnValues</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">noteID</span>&gt;</span> NOTE_ID <span class="tag">&lt;/<span class="name">newNote</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ReturnValues</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">addNote</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">CellMethods</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><em>&lt;res&gt;&#x2F;scripts&#x2F;service_defs&#x2F;&lt;service&gt;.def ‐ 服务方法addNote的声明</em></p>
<p>一旦声明了方法，还需要在服务Python实现文件中实现它。服务执行上下文有一个目录，其中包含每个服务的脚本。</p>
<p>这个实体的脚本名为&lt;res&gt;&#x2F;scripts&#x2F;service&#x2F;&lt;service&gt;.py，需要定义addNote方法，如下图所示:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> BigWorld</span><br><span class="line">...</span><br><span class="line"><span class="keyword">class</span> &lt;service&gt;( BigWorld.Service ):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addNote</span>(<span class="params"> self, description </span>):</span><br><span class="line">        <span class="comment"># insert code to implement addNote here</span></span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p><em>&lt;res&gt;&#x2F;scripts&#x2F;service&#x2F;&lt;entity&gt;.py ‐ Definition of service method addNote</em></p>
<h3 id="6-4-Intra-Entity-Communication"><a href="#6-4-Intra-Entity-Communication" class="headerlink" title="6.4. Intra-Entity Communication"></a><strong>6.4. Intra-Entity Communication</strong></h3><p>实体的不同执行环境通过调用其他执行环境的方法来相互通信。这些是作为实体的特殊属性公开的。</p>
<p>作为快速参考，现将可用的对象说明如下:</p>
<ul>
<li><p><strong>allClients</strong> - 可用：cell</p>
<p>何时&#x2F;如何使用:在此实体的所有客户端实例上调用客户端方法。</p>
<p>例如:self.allClients.someMethod ()</p>
</li>
<li><p><strong>base</strong> - 可用：Cell,Client</p>
<p>何时&#x2F;如何使用:调用此实体的基方法。对该对象的调用在基脚本上执行。客户端不能直接调用基于其他实体的方法。</p>
<p>例如:self.cell.someMethod()</p>
</li>
<li><p><strong>cell</strong> - 可用：Base,Client</p>
<p>何时&#x2F;如何使用:调用此实体的单元格方法。对该对象的调用在单元格脚本上执行。所有客户端实例都可以访问它们的单元对象(当实体存在于单元上时)。</p>
<p>例如:self.cell.someMethod ()</p>
</li>
<li><p><strong>otherClient</strong> - 可用：Cell</p>
<p>何时&#x2F;如何使用:在这个实体的所有客户端实例上调用客户端方法，除了它自己的。</p>
<p>例如:self.otherClients.someMethod ()</p>
</li>
<li><p><strong>ownClient</strong> - 可用： Cell,Base</p>
<p>何时&#x2F;如何使用:只在这个实体的客户端上调用客户端方法。这个对象只在客户端应用程序中作为这个实体“播放”的实体上调用这个方法，而不是在其他可以看到这个实体的客户端应用程序上。</p>
<p>例如:self.ownClient.someMethod ()</p>
</li>
</ul>
<p>附近实体的方法可以从客户端直接调用该实体的单元部分。</p>
<p>BigWorld会自动将这些对象公开给相关的脚本类。</p>
<p>这意味着，任何作为实体(单元、基础或客户端部分)一部分的脚本都可以调用属于同一实体的其他脚本。定义文件(&lt;res&gt;&#x2F;scripts&#x2F;entity_defs&#x2F;&lt;entity&gt;.def)描述哪些方法公开给不同的执行环境。</p>
<h3 id="6-5-Bandwidth-Optimisation-Send-Latest-Only"><a href="#6-5-Bandwidth-Optimisation-Send-Latest-Only" class="headerlink" title="6.5. Bandwidth Optimisation: Send Latest Only"></a><strong>6.5. Bandwidth Optimisation: Send Latest Only</strong></h3><p>当在Entity.otherClients(或Entity.allClients)上调用一个方法时，将创建一个事件对象并将其添加到事件历史记录中。当更新在其AoI中具有此实体的客户端应用程序时，将使用此事件历史记录。当这个实体进入其AoI时，自上次考虑此实体以来添加的任何事件都将发送给客户端。在单个更新中可能会发送对单个方法的多个调用。</p>
<p>如果在客户端方法上设置了SendLatestOnly标志，则事件历史中只保留最近的调用。这样可以避免发送多个调用。这可以节省发送到客户端的带宽，并且如果一个方法被频繁调用并且只需要最近一次调用，可以节省CellApps上的一些内存。</p>
<p>默认情况下，此值为false。</p>
<h3 id="6-6-Bandwidth-Optimisation-Is-Reliable"><a href="#6-6-Bandwidth-Optimisation-Is-Reliable" class="headerlink" title="6.6. Bandwidth Optimisation: Is Reliable"></a><strong>6.6. Bandwidth Optimisation: Is Reliable</strong></h3><p>当在Entity.otherClients(或Entity.allClients)上调用方法时，消息将发送到AoI中包含该实体的适当客户端应用程序。默认情况下，这些消息是可靠地发送的。如果在客户端方法上将“isReliable”标志设置为false，则此消息将不可靠地发送。</p>
<h3 id="6-7-Sending-Auxiliary-Data-to-the-Client-Via-Proxy"><a href="#6-7-Sending-Auxiliary-Data-to-the-Client-Via-Proxy" class="headerlink" title="6.7. Sending Auxiliary Data to the Client Via Proxy"></a><strong>6.7. Sending Auxiliary Data to the Client Via Proxy</strong></h3><p>辅助数据(Auxiliary Data)可以通过代理(proxy)流到客户端，不影响正常的游戏流量。当带宽可用时，将这些数据机会适当地流到客户机。</p>
<p>辅助数据流使用的带宽可以通过&lt;baseApp&#x2F;downloadStreaming&gt;中的bw.xml选项来控制。</p>
<p>这个流数据中的所有数据类型都是用户定义的，因为BigWorld没有任何内部用途。</p>
<p>通过streamStringToClient方法将数据添加到代理:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">id</span> = Proxy.streamStringToClient(<span class="built_in">id</span>,data)</span><br></pre></td></tr></table></figure>

<p>或通过方法streamFileToClient:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">id</span> = Proxy.streamFileToClient(<span class="built_in">id</span>,resource)</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li><p><strong>id</strong></p>
<p>16位数据ID。如果接收到-1，则选择当前没有使用的下一个ID。这个方法的调用者负责管理这个参数。将方法使用的相同ID值返回给调用者。</p>
</li>
<li><p><strong>data</strong></p>
<p>要发送到附加客户端的数据。必须为字符串格式。</p>
</li>
<li><p><strong>resource</strong></p>
<p>要发送给客户端的资源的字符串名称。</p>
</li>
</ul>
<p>一旦客户端接收到整个数据字符串，就会在客户端上调用回调BWPersonality.onStreamComplete。</p>
<h3 id="6-8-Exposed-Methods-‐-Client-to-Server-Communication"><a href="#6-8-Exposed-Methods-‐-Client-to-Server-Communication" class="headerlink" title="6.8. Exposed Methods ‐ Client-to-Server Communication"></a><strong>6.8. Exposed Methods</strong> ‐ <strong>Client-to-Server Communication</strong></h3><p>因为mmo游戏是在网络上运行的，为了防止玩家作弊，服务器方法(那些在单元或基础上的)不允许由客户端自动调用。</p>
<p>为了使服务器方法可以从客户端调用(这样世界就可以提供交互)，它的声明必须包含标签&lt;Exposed&#x2F;&gt;，如下图所示:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">CellMethods</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">yell</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Exposed</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Args</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">phrase</span>&gt;</span> STRING <span class="tag">&lt;/<span class="name">phrase</span>&gt;</span> <span class="comment">&lt;!-- phrase to exclaim --&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Args</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">yell</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">CellMethods</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><em>&lt;res&gt;&#x2F;scripts&#x2F;entity_defs&#x2F;&lt;entity&gt;.def</em></p>
<p>标签&lt;Exposed&#x2F;&gt;完成了两件事:</p>
<ul>
<li>它使客户端可以使用该方法。</li>
<li>在单元格上，它充当额外的参数标记，该参数标记自动填充调用它的客户机的实体ID。</li>
</ul>
<p>客户端实例实际调用方法时使用的参数比单元实体接收到的参数少一个，这可以防止在安全服务器环境之外的“伪造实体”。在调用服务器组件的公开方法时，需要将实体ID作为参数传递。</p>
<p>必须对单元格上的方法的定义进行扩展，以获取此参数，如下图所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> BigWorld</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EntityName</span>(BigWorld.Entity):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        BigWorld.Entity.init(self)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">yell</span>(<span class="params">self, sourceEntityID, phrase</span>):</span><br><span class="line">        <span class="comment"># insert code to implement yell here</span></span><br><span class="line">        <span class="comment"># if desired, check that self.id == sourceEntityID before proceeding</span></span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p><em>&lt;res&gt;&#x2F;scripts&#x2F;cell&#x2F;&lt;entity&gt;.py</em></p>
<p>在客户端，可以用下面的代码调用方法yell:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.cell.yell( <span class="string">&quot;BigWorld message test&quot;</span> )</span><br></pre></td></tr></table></figure>

<p>如果cell方法yell实现了对self.id的sourceEntityID的检查，则只有它的客户端能够调用它。其他客户端将无法执行它。</p>
<p>在某些情况下，该方法可能使用不同的sourceEntityID运行。例如，对于一个名为shakeHand的方法，在继续操作之前，最好检查源实体与自我实体之间的距离是否在几米之内(也许两者都没有死亡)。</p>
<h4 id="6-8-1-Security-Considerations-of-Exposed-Methods"><a href="#6-8-1-Security-Considerations-of-Exposed-Methods" class="headerlink" title="6.8.1. Security Considerations of Exposed Methods"></a><strong>6.8.1. Security Considerations of Exposed Methods</strong></h4><p>脚本编写者应该意识到，在操作任何公开方法的参数之前，都需要在服务器端仔细检查。</p>
<p>处理参数传递的底层c++代码确保只有在以下情况下服务器端才会调用该方法:</p>
<ul>
<li>传递正确数量的参数。</li>
<li>参数具有预期的类型。</li>
</ul>
<p>然而，除此之外，底层体系结构不能对客户端传递给服务器上的方法调用的值提供任何进一步的约束。</p>
<p>例如，整数可以接受任何有效的32位值，字符串和数组可以是任何长度，….脚本编写者需要确保公开方法的参数具有在该方法上下文中有意义的值。</p>
<h3 id="6-9-Server-to-Client-bandwidth-usage-of-Method-calls"><a href="#6-9-Server-to-Client-bandwidth-usage-of-Method-calls" class="headerlink" title="6.9. Server to Client bandwidth usage of Method calls"></a><strong>6.9. Server to Client bandwidth usage of Method calls</strong></h3><p>从服务器到客户端的方法调用的参数与优化属性更新的方式相同。</p>
<h3 id="6-10-Client-callbacks-on-property-changes"><a href="#6-10-Client-callbacks-on-property-changes" class="headerlink" title="6.10. Client callbacks on property changes"></a><strong>6.10. Client callbacks on property changes</strong></h3><p>当服务器更改客户端的属性时，实体将调用一个回调方法，以允许客户端采取适当的操作。</p>
<p>当实体的属性被替换为新值时，调用Set_ <property_name>。也就是说，实体的__dict__中的值会被替换。</p>
<p>如果修改现有属性，则调用setNested__<property_name>或setSlice_<property_name>。</p>
<h4 id="6-10-1-Implicit-set-Methods"><a href="#6-10-1-Implicit-set-Methods" class="headerlink" title="6.10.1. Implicit set_**** Methods"></a><strong>6.10.1. Implicit</strong> <strong>set_****<property_name></strong> <strong>Methods</strong></h4><p>当服务器更新带有分布标志ALL_CLIENTS, OTHER_CLIENTS或OWN_CLIENT的属性时，隐式方法set_&lt;在客户端调用。</p>
<p>这个方法不需要在定义文件的&lt;ClientMethods&gt;部分声明，因为它是由BigWorld自动提供的。</p>
<p>所有隐式定义的set_<property_name>方法都有一个参数，该参数在调用方法时接收属性的旧值。例如:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Seat</span>( BigWorld.Entity ):</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_seatType</span>(<span class="params"> self, oldValue </span>):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p><em>&lt;res&gt;&#x2F;scripts&#x2F;client&#x2F;Seat.py</em></p>
<p>请注意，如果修改而不是替换现有属性，并且合适的setNested_<property_name>或setSlice_<property_name>方法不存在，则将使用oldValue参数作为None调用该方法。</p>
<h4 id="6-10-2-Implicit-setNested-Methods"><a href="#6-10-2-Implicit-setNested-Methods" class="headerlink" title="6.10.2. Implicit setNested_**** Methods"></a><strong>6.10.2. Implicit</strong> <strong>setNested_****<property_name></strong> <strong>Methods</strong></h4><p>如果修改现有属性的嵌套属性，则调用setNested_<property_name>。这包括修改ARRAY或FIXED_DICT的单个元素。该方法接受两个参数。第一个表示更改的路径，第二个表示已替换的值。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Seat</span>( BigWorld.Entity ):</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setNested_myFixedDict</span>(<span class="params"> self, path, oldValue </span>):</span><br></pre></td></tr></table></figure>

<p>第一个参数表示已更改属性的路径。例如，如果更改为:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">self.myFixedDict.rightHandItem.weight = <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>path的值为:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&quot;rightHandItem&quot;</span>, <span class="string">&quot;weight&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>如果你有一个属性是ARRAY &lt;of&gt; ARRAY &lt;of&gt; INT32 &lt;&#x2F;of&gt; &lt;&#x2F;of&gt;。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.myArray[ <span class="number">5</span> ][ <span class="number">3</span> ] = <span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>将导致path的值为:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">5</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h4 id="6-10-3-Implicit-setSlice-Methods"><a href="#6-10-3-Implicit-setSlice-Methods" class="headerlink" title="6.10.3. Implicit setSlice_**** Methods"></a><strong>6.10.3. Implicit</strong> <strong>setSlice_****<property_name></strong> <strong>Methods</strong></h4><p>如果修改了数组的一个切片，则调用setSlice_<property_name>。这包括从数组中追加和删除。该方法接受两个参数。第一个表示已更改片的路径，第二个表示已替换的片。路径中的最后一个值是一个包含两个整数的元组。它们表示新值的范围。要创建包含新值的切片，使用myModifiedArray[ path[-1][0] :  path[-1][1] ]。</p>
<p>例如，if self.myArray是一个已有的5个元素的数组:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.myArray.append( <span class="number">10</span> )</span><br></pre></td></tr></table></figure>

<p>将导致setSlice_myArray被调用:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">path = [(<span class="number">5</span>,<span class="number">6</span>)]</span><br><span class="line">oldValues = [ ]</span><br><span class="line">newValues = self.myArray[ path[-<span class="number">1</span>][<span class="number">0</span>] : path[-<span class="number">1</span>][<span class="number">1</span>] ]</span><br></pre></td></tr></table></figure>

<p>如果数组是FIXED_DICT的一部分，并且数组有5个元素，最后一个值是21。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> self.myFixedDict.myArray[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>将导致:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path = [<span class="string">&quot;myArray&quot;</span>, (<span class="number">4</span>,<span class="number">4</span>)]</span><br><span class="line">oldValues = [<span class="number">21</span>]</span><br></pre></td></tr></table></figure>

<h3 id="6-11-LOD-on-Methods"><a href="#6-11-LOD-on-Methods" class="headerlink" title="6.11. LOD on Methods"></a><strong>6.11. LOD on Methods</strong></h3><p>与属性一样，有些方法只需要传播给附近的实体。</p>
<p>例如，即使一个实体可能在AoI距离上可见(例如500米)，但玩家似乎不太可能区分微笑和不微笑的实体。</p>
<p>为了体现他的，微笑法的细节水平，可以声明如下图:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">ClientMethods</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">smile</span>&gt;</span></span><br><span class="line">            ...</span><br><span class="line">            <span class="tag">&lt;<span class="name">DetailDistance</span>&gt;</span> 30 <span class="tag">&lt;/<span class="name">DetailDistance</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">smile</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">ClientMethods</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><em>&lt;res&gt;&#x2F;scripts&#x2F;cell&#x2F;&lt;entity&gt;.py</em></p>
<p>方法的LOD规范要比属性的LOD规范简单得多。这是因为如果LOD增加，则非广播属性更改可能必须稍后发送，而同一场景中的非广播方法则不必发送。</p>
<p>因此，该方法只需要内联声明一个标记&lt;DetailDistance&gt;，当它在公开对象allClients或otherClients上被调用时，它只会广播给实体周围指定距离内的客户端。</p>
<h3 id="6-12-Inter-Entity-Communication"><a href="#6-12-Inter-Entity-Communication" class="headerlink" title="6.12. Inter-Entity Communication"></a><strong>6.12. Inter-Entity Communication</strong></h3><p>一旦实体有了分配给它们的方法，能够调用其他实体的方法就变得很有用。</p>
<p>如果你有一个ent对象作为另一个实体的Python脚本表示，那么你可以调用ent.somemethod()来在ent上调用那个方法。这假设someemethod()在您所在的执行环境中运行。例如，如果您在单元格上，那么ent.somemethod()必须由ent的实体类型定义和提供。</p>
<p>如果你在cell上，你可以调用base上的一个方法，代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ent.base.otherMethod()</span><br></pre></td></tr></table></figure>

<p>这意味着一旦您能够获得实体对象，就会有大量的选项用于在不同实体实例的不同执行环境中调用方法。</p>
<h4 id="6-12-1-Entity-IDs"><a href="#6-12-1-Entity-IDs" class="headerlink" title="6.12.1. Entity IDs"></a><strong>6.12.1. Entity IDs</strong></h4><p>为了唯一地识别游戏世界中的每个对象，BigWorld为每个实体分配了一个唯一的数字。这被称为实体ID。</p>
<p>在BigWorld Python模块(在大多数脚本的开头导入)中，有一个对象，它将实体id映射到相应的实体对象。该对象与Python字典具有相同的接口，名为BigWorld.entities。</p>
<p>给定一个实体id entityID，它的实体对象可以通过下面的代码来检索:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ent = BigWorld.entities[ entityID ]</span><br></pre></td></tr></table></figure>

<p>人们应该非常小心实体id，并总是在假设可以安全使用相应实体之前检查它是否存在。大世界。如果查找的实体不存在，实体将抛出异常。</p>
<p>每个执行环境都有一个BigWorld.entities的版本对象，其中包含不同实体的实体对象。</p>
<p>BigWorld.enyities 包含与它所在的执行上下文相关的实体，如下所示:</p>
<table>
<thead>
<tr>
<th>执行环境</th>
<th>在BigWorld.entities中列出的实体</th>
</tr>
</thead>
<tbody><tr>
<td>Cell</td>
<td>真实和鬼影实体位于由该cell的CellApp管理的所有cell。</td>
</tr>
<tr>
<td>Base</td>
<td>位于BaseApp上的实体</td>
</tr>
<tr>
<td>Client</td>
<td>客户端AoI中的实体。</td>
</tr>
</tbody></table>
<p>可以通过多种方式获取实体id:</p>
<ol>
<li><p>从公开的方法(客户端发送实体ID作为参数)。</p>
</li>
<li><p>来自实体对象的id属性。</p>
<p>您可以将对象的ID从一个执行环境传递到另一个执行环境(例如，从客户端传递到单元格)，以便另一个环境可以获得相应的对象。您还可以使用此属性获取新创建实体的ID。</p>
</li>
<li><p>从可以用来查找实体引用的各种实用程序方法。</p>
<p>其中一个方法是entitiesInRange。此方法为每个单元实体定义，并返回位于与调用实体一定距离内的所有实体对象。结果输出可以再次查询，以获得更具体的搜索结果。</p>
<p>例如，要找到当前实体100米内的所有守卫实体，你可以使用以下代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">findGuards</span>():</span><br><span class="line">    output = []</span><br><span class="line">    <span class="keyword">for</span> entity <span class="keyword">in</span> self.entitiesInRange( <span class="number">100</span> ):</span><br><span class="line">        <span class="keyword">if</span> entity.__class__.__name__ == <span class="string">&quot;Guard&quot;</span>:</span><br><span class="line">            output += [entity]</span><br><span class="line">    <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>

<p>在使用这种方法时需要注意搜索范围不能太大。</p>
</li>
</ol>
<h4 id="6-12-2-Retrieving-Services"><a href="#6-12-2-Retrieving-Services" class="headerlink" title="6.12.2. Retrieving Services"></a><strong>6.12.2. Retrieving Services</strong></h4><p>实体是通过entityID来标识的，而服务是通过名称来标识的，而不管有多少ServiceApps提供它。每个服务实例被称为一个服务片段。</p>
<p>在BigWorld Python模块中，有一个对象，它将服务的名称映射到提供该服务的ServiceApps上相应的服务片段。这个对象被称为BigWorld.services,如BigWorld.entities,它具有与Python字典相同的接口。</p>
<p>服务serviceName可以使用下面的代码检索:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serviceMailbox = BigWorld.services[ serviceName ]</span><br></pre></td></tr></table></figure>

<p>以这种方式检索的服务将是对应服务片段的邮箱。一旦检索到此邮箱，就可以调用服务的方法。例如:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BigWorld.services[ <span class="string">&#x27;ExampleService&#x27;</span> ].myTest( <span class="string">u&quot;This is a test&quot;</span> )</span><br></pre></td></tr></table></figure>

<h3 id="6-13-Mailboxes"><a href="#6-13-Mailboxes" class="headerlink" title="6.13. Mailboxes"></a><strong>6.13. Mailboxes</strong></h3><p>邮箱用于与远程实体(即不在当前进程上的实体)通信。</p>
<p>实体只能访问在同一执行环境中运行的其他实体。然而，能够向其他执行环境中的实体发送消息通常是有用的。例如，一个实体可能希望向一个聊天通道的所有成员发送一条消息，但是该通道可能不会将其所有成员与执行实体位于同一个BaseApp上。</p>
<p>邮箱用于实现实体的以下属性:</p>
<ul>
<li>self.cell</li>
<li>self.base</li>
<li>self.ownClient</li>
</ul>
<p>还有一组特殊的邮箱可供单元使用，它们引用与当前实体相关的其他实体。</p>
<p>前面提到的这些属性(cell, base, ownClient)允许您引用位于不同进程上的对象，并且可以像任何其他值一样发送，使用方法调用和MAILBOX数据类型。</p>
<p>您可以像使用普通实体引用一样使用MAILBOX，并在其他进程上的其他实体上调用实体定义文件中声明的方法。</p>
<p>考虑到一个实体B(在下面的例子中引用为另一个实体)有一个方法heyThere，它接受一个MAILBOX类型的参数，实体a可以将其基本邮箱从单元格传递给实体B，如下面的例子:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anotherEntity.heyThere( self.base )</span><br></pre></td></tr></table></figure>

<p>在接收实体B(在示例中引用为另一个实体)上，调用实体(实体A)的基本邮箱(通过方法参数接收)可以用于在实体A上调用方法someMethod。例如:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">heyThere</span>(<span class="params"> self, originalEntity </span>):</span><br><span class="line">    originalEntity.someMethod()</span><br></pre></td></tr></table></figure>

<p>也可以将邮箱作为属性存储在类中。但是，这只对基本实体邮箱有用，因为当实体在空间中移动时，它们不会更改地址。</p>
<p>通过使用邮箱，还可以调用与被调用邮箱不同的执行环境中的方法。例如，使用实体的基本邮箱(以下代码中的baseMB)，可以如下调用基本实体的cell方法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">baseMB.cell.cellMethod()</span><br></pre></td></tr></table></figure>

<p>该调用首先被发送到基本实体，然后该实体从基本实体所在的位置调用cell方法。虽然它比调用基方法(基方法反过来调用cell方法)更方便，但调用cell实体仍然需要两个跃点。</p>
<p>可用的用法是:</p>
<ul>
<li>baseMB.cell</li>
<li>baseMB.ownClient</li>
<li>cellMB.base</li>
<li>cellMB.ownClient</li>
</ul>
<p>这些实际上是mailbox的实例，可以作为方法参数传递。然而，同样的限制也适用于cellMB.base和cellMB.base对于cell邮箱来说——它们可以随着实体的移动而改变，因此不应该被储存起来供以后使用。</p>
<p>注意baseMB.ownClient和 cellMB.ownClient仅指它们own client。没有对otherClients和allClients的快捷调用。</p>
<p>获取其他实体邮箱的一种方便方法是在BaseApp上使用BigWorld.lookUpBaseByDBID 和 BigWorld.lookUpBaseByName 更多详细信息，请参见 BaseApp Python API’s entry <strong>Main Page</strong> → <strong>BigWorld (Module)</strong> → <strong>Member Functions</strong>.</p>
<h4 id="6-13-1-Special-Mailboxes"><a href="#6-13-1-Special-Mailboxes" class="headerlink" title="6.13.1. Special Mailboxes"></a><strong>6.13.1. Special Mailboxes</strong></h4><p>在前面讨论的邮箱之上，CellApp还提供了一组特殊的邮箱，可用于与引用实体的AoI内的实体通信。</p>
<p>可供使用的邮箱如下:</p>
<ul>
<li>entity.allClients</li>
<li>entity.otherClients</li>
<li>entity.clientEntity(EntityID)</li>
</ul>
<p>这个allClients邮箱将调用存在于引用实体的AoI中的所有客户实体以及引用实体的ownClient上的一个方法。</p>
<p>下图演示了对实体a上的allClients邮箱的调用，例如A.allClients.chat()。这导致在ClientApps A上的实体A上调用chat()方法，B和C。</p>
<img src="image\bigworld\06_04.png" alt="06_04" style="zoom:60%;" />

<p>otherClients邮箱几乎与allClients邮箱相同，不同的是所调用的方法不会在引用实体的ownClient上执行。这对于引用实体的客户端是操作的发起者的情况很有用。</p>
<p>下图演示了对实体a上otherClients邮箱的调用，例如A.otherClients.jump()。这导致在ClientApps B和C上的实体A上调用jump()方法。</p>
<img src="image\bigworld\06_05.png" alt="06_05" style="zoom:60%;" />

<p>最复杂的邮箱是clientEntity(EntityID)。此邮箱用于调用在引用实体的ClientApp上表示的实体上的方法。这对于导致特定于单个客户端的行为只被感兴趣的客户端看到是很有用的，例如任务给予者与玩家交谈。</p>
<p>下面的图表说明了对实体B上的clientEntity邮箱的调用，它提供了C的EntityID，例如B.clientEntity(C.id).wave()。这导致在ClientApp B的实体C上调用wave()方法。</p>
<img src="image\bigworld\06_06.png" alt="06_06" style="zoom:60%;" />

<h3 id="6-14-Method-Execution-Context"><a href="#6-14-Method-Execution-Context" class="headerlink" title="6.14. Method Execution Context"></a><strong>6.14. Method Execution Context</strong></h3><p>所有跨物理机器的实体方法调用都是异步的。例如，如果您在基本实体上执行self.cell.cellMethod()或self.client.clientMethod()，调用将立即返回不带任何值的结果。实际的方法执行发生在实体的单元或客户端部分驻留的机器上。</p>
<p>要将执行结果通知调用实体，必须从方法内部调用一个函数。</p>
<p>下面的例子描述了类Avatar的客户实体启动一系列操作来打开一扇门，执行以下步骤:</p>
<ol>
<li>类Avatar的客户端方法openDoor调用它的单元格方法openDoor</li>
<li>然后，该方法调用类Door的单元格方法unlock，并传递self作为参数。通过这种方式，Door接收单元实体Avatar的邮箱，稍后将使用该邮箱(与公开的对象客户端一起)调用Avatar上适当的cell方法。</li>
<li>然后，该方法检查密钥卡，并使用单元格邮箱（sourceEntity）直接调用类avatar的适当客户端方法（在本例中，我们假设它是成功的）。</li>
</ol>
<ul>
<li><p>Avatar类的客户端实体:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Avatar</span>( ):</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">openDoor</span>(<span class="params"> self, doorID </span>):</span><br><span class="line">        <span class="comment"># Call the cell method to open the door</span></span><br><span class="line">        self.cell.openDoor( doorID )</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">doorOpenFailed</span>(<span class="params"> self, doorID, keycard </span>):</span><br><span class="line">        <span class="comment"># Animation shows the Avatar scratching his head</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">doorOpenSucceeded</span>(<span class="params"> self, doorID, keycard </span>):</span><br><span class="line">        <span class="comment"># Animation shows the door with corresponding doorID opening</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
</li>
<li><p>Avatar类的cell实体:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Avatar</span>( ):</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">openDoor</span>(<span class="params"> self, doorID </span>):</span><br><span class="line">        <span class="comment"># locate the door</span></span><br><span class="line">        door = self.locateTheDoor( doorID )</span><br><span class="line">        keycard = self.getKeycardFromInventory()</span><br><span class="line">        door.unlock( self, keycard )</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
</li>
<li><p>门类的单元实体:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Door</span>( BigWorld.Entity ):</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">unlock</span>(<span class="params"> self, sourceEntity, keycard </span>):</span><br><span class="line">        <span class="comment"># check source is close enough</span></span><br><span class="line">        <span class="comment"># check keycard is good</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.isGoodKeycard( keycard ):</span><br><span class="line">            sourceEntity.client.doorOpenFailed( self.<span class="built_in">id</span>, keycard )</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.isOpen = <span class="literal">True</span></span><br><span class="line">            sourceEntity.client.doorOpenSucceeded( self.<span class="built_in">id</span>, keycard )</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<p>使用相同的回调技术从一个被调用的方法中返回值。</p>
<p>下面的例子描述了类Avatar的客户实体启动了一系列的操作，根据库存索引查询物品的描述，执行以下步骤:</p>
<ol>
<li>客户端类Avatar的investigateInventory 方法调用它的基方法itemDescriptionRequest。</li>
<li>然后该方法调用其客户端方法itemDescriptionReply。</li>
<li>然后，该方法显示项目的描述。</li>
</ol>
<ul>
<li><p>Avatar类的客户端实体:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Avatar</span>( ):</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">investigateInventory</span>(<span class="params"> self, indexInInventory </span>):</span><br><span class="line">        <span class="comment"># first get the details from the server</span></span><br><span class="line">        self.base.itemDescriptionRequest( indexInInventory )</span><br><span class="line">        <span class="comment"># maybe have a timeout in case server doesn&#x27;t reply</span></span><br><span class="line">    ...</span><br><span class="line"> 	<span class="keyword">def</span> <span class="title function_">itemDescriptionReply</span>(<span class="params"> self, indexInInventory, desc </span>):</span><br><span class="line"> 		<span class="comment"># call the callback</span></span><br><span class="line"> 		<span class="keyword">if</span> desc == []:</span><br><span class="line"> 			GUI.addAlert( <span class="string">&quot;No such item&quot;</span> + <span class="built_in">str</span>(indexInInventory) )</span><br><span class="line"> 		<span class="keyword">return</span></span><br><span class="line"> 		GUI.displayItemWindow( indexInInventory, desc )</span><br><span class="line"> 	...</span><br></pre></td></tr></table></figure>
</li>
<li><p>cell类的基本实体:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Avatar</span>( ):</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">itemDescriptionRequest</span>(<span class="params"> self, indexInInventory </span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line"> 			desc = self.generateDescription( indexInInventory )</span><br><span class="line"> 		<span class="keyword">except</span>:</span><br><span class="line"> 			desc = [] <span class="comment"># in case no such index</span></span><br><span class="line"> 		self.client.itemDescriptionReply( indexInInventory, desc )</span><br><span class="line"> 	...</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>对于驻留在同一进程中的那些实体，方法调用是同步进行的。但是，由于不能保证调用实体和被调用实体总是在同一个进程中，因此最好采用回调解决方案。</p>
<p>一个特殊情况是实体的定义文件(&lt;res&gt;&#x2F;scripts&#x2F; entity_defs&#x2F;&lt;entity&gt;.def‐详细信息见 “The Entity Definition File”)中没有定义的实体方法。在这种情况下，方法总是同步执行，并且只在调用者的进程中执行。例如，对影实体的方法调用通常会委托给真实的实体。然而，如果该方法没有在实体的定义文件中定义，它将被视为一个普通的Python方法，并在本地运行。</p>
<p>这种机制确实节省了服务器组件之间的一些网络通信量，并且可以立即向调用者返回结果，但它也受到了限制，因为它只能访问只读的ghosting属性。尝试访问非ghost属性或写入只读属性将导致意外错误。除非经过仔细的规划，否则不应该利用这个特性。</p>
<h2 id="7-Inheritance-in-BigWorld"><a href="#7-Inheritance-in-BigWorld" class="headerlink" title="7. Inheritance in BigWorld"></a><strong>7. Inheritance in BigWorld</strong></h2><p>BigWorld使用三个单独的类(单元、基础和客户端实体部分)来实现实体，并使用一个定义文件(&lt;res&gt;&#x2F;scripts&#x2F;entity_defs&#x2F;&lt;entity&gt;.def)将它们捆绑在一起。因此，实体或实体的一部分可以有多种方式在其规范和实现中使用继承。</p>
<p>在BigWorld中有三种不同的方式来声明继承关系，它们都满足不同的需求。</p>
<h3 id="7-1-Python-Class-Inheritance"><a href="#7-1-Python-Class-Inheritance" class="headerlink" title="7.1. Python Class Inheritance"></a><strong>7.1. Python Class Inheritance</strong></h3><p>Python语言允许相互派生类。</p>
<p>例如，定义从a派生而来的类B，以及它们各自的方法，你可以有以下代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params"> self </span>):</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;A.f was called&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>( <span class="title class_ inherited__">A</span> ):</span><br><span class="line"> 	<span class="keyword">def</span> <span class="title function_">g</span>(<span class="params"> self </span>):</span><br><span class="line"> 		<span class="built_in">print</span> <span class="string">&quot;B.g was called&quot;</span></span><br></pre></td></tr></table></figure>

<p>然后假设你有一个程序，代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = B()</span><br><span class="line">x.f()  	<span class="comment">#A.f was called</span></span><br><span class="line">x.g()	<span class="comment">#B.g was called</span></span><br></pre></td></tr></table></figure>

<p>当在实体中使用时，这种形式的继承允许在实体类型之间共享公共实现细节。允许多重继承，因此您可以使用许多Python类来帮助在某些实体中实现不同的特性，例如：</p>
<img src="image\bigworld\06_07.png" alt="06_07" style="zoom:80%;" />

<p>下面的代码片段展示了如何在实体DerivedEntity中使用Python类CommonBase</p>
<ol>
<li><p>如果基类的cell脚本(&lt;res&gt;&#x2F;scripts&#x2F;cell&#x2F;CommonBase.py)定义如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># note that this class is not derived from BigWorld.Entity</span></span><br><span class="line"><span class="comment"># so it is just an ordinary Python class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CommonBase</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">readyForAction</span>(<span class="params"> self </span>):</span><br><span class="line">        <span class="comment"># implement method&#x27;s logic</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果派生实体的单元格脚本(&lt;res&gt;&#x2F;scripts&#x2F;cell&#x2F;DerivedEntity1.py)定义如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> BigWorld</span><br><span class="line"><span class="keyword">from</span> common <span class="keyword">import</span> CommonBase</span><br><span class="line">...</span><br><span class="line"><span class="comment"># derive from CommonBase, so you can use the method readyForAction</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedEntity1</span>( BigWorld.Entity, CommonBase ):</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"> self </span>):</span><br><span class="line">        BigWorld.Entity.__init__( self )</span><br><span class="line">        CommonBase.__init__( self )</span><br><span class="line">        ...</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">someAction</span>(<span class="params"> self </span>):</span><br><span class="line">		<span class="keyword">if</span> self.readyForAction():</span><br><span class="line">         	<span class="built_in">print</span> <span class="string">&quot;action performed&quot;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后你可以从基类中调用方法，如下图所示:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DerivedEntity1.readyForAction()</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="7-2-Entity-Interfaces"><a href="#7-2-Entity-Interfaces" class="headerlink" title="7.2. Entity Interfaces"></a><strong>7.2. Entity Interfaces</strong></h3><p>BigWorld还以类似于Java接口系统的形式支持继承。可以有一个文件夹&lt;res&gt;&#x2F; scripts&#x2F;defs&#x2F;interfaces，可以用来声明实体的公共部分。这允许将定义放在常用声明的一个位置。</p>
<p>这个概念说明如下：</p>
<img src="image\bigworld\06_08.png" alt="06_08" style="zoom:80%;" />

<p>实体接口定义文件的格式与实体定义文件的格式类似，只是接口定义文件没有&lt;Parent&gt;部分。</p>
<p>接口定义文件的概要描述如下(所有部分都是可选的):</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Implements</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- interface references --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Implements</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- properties --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ClientMethods</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- client methods --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ClientMethods</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">CellMethods</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- cell methods --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">CellMethods</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">BaseMethods</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- base methods --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">BaseMethods</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">LoDLevels</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- levels of detail --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">LODLevels</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>与实体不同，实体接口不需要有相关的Python实现文件，尽管这可能是一个好主意。</p>
<p>下面的代码片段演示了在实体定义文件中使用接口的结果:</p>
<ol>
<li><p>如果一个实体被定义为实现一个接口(&lt;res&gt;&#x2F;scripts&#x2F;entity_defs&#x2F; someEntity.def)，如下所示:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- someEntity --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">Implements</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Interface</span>&gt;</span> someInterface <span class="tag">&lt;/<span class="name">Interface</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Implements</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果实现的接口定义如下(&lt;res&gt;&#x2F;scripts&#x2F;entity_defs&#x2F;interfaces&#x2F;someInterface.def):</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- someInterface --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Type</span>&gt;</span> STRING <span class="tag">&lt;/<span class="name">Type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Flags</span>&gt;</span> ALL_CLIENTS <span class="tag">&lt;/<span class="name">Flags</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>那么在概念上，得到的实体定义如下:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- someEntity --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Type</span>&gt;</span> STRING <span class="tag">&lt;/<span class="name">Type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Flags</span>&gt;</span> ALL_CLIENTS <span class="tag">&lt;/<span class="name">Flags</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>如果需要更改描述，则可以重写来自接口的属性。在这种情况下，整个属性描述将被替换为新的描述，因此需要指定所有适当的字段。</p>
<h3 id="7-3-Entity-Parents"><a href="#7-3-Entity-Parents" class="headerlink" title="7.3. Entity Parents"></a><strong>7.3. Entity Parents</strong></h3><p>通常可以将提供其他实体类型通用功能的实体定义为单个基本实体。例如，一组npc可能会共享它们的大部分执行，但需要一些特定的调整才能将它们变成守卫或店主:</p>
<img src="image\bigworld\06_09.png" alt="图片" style="zoom:80%;" />

<p>下面的代码片段演示了这种形式的继承。</p>
<ol>
<li><p>定义基本实体GenericEntity (&lt;res&gt;&#x2F;scripts&#x2F;entity_defs&#x2F;GenericEntity.def):</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- GenericEntity --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- common properties and methods --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>定义GenericEntity的基脚本:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> BigWorld</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GenericEntity</span>( BigWorld.Base ):</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"> self </span>):</span><br><span class="line">        BigWorld.Base.__init__( self )</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义GenericEntity的单元格脚本:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> BigWorld</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GenericEntity</span>( BigWorld.Entity ):</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"> self </span>):</span><br><span class="line">        BigWorld.Entity.__init__( self )</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义派生实体:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- SpecificEntity --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- inheritance is defined in this tag --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Parent</span>&gt;</span> GenericEntity <span class="tag">&lt;/<span class="name">Parent</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- add more properties and methods here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>定义SpecificEntity的基础脚本:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> BigWorld</span><br><span class="line"><span class="keyword">import</span> GenericEntity</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpecificEntity</span>( GenericEntity.GenericEntity ):</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"> self </span>):</span><br><span class="line">        GenericEntity.GenericEntity.__init__( self )</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义SpecificEntity的单元格脚本:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> BigWorld</span><br><span class="line"><span class="keyword">import</span> GenericEntity</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpecificEntity</span>( GenericEntity.GenericEntity ):</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"> self </span>):</span><br><span class="line">        GenericEntity.GenericEntity.__init__( self )</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="7-4-Client-Entity-Reuse"><a href="#7-4-Client-Entity-Reuse" class="headerlink" title="7.4. Client Entity Reuse"></a><strong>7.4. Client Entity Reuse</strong></h3><p>有时，可能只需要在服务器上指定一个实体类型。在.def文件中使用可选&lt;ClientName&gt;部分允许为客户端实体使用不同的（通常是父的）实体类型。</p>
<p>例如，如果NPC来自Avatar，并且NPC包含了客户端不需要访问的附加属性，那么NPC对象就可以作为Avatar对象发送给客户端。这意味着客户端不需要特定的脚本来处理npc。</p>
<h3 id="7-5-User-Data-Object-Interfaces-and-Parents"><a href="#7-5-User-Data-Object-Interfaces-and-Parents" class="headerlink" title="7.5. User Data Object Interfaces and Parents"></a><strong>7.5. User Data Object Interfaces and Parents</strong></h3><p>为实体描述的接口和父级的继承也适用于用户数据对象。由于用户数据对象与普通实体相似( 具体查看”Entity Interfaces”和”Entity Parents”)</p>
<p>关于在用户数据对象中继承的例子，请参见&lt;res&gt;&#x2F;scripts&#x2F;user_data_object_defs&#x2F; testtem .def和&lt;res&gt;&#x2F;scripts&#x2F;user_data_object_defs&#x2F;testParent.def。</p>
<h2 id="8-Entity-Instantiation-and-Destruction"><a href="#8-Entity-Instantiation-and-Destruction" class="headerlink" title="8. Entity Instantiation and Destruction"></a><strong>8. Entity Instantiation and Destruction</strong></h2><p>由于BigWorld实体必须建立和相互链接的方式，它们的实例化方式必须与Python中其他对象的实例化方式不同。同样地，因为在破坏时，部件必须断开连接，所以有一些特殊的方法来完成这一点。</p>
<p>正如在前面 “The Entity Script Files” 一节中提到的，实体可以有位于单元格上的一部分(以真实和幽灵的形式)，一部分在基础上，另一部分在客户端上，在他们的AoI中有实体。不同的实体类型可能只支持它们的一个、两个或所有三个实例。此外，实体类型的实例可能比其类型支持的部分更少。</p>
<p>通常，首先创建实体的基本部分，然后(如果合适的话)创建其单元格部分。这有很多原因。</p>
<ul>
<li>基本实体可以直接从数据库创建，而单元实体不能。</li>
<li>基本实体可以创建其单元格部分，但反之则不行。</li>
<li>单元实体需要关联的基本实体才能容错。</li>
<li>单元实体需要关联的基本实体来将自身写入数据库。</li>
</ul>
<p>对于具有基本部分和单元格部分的实体类型，基本部分总是在单元格部分之前创建，然后在它之后销毁。也可以创建一个没有基本部分的单元实体。</p>
<h3 id="8-1-Entity-Instantiation-on-the-BaseApp"><a href="#8-1-Entity-Instantiation-on-the-BaseApp" class="headerlink" title="8.1. Entity Instantiation on the BaseApp"></a><strong>8.1. Entity Instantiation on the BaseApp</strong></h3><p>基本实体可以通过以下方式创建:</p>
<ul>
<li>直接从脚本，使用方法BigWorld.createBaseAnywhere，BigWorld.createBaseLocally, 或者BigWorld.createBaseRemotely。</li>
<li>从数据库中，使用方法BigWorld.createBaseFromDBID 或者BigWorld.createBaseFromDB。</li>
</ul>
<p>BigWorld.createBaseAnywhere方法可以指定基实体和单元实体属性，并具有以下签名:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">createBaseAnywhere</span>(<span class="params"> entityTypeName, *args, **kwargs </span>):</span><br></pre></td></tr></table></figure>

<p>参数entityTypeName是一个字符串，包含要实例化的实体类型的名称。例如，要实例化一个实体ExampleEntity，该参数将是“ExampleEntity”。</p>
<p>在最简单的形式中，它使用所有默认值创建实体，并如下例调用:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newEntity = BigWorld.createBaseAnywhere( <span class="string">&quot;ExampleEntity&quot;</span> )</span><br></pre></td></tr></table></figure>

<p>此方法可以选择接受一列其他参数，搜索这些参数以创建基本实体值和单元实体值。这些参数可以是:</p>
<ul>
<li>关键词参数</li>
<li>字典</li>
<li>ResMgr.DataSection</li>
</ul>
<p>首先搜索关键字参数，然后是字典，最后是DataSection。如果没有为实体的任何属性找到值，则为该属性&#x2F;数据类型分配默认值。</p>
<p>在实体定义中找不到的关键字参数和字典值被设置为基本实体属性。</p>
<h4 id="8-1-1-ServiceApps"><a href="#8-1-1-ServiceApps" class="headerlink" title="8.1.1. ServiceApps"></a><strong>8.1.1. ServiceApps</strong></h4><p>ServiceApp是BaseApp的一种专门类型。它不会在登录过程中创建玩家实体，也不会使用BigWorld.createBaseAnywhere()创建基础实体。</p>
<p>虽然很少，实体可以使用bigworld.createbasellocal()在ServiceApps上创建。这可能很有用，例如，为了存储状态，将一个实体与一个Service片段关联起来。实体也可以使用bigworld.createbaseremote()创建。</p>
<h3 id="8-2-Cell-Entity-Creation-From-BaseApp"><a href="#8-2-Cell-Entity-Creation-From-BaseApp" class="headerlink" title="8.2. Cell Entity Creation From BaseApp"></a><strong>8.2. Cell Entity Creation From BaseApp</strong></h3><p>方法BigWorld.createBaseAnywhere只创建实体的基表示。如果需要单元实体，则基本实体有责任实例化其关联的单元实体。</p>
<p>要创建关联的单元实体，可以使用以下方法:</p>
<ul>
<li>Base.createCellEntity</li>
<li>Base.createInNewSpace</li>
<li>Base.createInDefaultSpace</li>
</ul>
<p>这些方法读取基本实体的特殊变量base.cellData(在创建基本实体时使用单元实体的数据进行初始化)来获取单元实体的初始化值。如果实体类型不支持单元实体，则基本实体将没有cellData。</p>
<p>变量cellData的行为就像一个字典，包含实体定义文件中定义的所有单元格属性(&lt;res&gt;&#x2F;scripts&#x2F;entity_defs&#x2F;&lt;entity&gt;.def)。</p>
<p>它还有另外三个成员:</p>
<ul>
<li>position - 三个浮点数(x, y, z)的序列，或者Vector3的位置来创建新的实体</li>
<li>direction - 三个浮动序列(横摇，俯仰和偏航)与新单元实体的方向。</li>
<li>spaceID - 如果没有以不同的方式指定空间，将在其中创建单元格实体的空间ID。</li>
</ul>
<p>一旦单元实体成功创建，将执行以下步骤:</p>
<ol>
<li>删除变量cellData。</li>
<li>使用单元实体的邮箱创建一个名为cell的变量</li>
<li>回调Base.onGetCell将被调用</li>
</ol>
<h4 id="8-2-1-Creation-Near-an-Existing-Cell-Entity"><a href="#8-2-1-Creation-Near-an-Existing-Cell-Entity" class="headerlink" title="8.2.1. Creation Near an Existing Cell Entity"></a><strong>8.2.1. Creation Near an Existing Cell Entity</strong></h4><p>下图说明了使用BigWorld模块的方法Base.createCellEntity创建单元格实体。当已创建单元格实体时，将无法使用此方法。</p>
<p><img src="/image%5Cbigworld%5C06_10.png" alt="06_10"></p>
<p>Python中createCellEntity方法的声明如下所示</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">createCellEntity</span>(<span class="params"> self, mailbox = <span class="literal">None</span> </span>):</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<p>参数邮箱是一个单元实体邮箱。新单元实体将在与邮箱引用相同的空间和单元中创建(如果邮箱不是None)。理想情况下，两个实体接近，因为这增加了实体从正确的单元开始的可能性。</p>
<p>下图显示了在正确的单元格上创建实体时的通信流:</p>
<p><img src="/image%5Cbigworld%5C06_11.png" alt="06_11"></p>
<p>下图显示了在错误的单元格上创建实体时的通信流:</p>
<img src="image\bigworld\06_12.png" alt="06_12" style="zoom:100%;" />

<h4 id="8-2-2-Creation-in-a-Numbered-Space"><a href="#8-2-2-Creation-in-a-Numbered-Space" class="headerlink" title="8.2.2. Creation in a Numbered Space"></a><strong>8.2.2. Creation in a Numbered Space</strong></h4><p>也可以通过在属性cellData中为spaceID设置一个适当的值来创建单元实体。这是应该避免的，因为它需要通过CellAppMgr发送请求，这可能会导致瓶颈。</p>
<p>一旦创建了单元实体，就会在基本实体上调用通知方法onGetCell。这是一个信号，表明现在可以安全地开始使用单元实体self.cell的邮箱了。</p>
<p>对于实体someEntity, onGetCell方法可以如下图所示定义:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> BigWorld</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">someEntity</span>( BigWorld.Base ):</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">onGetCell</span>(<span class="params"> self </span>):</span><br><span class="line">        <span class="comment"># this method was called, that means cell entity has been created.</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<h4 id="8-2-3-Creation-in-a-New-Space"><a href="#8-2-3-Creation-in-a-New-Space" class="headerlink" title="8.2.3. Creation in a New Space"></a><strong>8.2.3. Creation in a New Space</strong></h4><p>该方法Base.createInNewSpace向CellAppMgr发送一个请求来创建一个新的空间和它上面的实体。</p>
<p>产生的消息跟踪如下图所示:</p>
<p><img src="/image%5Cbigworld%5C06_13.png" alt="06_13"></p>
<h4 id="8-2-4-Creation-in-Default-Space"><a href="#8-2-4-Creation-in-Default-Space" class="headerlink" title="8.2.4. Creation in Default Space"></a><strong>8.2.4. Creation in Default Space</strong></h4><p>方法Base.createInDefaultSpace与方法Base.createInNewSpace类似，只是没有创建一个新的空间。</p>
<p>只有在配置文件&#x2F;server&#x2F;bw.xml中标记设置为true时，这才可用。</p>
<h3 id="8-3-Entity-Destruction"><a href="#8-3-Entity-Destruction" class="headerlink" title="8.3. Entity Destruction"></a><strong>8.3. Entity Destruction</strong></h3><p>基本实体总是在单元实体之前创建，并在单元实体之后销毁。</p>
<p>一个单元实体被破坏后所发生的一系列事件描述如下:</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>Base</th>
<th>Cell</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>调用方法destoryCellEntity</td>
<td>调用方法destory</td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>方法onDestory自动被调用</td>
</tr>
<tr>
<td>3</td>
<td>自动调用onLoseCell方法。如果base要被销毁，<br>这是调用destroy方法的好地方。</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>cell属性丢失</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>恢复cellData属性，并保留其销毁时的值。</td>
<td></td>
</tr>
</tbody></table>
<p>Base.destroy方法有两个布尔关键字参数:</p>
<ul>
<li>deleteFromDB - 默认值为fasle</li>
<li>writeToDB - 如果实体之前已写入数据库，则默认值为true</li>
</ul>
<h3 id="8-4-Entity-Instantiation-From-The-CellApp"><a href="#8-4-Entity-Instantiation-From-The-CellApp" class="headerlink" title="8.4. Entity Instantiation From The CellApp"></a><strong>8.4. Entity Instantiation From The CellApp</strong></h3><p>在创建单元实体时，可以使用对应的基实体创建单元实体，也可以不创建单元实体。下面的小节描述了这两种方法。</p>
<h4 id="8-4-1-Instantiation-With-No-Base-Counterpart"><a href="#8-4-1-Instantiation-With-No-Base-Counterpart" class="headerlink" title="8.4.1. Instantiation With No Base Counterpart"></a><strong>8.4.1. Instantiation With No Base Counterpart</strong></h4><p>可以调用方法BigWorld.createEntity来创建一个没有关联的基实体的单元格实体。此方案如下图所示：</p>
<p><img src="/image%5Cbigworld%5C06_14.png" alt="06_14"></p>
<p>方法BigWorld.createEntity具有以下签名：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">createEntity</span>(<span class="params"> entityTypeName, spaceID, position, direction, properties </span>):</span><br></pre></td></tr></table></figure>

<p>详情查看CellApp Python API’s entry <strong>Main Page</strong> → <strong>Cell</strong> →<strong>BigWorld</strong> → <strong>Function</strong> → <strong>createEntity</strong>.</p>
<h4 id="8-4-2-Instantiation-With-Base-Counterpart"><a href="#8-4-2-Instantiation-With-Base-Counterpart" class="headerlink" title="8.4.2. Instantiation With Base Counterpart"></a><strong>8.4.2. Instantiation With Base Counterpart</strong></h4><p>方法BigWorld.createEntityOnBase允许CellApp创建基本实体。它具有以下签名：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">createEntityOnBaseApp</span>(<span class="params"> entityTypeName, properties </span>):</span><br></pre></td></tr></table></figure>

<p>这个函数接受以下参数:</p>
<ul>
<li><strong>entityTypeName</strong> - 需要创建的实体名字</li>
<li><strong>properties</strong> - 在实体的定义文件中列出的在base上的属性字典。</li>
</ul>
<p>这个函数向一个BaseApp发送一个消息来创建一个基本实体，这个基本实体稍后可以调用createCellEntity方法来创建单元实体。</p>
<p><img src="E:\markDown\image\bigworld\06_15.png" alt="06_15"></p>
<h3 id="8-5-Loading-Entities-From-Chunk-Files"><a href="#8-5-Loading-Entities-From-Chunk-Files" class="headerlink" title="8.5. Loading Entities From Chunk Files"></a><strong>8.5. Loading Entities From Chunk Files</strong></h3><p>世界编辑器可用于将实体占位符插入到数据块中。这些占位符可以通过服务器上的Python脚本读取，从而使用BaseApps上的BigWorld.fetchEntitiesFromChunks方法将这些实体加载到游戏世界中。详情查看fantasydemo&#x2F;res&#x2F;scripts&#x2F;base&#x2F;TeleportPoint.py</p>
<h2 id="9-The-Database-Layer"><a href="#9-The-Database-Layer" class="headerlink" title="9. The Database Layer"></a><strong>9. The Database Layer</strong></h2><p>数据库层是BigWorld的持久实体仓库。它允许将特定实体写入在线存储(通常写入数据库表或磁盘文件)，并在稍后再次检索它们。</p>
<p>数据库层不是每个实体都要频繁访问的，而是只在实体创建和销毁时(可能在关键的交易点)才访问。你不应该试图访问数据库来响应每个角色的每一个动作——让灾难恢复机制来处理游戏的完整性。</p>
<p>本章详细介绍如何从数据库中存储和检索实体。</p>
<h3 id="9-1-Persistent-Properties"><a href="#9-1-Persistent-Properties" class="headerlink" title="9.1. Persistent Properties"></a><strong>9.1. Persistent Properties</strong></h3><p>持久化实体的第一步是编辑它的定义文件(命名为&lt;res&gt;&#x2F;scripts&#x2F; entity_defs&#x2F;&lt;entity&gt;.def)，并指定要持久化的属性。</p>
<p>持久属性集通常是实体属性的一个小子集。例如，角色扮演游戏通常有一组核心属性(力量、敏捷等)，以及一组需要临时修改的衍生属性(也许角色在登录时总是获得完整的生命力，所以生命力点不需要持续)。</p>
<p>要将一个实体属性标记为persistent，它需要添加标签&lt; persistent &gt;，如下图所示:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">somePersistentProperty</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Type</span>&gt;</span> TYPENAME <span class="tag">&lt;/<span class="name">Type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Flags</span>&gt;</span> FLAGS <span class="tag">&lt;/<span class="name">Flags</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Persistent</span>&gt;</span> true <span class="tag">&lt;/<span class="name">Persistent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">somePersistentProperty</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">Properties</span>&gt;</span> </span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果类型是FIXED_DICT，那么可以为FIXED_DICT数据类型的每个属性指定&lt;Persistent&gt;标记。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">someFixedDictProperty</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Type</span>&gt;</span> FIXED_DICT</span><br><span class="line">                <span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">a</span>&gt;</span> <span class="tag">&lt;<span class="name">Type</span>&gt;</span> TYPENAME <span class="tag">&lt;/<span class="name">Type</span>&gt;</span> <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">b</span>&gt;</span> </span><br><span class="line">                        <span class="tag">&lt;<span class="name">Type</span>&gt;</span> TYPENAME <span class="tag">&lt;/<span class="name">Type</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">Persistent</span>&gt;</span> false <span class="tag">&lt;/<span class="name">Persistent</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Flags</span>&gt;</span> FLAGS <span class="tag">&lt;/<span class="name">Flags</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Persistent</span>&gt;</span> true <span class="tag">&lt;/<span class="name">Persistent</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">somePersistentProperty</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，someFixedDictProperty.a是持久的，但是someFixedDictProperty.b是。如果&lt;someFixedDictProperty&gt;级别的&lt;Persistent&gt;标记为false，那么a和b都不是持久的。默认情况下，FIXED_DICT字段级别的&lt;Persistent&gt;标记为true，因此没有必要指定它，除非有选择地关闭某些字段的持久性</p>
<p>可以为MySQL数据库引擎的持久属性设置其他参数。</p>
<h4 id="9-1-1-Non-Persistent-Properties"><a href="#9-1-1-Non-Persistent-Properties" class="headerlink" title="9.1.1. Non-Persistent Properties"></a><strong>9.1.1. Non-Persistent Properties</strong></h4><p>每次创建实体时重置的属性不应该持久化。例如,实体的A.I.和GUI状态通常是非持久性的。减少持久属性的数量将减少数据库上的负载。如果一个属性不是持久的，当从数据库加载实体时，它的值将被设置为默认值。</p>
<p>邮箱属性总是非持久的。</p>
<h4 id="9-1-2-Built-In-Properties"><a href="#9-1-2-Built-In-Properties" class="headerlink" title="9.1.2. Built-In Properties"></a><strong>9.1.2. Built-In Properties</strong></h4><p>以下内置属性是持久的:</p>
<ul>
<li>Base:databaseID</li>
<li>Cell:position,direction,spaceID</li>
</ul>
<p>所有其他内置属性都是非持久化的。</p>
<p>实体的内置id属性不是持久的。它将在每次重新创建实体时更改。这包括通过灾难恢复机制自动重新创建实体的情况。因此，当存储其他实体的实体id时，它们应该存储在非持久属性中，以便在灾难恢复机制重新创建实体时，它们将自动重置为属性的默认值。这避免了存储无效实体id的可能性。</p>
<p>当实体被我们的容错机制恢复时，实体的id属性是不变的。</p>
<p>使用实体的数据库ID作为对实体的长期引用。</p>
<h4 id="9-1-3-Database-Indexing"><a href="#9-1-3-Database-Indexing" class="headerlink" title="9.1.3. Database Indexing"></a><strong>9.1.3. Database Indexing</strong></h4><p>一个简单的属性可以在数据库数据定义中建立索引，这样索引就可以帮助查找这些属性，比如在使用BaseApp的Python API调用BigWorld.lookUpBasesByIndex()。每个属性可以有唯一索引或非唯一索引。如果未指定，则不会为该属性创建索引。</p>
<p>下面是一个在属性上指定索引的示例:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">playerNickname</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Type</span>&gt;</span> STRING <span class="tag">&lt;/<span class="name">Type</span>&gt;</span></span><br><span class="line">            ...</span><br><span class="line">            <span class="tag">&lt;<span class="name">Persistent</span>&gt;</span> true <span class="tag">&lt;/<span class="name">Persistent</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Indexed</span>&gt;</span> true </span><br><span class="line">                <span class="tag">&lt;<span class="name">Unique</span>&gt;</span> true <span class="tag">&lt;/<span class="name">Unique</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Indexed</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">playerNickname</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">playerNumKills</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Type</span>&gt;</span> UINT16 <span class="tag">&lt;/<span class="name">Type</span>&gt;</span></span><br><span class="line">            ...</span><br><span class="line">            <span class="tag">&lt;<span class="name">Persistent</span>&gt;</span> true <span class="tag">&lt;/<span class="name">Persistent</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Indexed</span>&gt;</span> true </span><br><span class="line">                <span class="tag">&lt;<span class="name">Unique</span>&gt;</span> false <span class="tag">&lt;/<span class="name">Unique</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Indexed</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">playerNumKills</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>索引属性时有一些限制和条件:</p>
<ul>
<li>仅在使用MySQL数据库时支持索引。</li>
<li>只有持久属性是可索引的。</li>
<li>只有UNICODE_STRING, STRING, BLOB, FLOAT,UINT和INT变量是可索引的。例如，组合类型如ARRAY和FIXED_DICT是不可索引的。</li>
<li>UNICODE_STRING, STRING只有前255个字符是可索引的。BLOB类型的前255个字节是可索引的。</li>
</ul>
<p>在定义索引时，如果省略了Unique部分，则该索引被假定为非惟一的。</p>
<h4 id="9-1-4-The-Identifier-Tag"><a href="#9-1-4-The-Identifier-Tag" class="headerlink" title="9.1.4. The Identifier Tag"></a><strong>9.1.4. The Identifier Tag</strong></h4><p>&lt;Identifier&gt;标记是持久化STRING或BLOB实体属性的可选标记。它指定一个属性作为该实体类型的标识符。可以使用实体的标识符而不是数据库ID从数据库中检索实体。因此，所有相同类型的实体必须具有惟一标识符。每个实体最多只能有一个属性被标记为标识符。</p>
<p>例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">playerNickname</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">Type</span>&gt;</span> STRING <span class="tag">&lt;/<span class="name">Type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Flags</span>&gt;</span> Flags <span class="tag">&lt;/<span class="name">Flags</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Persistent</span>&gt;</span> true <span class="tag">&lt;/<span class="name">Persistent</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Identifier</span>&gt;</span> true <span class="tag">&lt;/<span class="name">Identifier</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">playerNickname</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">someProperty1</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">Type</span>&gt;</span> UINT32 <span class="tag">&lt;/<span class="name">Type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">someProperty1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">someProperty2</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">Type</span>&gt;</span> STRING <span class="tag">&lt;/<span class="name">Type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Persistent</span>&gt;</span> true <span class="tag">&lt;/<span class="name">Persistent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">someProperty2</span>&gt;</span></span><br><span class="line">         ...</span><br></pre></td></tr></table></figure>

<p>然后假设上述实体类型有三个实例，它们可以如下表所示:</p>
<table>
<thead>
<tr>
<th>playerNickname</th>
<th>someProperty2</th>
</tr>
</thead>
<tbody><tr>
<td>playerNickname1</td>
<td>“cfeh”</td>
</tr>
<tr>
<td>playerNickname2</td>
<td>“fwep”</td>
</tr>
<tr>
<td>playerNickname3</td>
<td>“fwep”</td>
</tr>
</tbody></table>
<p>注意，&lt;someProperty1&gt;在数据库中没有表示，因为它没有被指定为持久的。</p>
<p>可以使用BigWorld.lookUpBaseByName和BigWorld.createBaseFromDB等方法按名称搜索具有属性的实体类型。有关详细信息，请参见BaseAppPythonAPI。</p>
<p>将属性标记为标识符属性还会向该属性添加唯一索引。（见Database Indexing）</p>
<h3 id="9-2-Reading-and-Writing-Entities"><a href="#9-2-Reading-and-Writing-Entities" class="headerlink" title="9.2. Reading and Writing Entities"></a><strong>9.2. Reading and Writing Entities</strong></h3><p>数据库提供了保存实体的方法，并在以后将它们返回到世界中。它还保证每个保存的实体在世界中只能有一个实例。这可以确保正确地执行实体对数据库的任何写入操作。</p>
<p>为了使用这个功能，您必须首先创建一个持久实体。这样的实体必须存在于BaseApp，可以是BigWorld.base。库或BigWorld.Proxy。您可以使用任何常规技术创建它。</p>
<p>持久化实体的关键是其属性databaseID，并其实体类型。属性databaseID是一个64位整数，在相同类型的实体中是唯一的，通常对应于数据库表中的一个自动增量字段。当使用任何常用技术创建实体时，其数据库ID设置为0，表示从未写入数据库。</p>
<p>要将新创建的实体添加到数据库中，必须调用它的方法writeToDB(从单元格或基库)。</p>
<p>如果在基本实体上调用，writeToDB会接收一个可选参数，指定回调方法。完成后，writeToDB将调用回调函数，并传递一个布尔参数(指示向数据库写入是成功还是失败)和调用该方法的基本实体。使用通知方法，因为数据库写操作是异步操作。</p>
<p>下面的代码片段演示了如何使用基类中的方法writeToDB。</p>
<ol>
<li><p>在someEntity的基础脚本(&lt;res&gt;&#x2F;scripts&#x2F;base&#x2F;someEntity.py)中，为writeToDB定义回调方法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> BigWorld</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">someEntity</span>( BigWorld.Base )</span><br><span class="line">...</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">onWriteToDBComplete</span>(<span class="params"> successful, entity </span>):</span><br><span class="line">    <span class="keyword">if</span> successful:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;write %i OK. databaseID = %i&quot;</span> % (entity.<span class="built_in">id</span>, databaseID)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;write %i was not successful&quot;</span> % entity.<span class="built_in">id</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用方法来创建base并将其添加到数据库:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ent = BigWorld.createBase( <span class="string">&quot;someEntity&quot;</span> )</span><br><span class="line">ent.writeToDB( onWriteToDBComplete )</span><br></pre></td></tr></table></figure>
</li>
<li><p>BaseApp中显示的结果:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write <span class="number">92</span> OK. databaseID = <span class="number">376182</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>下一次这个实体被销毁时(通过调用ent.destroy方法)，它将被“注销”——数据库层会跟踪这个实体是否在世界上。</p>
<p>稍后可以使用方法BigWorld.createBaseFromDBID和数据库中存储的属性将被销毁的实体带回世界，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BigWorld.createBaseFromDBID( <span class="string">&quot;someEntity&quot;</span>, <span class="number">376182</span>, optionalCallbackMethod )</span><br></pre></td></tr></table></figure>

<p>由于从数据库加载一个已销毁的实体也是一个异步操作，如果你希望这个过程的完成得到通知，你需要传递一个回调函数作为方法bigworld . createbasefrombid的第三个参数。回调函数接收实体标识符作为唯一参数，如果实体加载成功，则为databaseID，否则为None。</p>
<p>下面的代码片段演示了从数据库重新加载实体的请求:</p>
<ol>
<li><p>在someEntity的基础脚本(&lt;res&gt;&#x2F;scripts&#x2F;base&#x2F;someEntity.py)中，定义createBaseFromDBID的回调方法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> BigWorld</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">onComplete</span>(<span class="params"> entity </span>):</span><br><span class="line">    <span class="keyword">if</span> entity <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;entity successfully created&quot;</span> </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;entity was not created&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用有效的databaseID调用createBaseFromDBID:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BigWorld.createBaseFromDBID( <span class="string">&quot;someEntity&quot;</span>, <span class="number">376182</span>, onComplete )</span><br></pre></td></tr></table></figure>
</li>
<li><p>BaseApp中显示的结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">entity successfully created</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用无效的databaseID调用createBaseFromDBID:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BigWorld.createBaseFromDBID( <span class="string">&quot;someEntity&quot;</span>, <span class="number">10000000000</span>, onComplete )</span><br></pre></td></tr></table></figure>
</li>
<li><p>在BaseApp中显示的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">entity was not created</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="9-3-Mapping-BigWorld-Properties-Into-SQL"><a href="#9-3-Mapping-BigWorld-Properties-Into-SQL" class="headerlink" title="9.3. Mapping BigWorld Properties Into SQL"></a><strong>9.3. Mapping BigWorld Properties Into SQL</strong></h3><p>在设计持久属性时，了解数据库层如何执行从BigWorld类型到SQL类型的映射是很有用的。此信息可用于性能调优或手动修改数据库。</p>
<h4 id="9-3-1-Entity-Tables"><a href="#9-3-1-Entity-Tables" class="headerlink" title="9.3.1. Entity Tables"></a><strong>9.3.1. Entity Tables</strong></h4><p>每个实体类型在数据库中都有一个主实体表，以及零个或多个子表。</p>
<p>实体类型的主表名为tbl_<entity_type_name>。大多数BigWorld类型的数据将存储在主表的列中。但是，像ARRAY和TUPLE这样的类型需要使用额外的表，在本文档中称为子表。</p>
<p>除了ARRAY和TUPLE属性外，每个实体的数据都存储为实体类型的主表中的一行。</p>
<h4 id="9-3-2-The-databaseID-property"><a href="#9-3-2-The-databaseID-property" class="headerlink" title="9.3.2. The databaseID property"></a><strong>9.3.2. The</strong> <strong>databaseID</strong> <strong>property</strong></h4><p>一个实体的databaseID属性存储在主表的id列中——这就是为什么没有持久属性的实体仍然有一个主实体表。</p>
<h4 id="9-3-3-Simple-Data-Types"><a href="#9-3-3-Simple-Data-Types" class="headerlink" title="9.3.3. Simple Data Types"></a><strong>9.3.3. Simple Data Types</strong></h4><p>具有简单数据类型的属性被映射到具有可容纳的类型的单个SQL列(名为sm_<property_name>)。</p>
<p>下表描述了每个BigWorld简单数据类型，以及它映射到的MySQL类型:</p>
<p>表格将简单的BigWorld数据类型映射到SQL。</p>
<table>
<thead>
<tr>
<th>BigWorld data type</th>
<th>映射到MySQL类型</th>
</tr>
</thead>
<tbody><tr>
<td>INT8</td>
<td>TINYINT</td>
</tr>
<tr>
<td>UINT8</td>
<td>TINYINT UNSIGNED</td>
</tr>
<tr>
<td>INT16</td>
<td>SMALLINT</td>
</tr>
<tr>
<td>UINT16</td>
<td>SMALLINT UNSIGNED</td>
</tr>
<tr>
<td>INT32</td>
<td>INT</td>
</tr>
<tr>
<td>UINT32</td>
<td>INT UNSIGNED</td>
</tr>
<tr>
<td>INT64</td>
<td>BIGINT</td>
</tr>
<tr>
<td>UINT64</td>
<td>BIGINT UNSIGNED</td>
</tr>
<tr>
<td>FLOAT32</td>
<td>FLOAT</td>
</tr>
<tr>
<td>FLOAT64</td>
<td>DOUBLE</td>
</tr>
</tbody></table>
<h4 id="9-3-4-VECTOR-Data-Types"><a href="#9-3-4-VECTOR-Data-Types" class="headerlink" title="9.3.4. VECTOR Data Types"></a><strong>9.3.4. VECTOR Data Types</strong></h4><p>具有向量类型的属性被映射到MySQL类型FLOAT的适当列数‐命名为vm_&lt;index&gt;_<property_name>，其中&lt;index&gt;是从0到向量大小减1的数字。下面的列表描述了每个BigWorld VECTOR数据类型，以及它映射到的MySQL类型:</p>
<p>表格将BigWorld VECTOR数据类型映射到MySQL。</p>
<table>
<thead>
<tr>
<th>BigWorld data type</th>
<th>#of columns</th>
<th>映射到MySQL类型</th>
</tr>
</thead>
<tbody><tr>
<td>VECTOR2</td>
<td>2</td>
<td>FLOAT</td>
</tr>
<tr>
<td>VECTOR3</td>
<td>3</td>
<td>FLOAT</td>
</tr>
<tr>
<td>VECTOR4</td>
<td>4</td>
<td>FLOAT</td>
</tr>
</tbody></table>
<h4 id="9-3-5-STRING-UNICODE-STRING-BLOB-and-PYTHON-Data-Types"><a href="#9-3-5-STRING-UNICODE-STRING-BLOB-and-PYTHON-Data-Types" class="headerlink" title="9.3.5. STRING, UNICODE_STRING, BLOB, and PYTHON Data Types"></a><strong>9.3.5. STRING, UNICODE_STRING, BLOB, and PYTHON Data Types</strong></h4><p>STRING、UNICODE_STRING、BLOB和PYTHON类型的属性将被映射到列sm_<property_name>，类型依赖于实体定义文件中指定的属性的&lt;DatabaseLength&gt;属性，因为当类型映射到SQL时，它决定了列的宽度。</p>
<p>下面的列表总结了STRING、UNICODE_STRING、BLOB和PYTHON数据类型的映射:</p>
<ul>
<li><p>PYTHON</p>
<ul>
<li><strong>DatabaseLength</strong> <strong>&lt; 256</strong> ‐ TINYBLOB</li>
<li><strong>DatabaseLength</strong> <strong>&gt;&#x3D; 256 and &lt; 65536</strong> ‐ BLOB</li>
<li><strong>DatabaseLength</strong> <strong>&gt;&#x3D; 65536 and &lt; 16777215</strong> ‐ MEDIUMBLOB</li>
</ul>
</li>
<li><p>STRING</p>
<ul>
<li><strong>DatabaseLength</strong> <strong>&lt; 256</strong> ‐ VARBINARY</li>
<li><strong>DatabaseLength</strong> <strong>&gt;&#x3D; 256 and &lt; 65536</strong> ‐ BLOB</li>
<li><strong>DatabaseLength</strong> <strong>&gt;&#x3D; 65536 and &lt; 16777215</strong> ‐ MEDIUMBLOB</li>
<li><strong>DatabaseLength</strong> <strong>&gt;&#x3D; 16777216</strong> ‐ LONGBLOB</li>
</ul>
</li>
<li><p>UNICODE_STRING</p>
<p>UNICODE_STRING类型映射到下面列出的MySQL字符串类型。用于在数据库中存储这些字符串的字符编码由bw.xml选项dbMgr&#x2F;unicodeString&#x2F;characterSet的值决定。</p>
<ul>
<li><strong>(DatabaseLength</strong> <strong>x 3) &lt; 256</strong> ‐ VARCHAR</li>
<li><strong>(DatabaseLength</strong> <strong>x 3) &gt;&#x3D; 256 and &lt; 65536</strong> ‐ TEXT</li>
<li><strong>(DatabaseLength</strong> <strong>x 3) &gt;&#x3D; 65536 and &lt; 16777215</strong> ‐ MEDIUMTEXT</li>
<li><strong>DatabaseLength</strong> <strong>&gt;&#x3D; 16777216</strong> ‐ LONGTEXT</li>
</ul>
</li>
</ul>
<p>&lt;DatabaseLength&gt;的定义如下所示:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">someProperty</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Type</span>&gt;</span> STRING <span class="tag">&lt;/<span class="name">Type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Persistent</span>&gt;</span> true <span class="tag">&lt;/<span class="name">Persistent</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">DatabaseLength</span>&gt;</span> 16 <span class="tag">&lt;/<span class="name">DatabaseLength</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">someProperty</span>&gt;</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<h4 id="9-3-6-PATROL-PATH-and-UDO-REF-Data-Types"><a href="#9-3-6-PATROL-PATH-and-UDO-REF-Data-Types" class="headerlink" title="9.3.6. PATROL_PATH and UDO_REF Data Types"></a><strong>9.3.6. PATROL_PATH and UDO_REF Data Types</strong></h4><p>PATROL_PATH类型已被废弃，以支持使用用户数据对象，并且应该避免使用，因为它们将在未来的版本中被删除。用户数据对象将替换旧系统的站点节点。</p>
<p>具有UDO_REF类型的属性被映射到一个二进制类型的列，名为sm_&lt;property_name&gt;列宽度为16字节，对应于标识巡逻路径或用户的128位GUID数据对象类型。</p>
<p>128位GUID作为四组32位无符号整数存储在列中。每个整数都是小端顺序的。例如，GUID为00112233.44556677.8899AABB.CCDDEEFF，则列中的字节值将为3322110077665544BBAA9988FFEEDDCC。</p>
<h4 id="9-3-7-ARRAYs-and-TUPLEs"><a href="#9-3-7-ARRAYs-and-TUPLEs" class="headerlink" title="9.3.7. ARRAYs and TUPLEs"></a><strong>9.3.7. ARRAYs and TUPLEs</strong></h4><p>每个ARRAY或TUPLE属性都映射到一个SQL表，称为实体主表的子表，命名为<parent_table_name>_<property_name>。</p>
<p>&lt;parent_table_name&gt;是实体类型的主表的名称，除非数组或元组嵌套在另一个数组或元组属性中，在这种情况下<parent_table_name>是父数组或元组表的名称。</p>
<p>ARRAY或TUPLE子表有一个parentID列，用于存储与数据关联的父表中的行id。子表还将有一个id列来维护元素的顺序，并在有子表的子表的情况下提供行标识符。</p>
<p>子表的其他列将由ARRAY或TUPLE的元素类型(例如，一个ARRAY &lt;of&gt; INT8 &lt;&#x2F;of&gt;将产生一个额外的TINYINT类型的列)。大多数BigWorld类型只需要一个额外的列，该列将被称为sm_value。</p>
<h4 id="9-3-7-1-Storing-ARRAYs-and-TUPLEs-as-a-BLOB"><a href="#9-3-7-1-Storing-ARRAYs-and-TUPLEs-as-a-BLOB" class="headerlink" title="9.3.7.1. Storing ARRAYs and TUPLEs as a BLOB"></a><strong>9.3.7.1. Storing ARRAYs and TUPLEs as a BLOB</strong></h4><p>可以将每个ARRAY或TUPLE配置为在MEDIUMBLOB列中以内部二进制格式存储其数据，而不是将ARRAY和TUPLE数据存储在单独的表中。该行为由&lt;persistAsBlob&gt;选项控制:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">someProperty</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Type</span>&gt;</span> </span><br><span class="line">                ARRAY <span class="tag">&lt;<span class="name">of</span>&gt;</span> INT32 <span class="tag">&lt;/<span class="name">of</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">persistAsBlob</span>&gt;</span> true <span class="tag">&lt;/<span class="name">persistAsBlob</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">someProperty</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>&lt;persistAsBlob&gt;默认为假。</p>
<p>将数据存储为blob可以显著提高数据库性能，特别是对于深度嵌套的数组。但是，二进制数据是BigWorld的内部格式，不应该直接使用修改SQL语句。只能通过将实体加载到BigWorld、在Python中修改数据，然后将实体写回数据库来修改数据。</p>
<h4 id="9-3-7-2-The-lt-DatabaseLength-gt-Attribute"><a href="#9-3-7-2-The-lt-DatabaseLength-gt-Attribute" class="headerlink" title="9.3.7.2. The &lt;DatabaseLength&gt; Attribute"></a><strong>9.3.7.2. The</strong> <strong>&lt;DatabaseLength&gt;</strong> <strong>Attribute</strong></h4><p>如果数组的元素类型是STRING、BLOB或PYTHON，则ARRAY或TUPLE属性的&lt;DatabaseLength&gt;属性应用于该数组的元素类型。</p>
<p>其他类型要么不使用&lt;DatabaseLength&gt;修饰符，要么像FIXED_DICT的情况一样，使用自己的方法指定&lt;DatabaseLength&gt;。</p>
<h4 id="9-3-8-FIXED-DICTs"><a href="#9-3-8-FIXED-DICTs" class="headerlink" title="9.3.8. FIXED_DICTs"></a><strong>9.3.8. FIXED_DICTs</strong></h4><p>如果实体类型包含FIXED_DICT属性，那么该属性的字段就会映射到数据库，就像它们包含实体的属性一样。</p>
<p>FIXED_DICT列比非FIXED_DICT列有更详细的名称:</p>
<ul>
<li><p>sm_*<property_name><em>_</em><field_name>*</p>
<p>如果FIXED_DICT属性包含一个ARRAY或TUPLE字段，那么相应的子表的名称会更详细:</p>
</li>
<li><p><em><parent_table_name></em><em><em><property_name></em></em><em><field_name></em></p>
<p>如果FIXED_DICT类型用作ARRAY或TUPLE的元素，则字段被映射到ARRAY或TUPLE子表的列中。列将命名为sm_&lt;字段名&gt;。</p>
</li>
</ul>
<p>如果FIXED_DICT属性将&lt;AllowNone&gt;属性设置为true，那么将向表中添加一个名为fm_<property_name>的附加列。当属性值为None时，该列的值为0，否则为1。</p>
<p>&lt;DatabaseLength&gt;属性应该在FIXED_DICT属性的字段级别指定——在属性级别指定的属性被忽略。</p>
<h4 id="9-3-9-USER-TYPEs"><a href="#9-3-9-USER-TYPEs" class="headerlink" title="9.3.9. USER_TYPEs"></a><strong>9.3.9. USER_TYPEs</strong></h4><p>如果您有一个USER_TYPE数据类型，那么您可以指定它应该如何映射到SQL。</p>
<p>为了提供这种映射，需要在USER_TYPE中实现名为bindSectionToDB的方法。此方法接收一个对象作为其参数，用于声明数据绑定。例如，对于一个由TestUserType类型的实例实现的USER_TYPE:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestUserType</span>( <span class="title class_ inherited__">object</span> ):</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addToStream</span>(<span class="params"> self, obj </span>):</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bindSectionToDB</span>(<span class="params"> self, binder </span>):</span><br><span class="line">        ...</span><br><span class="line">instance = TestUserType()</span><br></pre></td></tr></table></figure>

<p>bindSectionToDB接收到的用于执行类型映射的对象(上例中的绑定器)提供了以下方法:</p>
<ul>
<li><p><strong>bind(property,type,databaseLength)</strong></p>
<p>将数据区中的属性(基于名称)绑定到当前SQL表中的一个或多个字段，并创建一个名为sm_<property_name>的列。</p>
<p>参数类型是一个字符串，对应于属性的XML定义的&lt; type &gt;字段。例如:</p>
<table>
<thead>
<tr>
<th>Data type</th>
<th>XML</th>
<th>type</th>
</tr>
</thead>
<tbody><tr>
<td>Simple</td>
<td>&lt;Type&gt; INT &lt;&#x2F;Type&gt;</td>
<td>INT</td>
</tr>
<tr>
<td>ARRAY</td>
<td>&lt;Type&gt; ARRAY &lt;of&gt; INT&lt;&#x2F;of&gt; &lt;&#x2F;Type</td>
<td>ARRAY&lt;of&gt; INT&lt;of&gt;</td>
</tr>
<tr>
<td>Custom</td>
<td>&lt;Type&gt; USER_TYPE &lt;implementedBy&gt; <br>module.instance &lt;&#x2F;implementedBy&gt; &lt;&#x2F;Type&gt;</td>
<td>USER_TYPE &lt;implementedBy&gt;<br>module.instance &lt;&#x2F;implementedBy&gt;</td>
</tr>
</tbody></table>
<p>参数databaseLength是可选的(默认为255)，它决定了STRING映射的大小和数据类型。</p>
</li>
<li><p><strong>beginTable(property)</strong></p>
<p>开始指定一个新的SQL表(称为<current_table_name>_<property_name>)，用于绑定Python复合对象，如列表、元组、字典。在beginTable调用之后，任何对方法bind的调用都将绑定到新表中的字段，直到endTable被调用。</p>
<p>通常，beginTable只用于绑定包含可变数量复合对象的Python复合对象，例如元组列表。对于简单的列表和元组，调用bind ‘ARRAY&lt;of&gt;&lt;simple_type&gt;&lt;&#x2F;of&gt;’作为类型就足够了。对于包含固定数量项的复合对象，将每个项作为父表中的一个单独字段绑定，而不是创建一个新表，这样更有效。</p>
<p>由beginTable创建的所有表都有一个附加字段parentID，用于将新表中的行与父表关联起来。</p>
</li>
<li><p><strong>endTable()</strong></p>
<p>完成由方法beginTable启动的新SQL表的规范。</p>
<p>完成后，将恢复父表的指定。</p>
</li>
</ul>
<p>方法bindSectionToDB的实现必须与方法addToStream的实现匹配。绑定调用的顺序和参数类型必须与属性序列化的顺序匹配。</p>
<p>下表显示了addToStream实现和相应的bindSectionToDB实现:</p>
<table>
<thead>
<tr>
<th align="left">addToStream实现</th>
<th>对应的bindSectionToDB实现</th>
</tr>
</thead>
<tbody><tr>
<td align="left">stream +&#x3D; struct.pack( <strong>“b”</strong>, obj.intValue )</td>
<td>binder.bind( “intValue”, <strong>“INT8”</strong> )</td>
</tr>
<tr>
<td align="left">stream +&#x3D; struct.pack( <strong>“B”</strong>, obj.intValue )</td>
<td>binder.bind( “intValue”, <strong>“UINT8”</strong> )</td>
</tr>
<tr>
<td align="left">stream +&#x3D; struct.pack( <strong>“h”</strong>, obj.intValue )</td>
<td>binder.bind( “intValue”, <strong>“INT16”</strong> )</td>
</tr>
<tr>
<td align="left">stream +&#x3D; struct.pack( <strong>“H”</strong>, obj.intValue )</td>
<td>binder.bind( “intValue”, <strong>“UINT16”</strong> )</td>
</tr>
<tr>
<td align="left">stream +&#x3D; struct.pack( <strong>“i”</strong>, obj.intValue )</td>
<td>binder.bind( “intValue”, <strong>“INT32”</strong> )</td>
</tr>
<tr>
<td align="left">stream +&#x3D; struct.pack( <strong>“I”</strong>, obj.intValue )</td>
<td>binder.bind( “intValue”, <strong>“UINT32”</strong> )</td>
</tr>
<tr>
<td align="left">stream +&#x3D; struct.pack( <strong>“q”</strong>, obj.intValue )</td>
<td>binder.bind( “intValue”, <strong>“INT64”</strong> )</td>
</tr>
<tr>
<td align="left">stream +&#x3D; struct.pack( <strong>“Q”</strong>, obj.intValue )</td>
<td>binder.bind( “intValue”, <strong>“UINT64”</strong> )</td>
</tr>
<tr>
<td align="left">stream +&#x3D; struct.pack( <strong>“f”</strong>, obj.floatValue )</td>
<td>binder.bind( “floatValue”, <strong>“FLOAT32”</strong>)</td>
</tr>
<tr>
<td align="left">stream +&#x3D; struct.pack( <strong>“b”</strong>, len(obj.stringValue) )+ stringValue</td>
<td>binder.bind( “stringValue”, <strong>“STRING”</strong>, 50)</td>
</tr>
<tr>
<td align="left">stream +&#x3D; struct.pack ( “i”, len(obj.listValue) )<br>for item in obj.listValue stream +&#x3D; struct.pack<br>( “f”, item )</td>
<td>binder.beginTable( “listValue” )<br>binder.bind( “value”, “FLOAT32” )<br>binder.endTable()<br>or<br>binder.bind( “listValue”, “ARRAY &lt;of&gt; FLOAT32 &lt;&#x2F;of&gt;”)</td>
</tr>
</tbody></table>
<h4 id="9-3-9-1-Examples"><a href="#9-3-9-1-Examples" class="headerlink" title="9.3.9.1. Examples"></a><strong>9.3.9.1. Examples</strong></h4><ul>
<li><strong>Mapping a simple user-defined data type</strong></li>
<li><strong>Mapping a complex user-defined type</strong></li>
</ul>
<p>(之后再回来看)</p>
<h3 id="9-4-Execute-Arbitrary-Commands-on-Database"><a href="#9-4-Execute-Arbitrary-Commands-on-Database" class="headerlink" title="9.4. Execute Arbitrary Commands on Database"></a><strong>9.4. Execute Arbitrary Commands on Database</strong></h3><p>BigWorld为开发人员提供了在底层数据库上执行任意命令的工具。通过使用BigWorld.executeRawDatabaseCommand可以执行自定义语句或命令，并访问不符合标准BigWorld数据库模式的数据。</p>
<p>每个数据库接口都可以解释数据(命令)并将其转换为预期的格式。例如，MySQL接口需要一条SQL语句，XML接口需要一条Python语句。</p>
<h4 id="9-4-1-Execute-Commands-on-SQL-Database"><a href="#9-4-1-Execute-Commands-on-SQL-Database" class="headerlink" title="9.4.1. Execute Commands on SQL Database"></a><strong>9.4.1. Execute Commands on SQL Database</strong></h4><p>当在SQL数据库上执行命令时，BigWorld.executeRawDatabaseCommand有如下签名:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BigWorld.executeRawDatabaseCommand( sql_statement, sqlResultCallback )</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>sql_statement</strong></p>
<p>要执行的SQL语句。例如:’SELECT * FROM tbl_Avatar’。</p>
</li>
<li><p><strong>sqlResultCallback</strong></p>
<p>使用SQL的结果调用的Python回调函数。</p>
</li>
</ul>
<p>可以使用多条命令，以逗号隔开。</p>
<p>对于单结果集命令，以下参数被传递给回调:</p>
<ul>
<li><p><strong>resultSet</strong> <strong>(List of list of strings)</strong></p>
<p>对于返回结果集(如SELECT)的SQL语句，这是一个行列表，每一行是一个字符串列表。</p>
<p>对于不返回结果集(如DELETE)的SQL语句，这是None。</p>
</li>
<li><p><strong>affectedRows</strong> <strong>(Integer)</strong></p>
<p>对于返回结果集(如SELECT)的SQL语句，这是None。</p>
<p>对于不返回结果集(如DELETE)的SQL语句，这是受影响的行数</p>
</li>
<li><p><strong>error</strong> <strong>(String)</strong></p>
<p>如果在执行SQL语句时出现错误，则这是一条错误消息。否则，这是None。</p>
</li>
</ul>
<p>对于多结果集命令，将传递一个列表，其中包含每个元素的元组。这三个元素对应于上面的参数(resultSet、affectedRows和errors)，对于每个返回的结果集，列表都包含这些元组中的一个。</p>
<h4 id="9-4-2-Execute-Commands-on-XML-Database"><a href="#9-4-2-Execute-Commands-on-XML-Database" class="headerlink" title="9.4.2. Execute Commands on XML Database"></a><strong>9.4.2. Execute Commands on XML Database</strong></h4><p>在XML数据库上执行命令时，BigWorld.executeRawDatabaseCommand有如下签名:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BigWorld.executeRawDatabaseCommand( python_statement, pythonResultCallback )</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>python_statement</strong></p>
<p>要执行的Python表达式</p>
</li>
<li><p><strong>pythonResultCallback</strong></p>
<p>使用Python表达式的结果调用的Python回调函数。</p>
</li>
</ul>
<p>XML数据库存储在一个名为BigWorld.dbRoot的全局数据部分中。数据段的结构由实体定义文件(&lt;res&gt;&#x2F;scripts&#x2F;entity_defs&#x2F;&lt;entity&gt;.def)定义。</p>
<ul>
<li><p><strong>resultSet</strong> <strong>(List of list of strings)</strong></p>
<p>Python表达式的输出，作为字符串。</p>
<p>字符串嵌入在两层列表中，因此resultSet[0][0]检索字符串。</p>
</li>
<li><p><strong>affectedRows</strong> <strong>(Integer)</strong></p>
<p>该参数将始终为None。</p>
</li>
<li><p><strong>error</strong> <strong>(String)</strong></p>
<p>如果在执行Python表达式时出现错误，则这是错误消息。否则，这是None。</p>
</li>
</ul>
<p>下面的代码片段在XML数据库上执行一个命令:</p>
<ol>
<li><p>请求一个名为“Fred”的角色的生命值等级:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigWorld.executeRawDatabaseCommand(<span class="string">&quot;[a[1][&#x27;health&#x27;].asInt for a in BigWorld.dbRoot.items() if a[0]==&#x27;Avatar&#x27; and a[1][&#x27;playerName&#x27;].asString == &#x27;Fred&#x27;]&quot;</span>,healthCallback</span><br><span class="line"> )</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现Python回调:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">healthCallback</span>(<span class="params"> result, dummy, error </span>):</span><br><span class="line">    <span class="keyword">if</span> (error):</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;Error:&quot;</span>, error</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Health:&quot;</span>, result[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果角色的生命值是87，那么输出将是:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Health: [<span class="number">87</span>]</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="9-5-Secondary-Databases"><a href="#9-5-Secondary-Databases" class="headerlink" title="9.5. Secondary Databases"></a><strong>9.5. Secondary Databases</strong></h3><p>辅助数据库是一个可选特性，通过将数据库写入分布到带有BaseApp进程的机器上，可以帮助减少主数据库的负载。</p>
<p>此处不做过多讨论，启用辅助数据库时持久实体数据流：</p>
<p><img src="/image%5Cbigworld%5C06_16.png" alt="06_16"></p>
<h2 id="10-Character-Sets-and-Encodings"><a href="#10-Character-Sets-and-Encodings" class="headerlink" title="10. Character Sets and Encodings"></a><strong>10. Character Sets and Encodings</strong></h2><p>在处理ASCII范围以外的字符时，可能需要将多字节值转换为定义良好的格式，以便网络传输和存储在文件或数据库中。服务器的所有区域和服务器工具默认使用UTF-8字符编码。</p>
<p>在讨论Unicode和字符编码时，我们使用一些常见的术语。</p>
<ul>
<li><p><strong>Unicode</strong></p>
<p>表示任何语言文本(字符和符号)的标准。</p>
<p>每种语言的字符都由唯一的代码点表示。在讨论代码点时，为了清晰起见，通常会在代码点前加上U或U+。</p>
</li>
<li><p><strong>Character encoding</strong></p>
<p>在应用程序之间传输数据时表示多字节值的标准，例如3字节Unicode码点。</p>
<p>例如:UTF-8, Big5, GB18030, GB2312, KOI8-R</p>
</li>
<li><p><strong>Encode</strong></p>
<p>将Unicode码位(或一系列码位)转换为特定字符编码的过程。</p>
</li>
<li><p><strong>Decode</strong></p>
<p>将一个字节(或字节数组)从字符编码转换为一组Unicode码位的过程。</p>
</li>
</ul>
<h3 id="10-1-Python-and-Entity-Properties"><a href="#10-1-Python-and-Entity-Properties" class="headerlink" title="10.1. Python and Entity Properties"></a><strong>10.1. Python and Entity Properties</strong></h3><p>在每个Python解释器中，都有一个用于从字符串对象转换为unicode对象的默认编码。当前的默认编码可以通过在Python解释器中运行以下代码来查看:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getdefaultencoding()</span><br><span class="line"><span class="string">&#x27;ascii&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在BigWorld FantasyDemo源代码中，默认编码由变量控制DEFAULT_ENCODING在文件fantasydemo&#x2F;res&#x2F;scripts&#x2F;common&#x2F;BWAutoImport.py中。默认情况下，该值被设置为utf-8，但是可以根据需要将其更改为任何有效的Python编码。</p>
<p>由于Python是用于与实体及其属性进行交互的脚本语言，所以理解实体属性的默认Python编码的含义是很重要的。这主要影响两种实体属性数据类型，STRING和UNICODE_STRING。</p>
<h4 id="10-1-1-STRING"><a href="#10-1-1-STRING" class="headerlink" title="10.1.1. STRING"></a><strong>10.1.1.</strong> <strong>STRING</strong></h4><p>使用STRING数据类型的实体属性作为字节数组在网络上传输，不需要任何修改，并作为BLOB存储在MySQL数据库中。这种类型的属性被期望直接映射到Python字符串对象。</p>
<p>当将unicode字符串赋值给string属性时，程序员必须显式地encode()该字符串。例如，假设默认编码为UTF-8:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>self.string_property = <span class="string">u&quot;\u4e04&quot;</span>.encode()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="built_in">repr</span>( self.string_property )</span><br><span class="line"><span class="string">&#x27;\xe4\xb8\x84&#x27;</span></span><br></pre></td></tr></table></figure>

<p>由于STRING属性以二进制BLOB的形式存储在数据库中，因此可以使用此方法使用任何字符编码，因为程序员需要确保对字符串的所有Python脚本引用都使用相同的编码。</p>
<h4 id="10-1-2-UNICODE-STRING"><a href="#10-1-2-UNICODE-STRING" class="headerlink" title="10.1.2. UNICODE_STRING"></a><strong>10.1.2.</strong> <strong>UNICODE_STRING</strong></h4><p>使用UNICODE_STRING数据类型的实体属性应该是一个Python unicode类型对象，可以根据需要调用它们的encode()和decode()方法，分别从Python字符串对象转换为Python字符串对象。</p>
<p>为了在网络周围传输UNICODE_STRING属性，它们被BigWorld引擎编码到UTF-8，然后在解流后解码到Python单节点对象。这是由bigworld&#x2F;src&#x2F;lib&#x2F;entitydef&#x2F;data_types中的UnicodeStringDataType类执行的。</p>
<p>UNICODE_STRING属性的MySQL存储与常规的字符串对象略有不同。这些属性会导致数据库中的TEXT列或varchar列，在每个表和列上都有一个特定的字符集编码。</p>
<h3 id="10-2-DBMgr-and-Encodings"><a href="#10-2-DBMgr-and-Encodings" class="headerlink" title="10.2. DBMgr and Encodings"></a><strong>10.2. DBMgr and Encodings</strong></h3><p>在考虑DBMgr和MySQL对字符编码的使用时，我们必须清楚使用字符集的所有区域。</p>
<h4 id="10-2-1-UNICODE-STRING-storage"><a href="#10-2-1-UNICODE-STRING-storage" class="headerlink" title="10.2.1. UNICODE_STRING storage"></a><strong>10.2.1. UNICODE_STRING storage</strong></h4><p>数据类型为UNICODE_STRING的实体属性存储在MySQL数据库中为TEXT或VARCHAR列取决于实体定义文件中是否指定了&lt;DatabaseLength&gt;。</p>
<p>为了在MySQL中更有效地存储数据，可以更改的存储类型UNICODE_STRING属性列使用dbMgr&#x2F;unicodeString&#x2F;characterSet3 bw.xml选项。修改此值的效果可以通过使用示例来最好地看到。</p>
<p>使用中文字符3 (unicode码位U+4E09)，我们可以从以下Python代码中看到，该字符在GB23124字符集中的字节表示比在UTF-8中更小。</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="built_in">repr</span>( three )</span><br><span class="line"><span class="string">u&#x27;\u4e09&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="built_in">repr</span>( three.encode( <span class="string">&quot;utf8&quot;</span> ) )</span><br><span class="line"><span class="string">&#x27;\xe4\xb8\x89&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="built_in">repr</span>( three.encode( <span class="string">&quot;gb2312&quot;</span> ) )</span><br><span class="line"><span class="string">&#x27;\xc8\xfd&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="10-2-1-1-Storing-invalid-characters"><a href="#10-2-1-1-Storing-invalid-characters" class="headerlink" title="10.2.1.1. Storing invalid characters"></a><strong>10.2.1.1. Storing invalid characters</strong></h4><p>因为可以修改MySQL中存储的UNICODE_STRING属性的字符集，所以理解MySQL如何处理无法编码到列字符集的数据的情况是很重要的。</p>
<p>为了说明这个例子，我们将从一个简单的Python示例开始。如果我们试图将()代码点U+4E04编码为ASCII字符编码，将引发如下异常:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print u&quot;\u4E04&quot;.encode( &quot;ascii&quot; )</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line"> File &quot;&lt;stdin&gt;&quot;, line 1 in ?</span><br><span class="line">UnicodeEncodeError: &#x27;ascii&#x27; codec can&#x27;t encode character u&#x27;\u4e04&#x27; in position</span><br><span class="line"> 0: ordinal not in range(128)</span><br></pre></td></tr></table></figure>

<p>不幸的是，这种行为没有在MySQL中复制，而是会无声地失败并插入？用字符代替无效的字符。由于这个失败是无声的，所以有可能通过有一个dbMgr&#x2F;unicodeString&#x2F;characterSet，它不能完全覆盖可能提供给MySQL的值的范围，因为会不知不觉地破坏数据库中的数据。这也是我们建议您将存储类型保留为UTF-8的原因之一，除非是绝对需要的。</p>
<h4 id="10-2-2-Sorting-search-results"><a href="#10-2-2-Sorting-search-results" class="headerlink" title="10.2.2. Sorting search results"></a><strong>10.2.2. Sorting search results</strong></h4><p>由于每种语言都有自己的关于一组值排序顺序的约定，MySQL也提供了在查询数据库时修改搜索结果行为的能力。用于定义排序顺序的规则称为排序规则。</p>
<p>MySQL中可用的每个字符集都有一个或多个排序规则。例如，MySQL中的UTF-8字符集有21种排序规则，可以通过运行以下命令看到:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW COLLATION LIKE &#x27;utf8_%&#x27;;</span><br></pre></td></tr></table></figure>

<p>这与您可能在BigWorld实体数据库上执行的自定义搜索结果有关,以及通过其&lt;Identifier&gt;属性查找实体而执行的内部服务器查找。</p>
<p>排序通常被称为以下其中之一:</p>
<ul>
<li>Case sensitive</li>
<li>Case insensitive</li>
<li>Binary</li>
</ul>
<p>根据你的游戏需求，你可能希望用dbMgr&#x2F;unicodeString&#x2F;collation8 bw.xml选项修改默认的UNICODE_STRING排序规则。</p>
<h2 id="11-Profiling"><a href="#11-Profiling" class="headerlink" title="11. Profiling"></a><strong>11. Profiling</strong></h2><p>分析服务器可以采用多种形式，这取决于您所处的开发阶段以及您试图隔离的问题类型。下面的列表是您可能希望概述的不同领域的简要概述。</p>
<ul>
<li><strong>Entities</strong></li>
<li><strong>Python script</strong></li>
<li><strong>Server Processes</strong></li>
<li><strong>Client Communication</strong></li>
<li><strong>Server Process Communication</strong></li>
</ul>
<h3 id="11-1-Profiling-Entities"><a href="#11-1-Profiling-Entities" class="headerlink" title="11.1. Profiling Entities"></a><strong>11.1. Profiling Entities</strong></h3><p>由于实体是BigWorld引擎所有组件使用的主要游戏对象，所以确保你的游戏实体尽可能有效地执行是很重要的。这包括:</p>
<ul>
<li>最小化持久化属性。</li>
<li>确保属性具有最小的适用数据类型(同时考虑长期扩展)。</li>
<li>确保属性具有分配的最适当的数据传播标志。</li>
<li>确保属性在适当的地方具有AoI。</li>
</ul>
<p>目前对实体大小进行分析的最佳机制是使用WebConsole过滤观察者视图来收集关于每个实体类型的属性影响的信息，再加上一个同行评审系统，以确保多人了解属性类型的影响。</p>
<h4 id="11-1-1-Persistent-Properties"><a href="#11-1-1-Persistent-Properties" class="headerlink" title="11.1.1. Persistent Properties"></a><strong>11.1.1. Persistent Properties</strong></h4><p>持久属性会导致CellApp、BaseApp和DBMgr之间的网络传输成本，以及在不使用辅助数据库时将负载放置到DBMgr上。通过最小化持久性属性的数量以及减少持久性属性的大小，您将在集群中获得长期的性能提升。</p>
<p>确定持久属性可以通过使用WebConsole过滤的监视页面来执行。</p>
<h4 id="11-1-2-Property-Data-Types"><a href="#11-1-2-Property-Data-Types" class="headerlink" title="11.1.2. Property Data Types"></a><strong>11.1.2. Property Data Types</strong></h4><p>选择可用于属性的尽可能小的数据类型将有助于降低集群中的网络负载。这包括所有属性，无论它们是否被持久化。</p>
<h4 id="11-1-3-Property-Data-Propagation"><a href="#11-1-3-Property-Data-Propagation" class="headerlink" title="11.1.3. Property Data Propagation"></a><strong>11.1.3. Property Data Propagation</strong></h4><p>通常，开发游戏时最简单的解决方案是将所有属性设置为CELL_PUBLIC或ALL_CLIENTS，因为它提供了属性的最大可视性。当在办公室的单机服务器上进行开发时，这种方法通常非常有效，因为单机服务器的负载不是很重，但是当执行负载测试和将游戏扩展到生产时，这可能会导致大问题。</p>
<p>理想情况下，在决定与属性一起使用的传播标志时，理想的最佳方法是使用面向对象的设计理念，即在对象(在本例中是实体)上调用方法，请求它为您执行工作，而不是您自己访问它的私有信息。</p>
<p>一个常见的例子是一个实体的运行状况或HP。该值可能由于随着时间的推移而损坏或恢复健康状况而不断变化，并且通常只与属性关联的实体直接相关。虽然其他实体可能对这个属性感兴趣，但他们只是短暂感兴趣，比如当他们在一起战斗时，或者实体已经组成了一组玩家。在这种情况下，将传播标志作为CELL_PRIVATE是有意义的，可以根据方法调用的需要请求。这减少了每次更新运行状况属性时通过广播所产生的网络流量，但仍然允许在需要时访问该属性。</p>
<h3 id="11-2-Python-Game-Script"><a href="#11-2-Python-Game-Script" class="headerlink" title="11.2. Python Game Script"></a><strong>11.2. Python Game Script</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">control_cluster.py pyprofile</span><br></pre></td></tr></table></figure>

<p>分析Python脚本通常是由于在脚本中识别出导致服务器进程问题的特定瓶颈而发生的，例如长时间滴答导致通过SIGQUIT信号终止进程。</p>
<p>剖析服务器端脚本使用pyprofile命令与control_cluster.py脚本一起执行。该命令只适用于运行Python脚本的服务器组件，如CellApp, BaseApp和DBMgr</p>
<h4 id="11-2-1-Understanding-the-output"><a href="#11-2-1-Understanding-the-output" class="headerlink" title="11.2.1. Understanding the output"></a><strong>11.2.1. Understanding the output</strong></h4><p>PyProfile将以内部时间和累计时间两种顺序输出查询的每个进程的结果。这两个结果集的输出格式是相同的。该概要文件旨在帮助识别游戏实现的最耗时的Python脚本方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">			6681 function calls in 0.106 CPU seconds</span><br><span class="line">Ordered by: internal time</span><br><span class="line">List reduced from 30 to 10 due to restriction &lt;10&gt;</span><br><span class="line"></span><br><span class="line">ncalls tottime percall cumtime percall filename:lineno(function)</span><br><span class="line">     643 0.019 0.000 0.020 0.000 Guard.py:446(moveToPosition)</span><br><span class="line">     102 0.016 0.000 0.016 0.000 Creature.py:476(moveTowardsPoint)</span><br><span class="line">     643 0.011 0.000 0.050 0.000 Guard.py:349(think)</span><br><span class="line">     354 0.010 0.000 0.036 0.000 Creature.py:332(think)</span><br><span class="line">     239 0.007 0.000 0.008 0.000 Guard.py:584(nextPatrolNode)</span><br><span class="line">     627 0.006 0.000 0.054 0.000 Guard.py:735(onMove)</span><br><span class="line">     202 0.006 0.000 0.006 0.000 Flock.py:166(onTimer)</span><br><span class="line">     404 0.005 0.000 0.019 0.000 Guard.py:653(doCamp)</span><br><span class="line">     101 0.004 0.000 0.004 0.000 DustDevil.py:26(onTimer)</span><br><span class="line">     239 0.004 0.000 0.019 0.000 Guard.py:639(doPatrol)</span><br></pre></td></tr></table></figure>

<p>生成这些报告的hotshot Python模块在引用相同信息时使用两个不同的名称。内部时间报告对应于下表中列出的总时间列以及其他列说明。</p>
<table>
<thead>
<tr>
<th>Column Name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>ncalls</td>
<td>此函数的调用总数。</td>
</tr>
<tr>
<td>tottime</td>
<td>仅在当前方法内部执行代码所花费的时间(以秒为单位)。从此方法调用的方法不包括在内。</td>
</tr>
<tr>
<td>percall</td>
<td>percall列直接引用它们左边的列，并表示它们所引用的配置文件时间的每个调用的平均时间。</td>
</tr>
<tr>
<td>cumtime</td>
<td>此方法执行所花费的时间(以秒为单位)，包括从该方法调用的任何其他方法的执行时间。</td>
</tr>
<tr>
<td>filename:lineno(function)</td>
<td>包含该配置文件所引用的函数的文件名和行数。</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ control_cluster.py help pyprofile</span><br></pre></td></tr></table></figure>

<h4 id="11-2-2-Increasing-Memory-Usage-x2F-Entity-Count"><a href="#11-2-2-Increasing-Memory-Usage-x2F-Entity-Count" class="headerlink" title="11.2.2. Increasing Memory Usage &#x2F; Entity Count"></a><strong>11.2.2. Increasing Memory Usage &#x2F; Entity Count</strong></h4><p>BigWorld中已禁用了自动垃圾收集，以避免Python引擎以意想不到的间隔使用大量CPU时间。为了允许删除Python对象，服务器进程只会在对象的引用计数达到0时删除对象。这种方法的副作用是不会删除具有循环引用的对象或被具有循环引用的对象引用的对象。</p>
<h3 id="11-3-Profiling-Server-Processes-C-Code"><a href="#11-3-Profiling-Server-Processes-C-Code" class="headerlink" title="11.3. Profiling Server Processes (C++ Code)"></a><strong>11.3. Profiling Server Processes (C++ Code)</strong></h3><p>当您的服务器出现负载峰值，而负载峰值不容易归因于某个特定的原因时，分析c++服务器代码有助于缩小花费时间最多的区域。BaseApp和CellApp都支持使用control_cluster.py命令cprofile。</p>
<p>(目前不详细研究)</p>
<h3 id="11-4-Client-Communication"><a href="#11-4-Client-Communication" class="headerlink" title="11.4. Client Communication"></a><strong>11.4. Client Communication</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">control_cluster.py eventprofile</span><br></pre></td></tr></table></figure>

<p>服务器将非易失性数据和易失性数据都发送给客户机。易失性数据是位置和姿态更新的形式，而非易失性数据包括实体的属性更新和对该实体的客户端方法调用，发送给任何可以看到该实体的玩家。通过分析非易失性数据，可以了解哪些方法和属性更新的吞吐量特别高，从而有效地优化实体脚本的网络影响。</p>
<p>(目前不详细研究)</p>
<h3 id="11-5-Server-Communication"><a href="#11-5-Server-Communication" class="headerlink" title="11.5. Server Communication"></a><strong>11.5. Server Communication</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">control_cluster.py mercuryprofile</span><br></pre></td></tr></table></figure>

<p>服务器通信主要通过Mercury接口进行。这些可以在监视树路径nub&#x2F;interfacesByName下的服务器进程中看到。</p>
<p> mercuryprofile的输出提供了一个结果压缩表，可以在运行配置文件时使用选项根据需要对其进行排序。下面提供了一个CellApp实例的输出示例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cellapp01 - Internal Nub</span><br><span class="line"> id name br mr max br aml abps amps</span><br><span class="line"> 0 DBInterfaceBirth 8 1 8 8.0 0.0 0.0</span><br><span class="line"> 1 addCell 92 4 23 23.0 0.0 0.0</span><br><span class="line"> 2 startup 8 1 8 8.0 0.0 0.0</span><br><span class="line"> 3 setGameTime 4 1 4 4.0 0.0 0.0</span><br><span class="line"> 14 cellAppMgrInfo 380184 95046 4 4.0 40.0 10.0</span><br><span class="line"> 18 updateGeometry 646272 38016 17 17.0 68.0 4.0</span><br><span class="line"> 19 spaceGeometryLoaded 78 4 22 19.5 0.0 0.0</span><br><span class="line"> 21 createEntity 270 4 70 67.5 0.0 0.0</span><br><span class="line"> 22 createEntityNearEntity 63181 466 295 135.6 0.0 0.0</span><br><span class="line"> 35 writeToDBRequest 1536 384 4 4.0 0.1 0.0</span><br><span class="line"> 50 runScriptMethod 49110 4821 190 10.2 -5.0 -0.5</span><br><span class="line">255 Reply 10892 165 9600 66.0 -0.0 -0.0</span><br></pre></td></tr></table></figure>

<p>(目前不详细研究)</p>
<h2 id="12-Proxies-and-Players"><a href="#12-Proxies-and-Players" class="headerlink" title="12. Proxies and Players"></a><strong>12. Proxies and Players</strong></h2><h3 id="12-1-Proxies"><a href="#12-1-Proxies" class="headerlink" title="12.1. Proxies"></a><strong>12.1. Proxies</strong></h3><p>在BaseApp上的BigWorld.Proxy拓展了BigWorld.Base,为了支持受玩家控制的实体。</p>
<p>通过从BigWorld.proxy派生出一个实体。你可以在服务器上实现玩家角色、他们的帐户和任何其他相关的玩家控制的对象。</p>
<p>来自BigWorld的实体。每当客户端登录到服务器时，都会从数据库创建代理。关于BigWorld如何决定加载哪个代理的详细信息。以这种方式创建的具有名为password属性的代理，将该属性的值设置为登录密码。</p>
<p> 一个BigWorld.Peoxy的实例既不需要单元实体，也不需要客户端实体。可以使用BigWorld.creeteBase方法创建代理实体，就像其他实体一样（详情见“Entity Instantiation on the BaseApp” ）。</p>
<p>与其他基本实体一样，可以从数据库中保存和加载代理实体。最初，这些重新加载的代理实体将在没有附加客户端的情况下创建。现有的代理可以稍后将其客户端移交给重新加载的代理，在这种情况下，重新加载的代理将处理客户端连接。</p>
<p>要将客户机的控制权从一个代理传递给另一个代理，可以使用giveClientTo方法，如下面的示例:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clientControlledProxy.giveClientTo( nonClientControlledProxy)</span><br></pre></td></tr></table></figure>

<p>每当客户端在代理之间移动，或者客户端所连接的代理的单元实体被销毁时，客户端会收到一个onEntitiesReset的调用，以清除其当前的世界知识。这将有效地中断所有游戏交流，并迫使客户端进行刷新。如果只有单元实体被销毁，那么客户机关于其代理的知识将被保留。</p>
<p>如果由于目标代理的问题导致giveClientTo没有成功，onGiveClientToFailure将在源代理上调用。</p>
<p><img src="/image%5Cbigworld%5C06_17.png" alt="06_17"></p>
<h3 id="12-2-Witnesses"><a href="#12-2-Witnesses" class="headerlink" title="12.2. Witnesses"></a><strong>12.2. Witnesses</strong></h3><p>每当带有附加客户端的代理具有相应的单元实体时，一个名为witness的额外对象就会附加到单元实体。</p>
<p>该对象管理实体的AoI，并将更新发送给代理，代理将更新转发给客户端。</p>
<p>这些更新包含大量与游戏相关的信息，例如:</p>
<ul>
<li>实体的位置更新。</li>
<li>实体属性更新。</li>
<li>方法调用。</li>
<li>空间数据更改。</li>
<li>实体进入和离开AoI的通知。</li>
</ul>
<h3 id="12-3-Entity-Control"><a href="#12-3-Entity-Control" class="headerlink" title="12.3. Entity Control"></a><strong>12.3. Entity Control</strong></h3><p>默认情况下，每个单元实体都被认为是由服务器控制的。当一个实体合并一个wintess对象时，它被认为是由附加到相应代理的客户端控制的。</p>
<p>但是，可以使用实体属性 .controlledby显式地分配和查询实体的控制权。此属性可以设置为None，以指示服务器控件，或者设置为BaseEntityMailBox，以指示由连接到该代理的客户端进行的控制。</p>
<p>在这种情况下，控制意味着对实体的位置和方向的所有权和责任。客户(和代理)被告知他们可以控制的实体集的更改。代理可以通过它们的属性区读取这个集合。</p>
<h3 id="12-4-Physics-Correction"><a href="#12-4-Physics-Correction" class="headerlink" title="12.4. Physics Correction"></a><strong>12.4. Physics Correction</strong></h3><p>当实体由客户端控制时，将属性Entity.topSpeed设置为大于零的值可以启用物理检查。默认情况下，top速度允许在所有3轴上进行物理检查，但这可能并不总是合适的。例如，如果你的游戏环境的重力使y轴加速，导致最高速度超过允许的最大X&#x2F;Z轴最高速度。为了适应这一点，有一个名为Entity.topSpeedY的次要属性，当设置为值大于零时优先。只有当topSpeedY和top都大于0时才使用topSpeedY。</p>
<p>通过以下方式验证实体移动：</p>
<ul>
<li><p><strong>Speed</strong></p>
</li>
<li><p><strong>Geometry of the scene</strong></p>
</li>
<li><p><strong>Custom physics validator</strong></p>
</li>
</ul>
<h4 id="12-4-1-Avoiding-Y-axis-rubber-banding"><a href="#12-4-1-Avoiding-Y-axis-rubber-banding" class="headerlink" title="12.4.1. Avoiding Y-axis rubber-banding."></a><strong>12.4.1. Avoiding Y-axis rubber-banding.</strong></h4><p>由于物理验证发生的方式，如果超过了最高速度，服务器将强制更新客户端最后一个已知有效位置的位置。然而，这有一个不幸的副作用，即产生一个实体，如果在y轴上超过了最高速度，它就不会掉落。将topSpeedY设置为高于topSpeed在这种情况下会有所帮助，但最终，由于长时间下落时重力的加速度，y速度将大于topSpeedY。</p>
<p>为了解决这个问题，建议编写一个自定义物理验证器，同时为topSpeedY设置一个大的值。然后，自定义物理验证器可以执行自己的验证，并在返回false之前用递减的y轴位置更新实体位置，然后将更新的位置强制发送给客户端。</p>
<h2 id="13-Entities-and-the-Universe"><a href="#13-Entities-and-the-Universe" class="headerlink" title="13. Entities and the Universe"></a><strong>13. Entities and the Universe</strong></h2><p>BigWorld中的实体包含在游戏世界中。宇宙由空间组成，空间由单元组成。</p>
<p>每个空格可以包含:</p>
<ul>
<li>空间数据，用于整个空间必须可用的信息。</li>
<li>几何定义实体可以移动的位置。</li>
<li>一天中的时间，客户使用它来确定白天&#x2F;夜晚的周期。</li>
</ul>
<h3 id="13-1-Multiple-Spaces"><a href="#13-1-Multiple-Spaces" class="headerlink" title="13.1. Multiple Spaces"></a><strong>13.1. Multiple Spaces</strong></h3><p>BigWorld支持在一个宇宙中拥有多个独立的几何空间。每个空间都可以有一组不同的几何体映射到其中，以及一组不同的实体存在于其中。每个CellApp可以处理不同空间中的多个细胞。</p>
<p>让管理变得更简单的一种常见设计技巧是创建实体空间(通常根据空间的用途命名，如任务或任务)。这样的实体将在一个新空间中创建，然后负责配置该空间以便开始游戏。然后玩家就可以传送到新的空间去探索它，玩他们的任务等等。</p>
<ul>
<li><p><strong>Base script</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Space</span>( BigWorld.Base ):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"> self </span>):</span><br><span class="line">        <span class="comment"># create our cell entity in a new space. self.onGetCell() will be</span></span><br><span class="line">        <span class="comment"># called when the cell entity is created.</span></span><br><span class="line">        self.createInNewSpace()</span><br><span class="line"> 	<span class="keyword">def</span> <span class="title function_">onGetCell</span>(<span class="params"> self </span>):</span><br><span class="line">        <span class="comment"># create any predefined entities in the space</span></span><br><span class="line">        <span class="comment"># may want to use ResMgr to load details from an XML file</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># we want to make sure that each entity&#x27;s createCellEntity()</span></span><br><span class="line">        <span class="comment"># method is passed the appropriate cell mailbox (this entity&#x27;s</span></span><br><span class="line">        <span class="comment"># cell mailbox) so that it is created in the correct space</span></span><br><span class="line">        <span class="comment"># for example:</span></span><br><span class="line"> 		BigWorld.createBase( <span class="string">&quot;Monster&quot;</span>, arguments, createOnCell=self.cell )</span><br></pre></td></tr></table></figure>

<p>Example file <em>&lt;res&gt;</em>&#x2F;scripts&#x2F;base&#x2F;Space.py</p>
</li>
<li><p><strong>Cell script</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Space</span>( BigWorld.Entity ):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"> self </span>):</span><br><span class="line">        <span class="comment"># Register our mailbox for getting the callback when the space</span></span><br><span class="line">        <span class="comment"># geometry finishes loading. You can choose any arbitrary string </span></span><br><span class="line">        <span class="comment"># as the key so long you can find this entry again.</span></span><br><span class="line">        BigWorld.cellAppData[ <span class="string">&#x27;SpaceLoader:&#x27;</span> + <span class="built_in">str</span>(self.spaceID) ] = self</span><br><span class="line">        <span class="comment"># Add the geometry mapping. This maps the set of .chunk files we </span></span><br><span class="line">        <span class="comment"># want into the space. BWPersonality.onAllSpaceGeometryLoaded will</span></span><br><span class="line">        <span class="comment"># be called when BigWorld finished loading the geometry.</span></span><br><span class="line">        BigWorld.addSpaceGeometryMapping( self.spaceID, <span class="literal">None</span>, </span><br><span class="line">                                         <span class="string">&quot;geometry/path&quot;</span> )</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">onGeometryLoaded</span>(<span class="params"> self </span>):</span><br><span class="line">        <span class="comment"># we can now also teleport in any additional entities that already</span></span><br><span class="line">        <span class="comment"># existed in the world (we&#x27;d probably store a mailbox somewhere in</span></span><br><span class="line">        <span class="comment"># the construction sequence to make this possible)</span></span><br><span class="line">        <span class="comment"># see the cell entity teleport() method for details</span></span><br><span class="line">        playerMB.teleport( self, position, direction )</span><br></pre></td></tr></table></figure>

<p>Example file <em>&lt;res&gt;</em>&#x2F;scripts&#x2F;cell&#x2F;Space.py</p>
</li>
<li><p><strong>Cell personality script</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">onAllSpaceGeometryLoaded</span>(<span class="params"> spaceID, isBootstrap, lastPath </span>):</span><br><span class="line">    <span class="keyword">if</span> (isBootstrap):</span><br><span class="line">        <span class="comment"># Find the registered loader and tell it to load the entities into</span></span><br><span class="line">        <span class="comment"># the space.</span></span><br><span class="line">        loaderKey = <span class="string">&#x27;SpaceLoader:&#x27;</span> + <span class="built_in">str</span>(spaceID)</span><br><span class="line">	<span class="keyword">if</span> BigWorld.cellAppData.has_key( loaderKey ):</span><br><span class="line">        BigWorld.cellAppData[ loaderKey ].onGeometryLoaded();</span><br></pre></td></tr></table></figure>

<p>Example file <em>&lt;res&gt;</em>&#x2F;scripts&#x2F;cell&#x2F;BWPersonality.py</p>
</li>
</ul>
<p>为了创建这个实体，下面的代码应该是这样写的:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newSpace = BigWorld.createBaseAnywhere( <span class="string">&quot;Space&quot;</span>, ... )</span><br></pre></td></tr></table></figure>

<p>注意，这段代码中有四个关键步骤:</p>
<ol>
<li>在一个新空间中创建单元格实体(在__init__方法中)。</li>
<li>创建单元格实体时，在空间包含的任何几何图形中进行映射。</li>
<li>创建世界中需要存在的任何实体。</li>
<li>当空间几何体被加载时，将任何需要的玩家带到空间中。</li>
</ol>
<p>很可能会有针对所需空间风格的管理代码(这些代码很大程度上取决于你的游戏需求)。根据实体实例化需求，还可以在单元和基础之间执行各种步骤。</p>
<p>当一个空间中的所有实体被移除时，这个空间将被摧毁。或者，空间中的任何实体都可以调用entity . destroyspace方法来销毁该实体所在的当前空间。空间中的每个实体在实际销毁之前都会调用它的onSpaceGone方法。</p>
<h4 id="13-1-1-Spaces-Pool"><a href="#13-1-1-Spaces-Pool" class="headerlink" title="13.1.1. Spaces Pool"></a><strong>13.1.1. Spaces Pool</strong></h4><p>当你的游戏需要一个空间的多个实例(例如任务空间)时，在游戏启动时创建一个可重复使用的空间实例池是有利的。</p>
<p>这一机制消除了之后需要根据需求加载区块的需求，当玩家请求进入一个空间时，将从池中选择一个实例。当玩家离开场地后，你可以将场地移回池中，以便以后使用。这种机制可以大大加快玩家在服务器上的游戏加载速度。</p>
<h3 id="13-2-Navigation-System"><a href="#13-2-Navigation-System" class="headerlink" title="13.2. Navigation System"></a><strong>13.2. Navigation System</strong></h3><p>以下各小节描述导航系统的功能</p>
<h4 id="13-2-1-Key-Features"><a href="#13-2-1-Key-Features" class="headerlink" title="13.2.1. Key Features"></a><strong>13.2.1. Key Features</strong></h4><p>该系统的主要特点是:</p>
<ul>
<li>室内和室外块导航</li>
<li>室内外无缝切换</li>
<li>导航多边图的动态加载</li>
<li>路径缓存，提高效率</li>
</ul>
<h4 id="13-2-2-Navpoly-Data-Format"><a href="#13-2-2-Navpoly-Data-Format" class="headerlink" title="13.2.2. Navpoly Data Format"></a><strong>13.2.2. Navpoly Data Format</strong></h4><p>世界被分成了许多块。每个chunk是一个凸包，由一个chunk ID字符串唯一标识，例如0000ffffo。</p>
<p>为了导航的目的，每个块被分解成一组凸多边形棱镜。这种棱镜被称为navpoly，并由单个块唯一的整数navpolyID标识。一组导航多边区域称为导航网格。</p>
<p>navpoly上的每条边都可以与相邻区域的边共享。这意味着这两个区域之间的移动是允许的。或者，一条边可以被标记为与不同的块相邻。</p>
<p><img src="E:\markDown\image\bigworld\06_18.png" alt="06_18"></p>
<p>navpoly也有相应的高度。这是navpoly区域的最大高度，这样客户端可以从这个Y值做一个下降测试，并总是在navpoly的底部结束。</p>
<p>navpoly中的顶点按顺时针顺序定义，并将其XZ坐标存储在XY字段中。</p>
<p>第三个坐标用于存储这个顶点和下一个顶点之间形成的边的邻接信息。这第三个坐标的值要么是邻近navpoly的navpoly ID，要么是障碍物类型的编码。块边界上的边由相邻块ID的单独标记表示。在这种情况下，不使用第三个顶点坐标。</p>
<h4 id="13-2-3-Script-Interface"><a href="#13-2-3-Script-Interface" class="headerlink" title="13.2.3. Script Interface"></a><strong>13.2.3. Script Interface</strong></h4><p>当一个实体想要导航到一个位置时，它使用Python实体。navigateStep脚本方法，如下所示:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.controllerID = self.navigateStep( destination, velocity, maxMoveDistance,</span><br><span class="line"> maxSearchDistance, faceMovement, girth, userData )</span><br></pre></td></tr></table></figure>

<ul>
<li>**destination ** - 目标位置。</li>
<li><strong>velocity</strong> ‐ 移动速度，单位是m&#x2F;s。</li>
<li><strong>maxMoveDistance</strong> ‐ 在触发onMove回调之前移动的最大距离。</li>
<li><strong>maxSearchDistance</strong> ‐ 搜索路径的最大距离。</li>
<li><strong>faceMovement</strong> ‐ 实体是否应该面向运动方向。</li>
<li><strong>girth</strong> ‐ 实体可以通过的最小宽度。</li>
<li><strong>userData</strong> ‐ 传递给导航回调的整数值。</li>
</ul>
<p>如果没有到目的地的有效路径，那么navigateStep将失败，并抛出一个脚本异常。否则，它将返回一个控制器ID。这是一个唯一的ID，可以用来取消移动请求，像这样:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.cancel( self.controllerID )</span><br></pre></td></tr></table></figure>

<p>在路径上的每个waypoint，实体的onMove方法将被调用，controllerID和userData作为参数。继续路径，必须再次调用Entity.navigateStep以将控制器推进到下一步，否则实体将停止。如果没有再次调用navigateStep，或者再次调用navigateStep失败，所有与控制器相关的资源将被释放，不需要通过调用Entity.cancel来释放它们。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">onMove</span>(<span class="params"> self, controllerID, userData </span>):</span><br></pre></td></tr></table></figure>

<p>如果onMove通知方法调用Entity.navigateStep超过100次，而没有以指定的速度移动一次移动所需的距离，则调用onMove失败通知方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">onMoveFailure</span>(<span class="params"> self, controllerID, userData </span>):</span><br></pre></td></tr></table></figure>

<h4 id="13-2-4-Navigate"><a href="#13-2-4-Navigate" class="headerlink" title="13.2.4. Navigate"></a><strong>13.2.4. Navigate</strong></h4><p>当调用Entity.navigateStep脚本方法时，服务器将执行以下步骤:</p>
<ol>
<li>从源位置解析ChunkID和WaypointID。</li>
<li>从目标位置解析ChunkID和WaypointID。</li>
<li>如果ChunkIDs不同，那么在块级别上执行一个图搜索。否则，如果waypointid不同，则在navpoly级别上执行一个图搜索。如果这两个测试都失败，则沿直线移动到指定位置。</li>
</ol>
<h4 id="13-2-5-Graph-Searches"><a href="#13-2-5-Graph-Searches" class="headerlink" title="13.2.5. Graph Searches"></a><strong>13.2.5. Graph Searches</strong></h4><p>A<em>搜索用于块图搜索和navpoly图搜索。ChunkState和WaypointState类都实现了A</em>搜索所需的接口，并分别用于搜索块图和navpoly图。</p>
<p>对于块图搜索，距离是基于实体进入和退出块的近似点来计算的。</p>
<p>导航多边形图上的距离是根据通过导航多边形的实际路径计算的。</p>
<p>给定一个源位置在navpoly内部，目标位置在navpoly外部，算法如下:</p>
<ul>
<li>找到从源到目的地的直线与多边形边界相交的点。</li>
<li>如果这个点在有邻接的边上，直接移动到交点。</li>
<li>否则，移动到有邻接关系的顶点，以便使此路径和期望路径之间的夹角最小化。</li>
</ul>
<p>这是一种简单的方法，并不总是最优的，但在大多数情况下都能正常工作。</p>
<p>PathCache类被用作执行块和navpoly图搜索的包装器。它为每个实体缓存一条路径，并在该路径中存储当前跳索引。每次图搜索发生时，PathCache检查目标是否与缓存的目标相同。如果是，则返回路径中的下一个状态，并在适当的情况下增加跳索引。</p>
<h4 id="13-2-6-Auto-Generation-of-Navpoly-Regions"><a href="#13-2-6-Auto-Generation-of-Navpoly-Regions" class="headerlink" title="13.2.6. Auto-Generation of Navpoly Regions"></a><strong>13.2.6. Auto-Generation of Navpoly Regions</strong></h4><p>BigWorld提供了两种不同的工具来生成navpoly区域:NavGen(用于生成NavGen网格)和Offline Processor(用于生成Recast网格)。每个空间将被配置为使用这些生成器之一。两者都生成了可以被服务器端导航使用的导航网格，并在本节的后面会有更详细的解释。</p>
<p>这些工具根据区块文件中的地形和其他几何信息生成凸导航多边形棱镜（命名： <em>&lt;res&gt;</em>&#x2F;spaces&#x2F;&lt;space&gt;&#x2F;<em><chunk_ID></em>.chunk）</p>
<p>然后将结果写入二进制.cdata文件</p>
<p>文件bigworld&#x2F;res&#x2F;helpers&#x2F;girths.xml说明了不同的实体配置文件，例如它们的大小和其他物理属性。这由周长值表示。可以指定多个周长，在这种情况下，将生成和维护多个导航网格。对于每个周长，可以设置不同的物理参数(例如，有一个用于实体高度的洪水填充参数)。对于类人实体来说，2.0米是不错的默认设置。</p>
<p>navmesh的生成方法由文件space.setting中的navmeshGenerator的值决定。。修改这个值不会自动导致块被脏，所以如果一个navmesh已经存在，那么下一代将不得不在覆盖模式下运行。</p>
<h5 id="13-2-6-1-Configuring-Girth-Information-for-Navmesh-Generation"><a href="#13-2-6-1-Configuring-Girth-Information-for-Navmesh-Generation" class="headerlink" title="13.2.6.1. Configuring Girth Information for Navmesh Generation"></a><strong>13.2.6.1. Configuring Girth Information for Navmesh Generation</strong></h5><h5 id="13-2-6-2-Generating-a-NavGen-Mesh-The-NavGen-Tool"><a href="#13-2-6-2-Generating-a-NavGen-Mesh-The-NavGen-Tool" class="headerlink" title="13.2.6.2. Generating a NavGen Mesh: The NavGen Tool"></a><strong>13.2.6.2. Generating a NavGen Mesh: The NavGen Tool</strong></h5><h5 id="13-2-6-3-Generating-a-Recast-Mesh-The-Offline-Processor-Tool"><a href="#13-2-6-3-Generating-a-Recast-Mesh-The-Offline-Processor-Tool" class="headerlink" title="13.2.6.3. Generating a Recast Mesh: The Offline Processor Tool"></a><strong>13.2.6.3. Generating a Recast Mesh: The Offline Processor Tool</strong></h5><p>（以上几节此处不作过多介绍）</p>
<h3 id="13-3-Time"><a href="#13-3-Time" class="headerlink" title="13.3. Time"></a><strong>13.3. Time</strong></h3><p>我们已经看到实体是如何定义游戏不同部分的行为的。游戏玩法涉及到随着时间的推移而改变实体的状态，所以很重要的一点是要很好地理解BigWorld环境中如何管理时间。</p>
<p>在BigWorld中讨论时间时，思考不同类型的时间会有所帮助。这些类型将在下面的小节中讨论。</p>
<h4 id="13-3-1-Real-Time"><a href="#13-3-1-Real-Time" class="headerlink" title="13.3.1. Real Time"></a><strong>13.3.1. Real Time</strong></h4><p>“真实时间”只是现实世界时钟上的时间。实时时间被用作BigWorld中定义其他类型时间的基础。</p>
<h4 id="13-3-2-Server-Time"><a href="#13-3-2-Server-Time" class="headerlink" title="13.3.2. Server Time"></a><strong>13.3.2. Server Time</strong></h4><p>在服务器上，基于&lt;res&gt;&#x2F;server&#x2F;bw.xml中的&lt;gameUpdateHertz&gt;配置选项，游戏时间以离散的单位递增</p>
<p>服务器保持一个整数计数器，该计数器以这个速度递增，在服务器启动时其初始值为0。</p>
<p>计算服务器时间(以秒为单位)的公式如下:</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serverTime = serverTimestamp / gameUpdateHertz</span><br></pre></td></tr></table></figure>

<p>这大约是:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serverTime ~= currentRealTime - serverStartRealTime</span><br></pre></td></tr></table></figure>

<p>每个客户端机器都会计算一个时间的同步版本，可以通过脚本方法BigWorld.serverTime获得。</p>
<h4 id="13-3-3-Game-Time"><a href="#13-3-3-Game-Time" class="headerlink" title="13.3.3. Game Time"></a><strong>13.3.3. Game Time</strong></h4><p>游戏时间是玩家在游戏世界中感知的时间。</p>
<p>大型在线持久化游戏通常会在虚拟世界中设置虚拟天数和虚拟月份。例如，你可能希望在Real Time中每小时运行一个游戏世界小时。为了支持这一点，BigWorld有一个标准的空间数据块，用于计算一天中的时间</p>
<p>该空间数据记录了以下数字:</p>
<ul>
<li><strong>initialTimeOfDay</strong> - 游戏服务器启动时间。</li>
<li><strong>gameSecondsPerSecond</strong> - 转换系数，从服务器时间更新速率到实时。</li>
</ul>
<p>它们一起被用来定义游戏时间:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gameTimeOfDay = ( serverTime - initialTimeOfDay ) * gameSecondsPerSecond</span><br></pre></td></tr></table></figure>

<p>为了修改整个空间的游戏时间，可以使用CellApp的Python方法叫BigWorld.setSpaceTimeOfDay。该方法接受以下三个参数:</p>
<ul>
<li><strong>spaceID</strong> - 应该被影响的空间的ID。</li>
<li><strong>initialTimeOfDay</strong> - 服务器启动时的一天时间。</li>
<li><strong>gameSecondsPerSecond</strong> - 每个实时秒中经过的游戏秒数。</li>
</ul>
<p>要根据时间只修改客户端可视化，请参考client Python方法BigWorld.spaceTimeOfDay。</p>
<h3 id="13-4-Initialisation-Personality-script-eload-and-runscript"><a href="#13-4-Initialisation-Personality-script-eload-and-runscript" class="headerlink" title="13.4. Initialisation: Personality script, eload, and runscript"></a><strong>13.4. Initialisation: Personality script, eload, and runscript</strong></h3><p>默认情况下，当服务器启动时，会创建单个默认空间，不包含实体和几何图形。</p>
<p>为了让游戏变得有趣，脚本必须填充这个空间，并可能创造其他空间。当服务器运行时，您可能希望运行专业脚本来更改元素的属性。这些任务可以使用个性脚本和两个服务器端工具:加载和runscript来完成。</p>
<p>人格脚本可以包含一个Python函数，在每个BaseApp上运行一个可用的CellApp后立即执行。通过这种方式，可以保证您可以从脚本创建单元实体和基本实体。</p>
<p>要执行的脚本在文件&lt;res&gt;&#x2F;server&#x2F;bw.xml中指定，如下所示:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">personality</span>&gt;</span> personalityscript <span class="tag">&lt;/<span class="name">personality</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对应的文件(在上面的例子中是personalityscript.py)被放置在&lt;res&gt;&#x2F;scripts&#x2F;base目录中，将在适当的时间执行。</p>
<p>如果没有定义个性脚本，则使用默认文件名BWPersonality.py。</p>
<p>个性脚本中的onAppReady方法由BaseApp调用。方法接收一个布尔参数，其值定义如下:</p>
<ul>
<li>true - 如果BaseApp是服务器集群中第一个准备好的。</li>
<li>false - 如果BaseApp不是集群中的第一个准备好的。</li>
</ul>
<p>人格脚本可以调用任何BigWorld模块方法，建议执行以下操作：</p>
<ul>
<li>通过从单元格实体调用addSpaceGeometryMapping函数向空间添加几何图形。</li>
<li>通过调用cell实体中的setSpaceTimeOfDay方法来初始化游戏时间。</li>
<li>初始化任何自定义空间数据。</li>
<li>通过创建实体来填充世界。</li>
</ul>
<p>在执行个性脚本函数的过程中，BaseApp无法响应来自其他服务器组件的消息。耗时的个性脚本可能会使服务器集群的BaseApp超时。建议及时扩展实体创建，以便顺利、稳健地启动。</p>
<p>下面演示了这个示例，其中包含个性、基础和客户端脚本的代码</p>
<ul>
<li><p><strong>In the personality script:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">onAppReady</span>(<span class="params"> <span class="built_in">bool</span> isBootStrap </span>):</span><br><span class="line">    <span class="keyword">if</span> isBootStrap:</span><br><span class="line">        BigWorld.createBase( <span class="string">&quot;SpaceManager&quot;</span>, &#123;&#125;, &#123;&#125; )</span><br><span class="line">        BigWorld.createBase( <span class="string">&quot;EntityLoaderManager&quot;</span>, &#123;&#125;, &#123;&#125; )</span><br><span class="line">    <span class="comment"># every BaseApp needs an EntityLoader</span></span><br><span class="line">    BigWorld.createBase( <span class="string">&quot;EntityLoader&quot;</span>, &#123;&#125;, &#123;&#125; )</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>Example personality script <em>&lt;res&gt;</em>&#x2F;scripts&#x2F;base&#x2F;<personality_script_name>.py</p>
</li>
<li><p><strong>On the BaseApp:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SpaceManager</span>( BigWorld.Base ):</span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"> self </span>):</span><br><span class="line">     <span class="comment"># create the cell entity in a new space</span></span><br><span class="line">     self.createInNewSpace( (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>), (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>), <span class="literal">None</span> )</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EntityLoaderManager</span>( BigWorld.Base ):</span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"> self </span>):</span><br><span class="line">         <span class="comment"># register globally under a well-known name (ELM for example)</span></span><br><span class="line">         <span class="comment"># so the EntityLoaders can register with me</span></span><br><span class="line">         self.registerGlobally( <span class="string">&quot;ELM&quot;</span>, onRegister )</span><br><span class="line">         <span class="comment"># add a timer that calls back every 1 second.</span></span><br><span class="line">         <span class="comment"># User data is 999 (only for identification purpose)</span></span><br><span class="line">         self.addTimer( <span class="number">1</span>, <span class="number">1</span>, <span class="number">999</span> )</span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">onRegister</span>(<span class="params"> self, succeeded </span>):</span><br><span class="line">         <span class="comment"># callback from registerGlobally(). Argument succeeded should always</span></span><br><span class="line">         <span class="comment"># be True there is only one EntityLoaderManager in whole system</span></span><br><span class="line">         <span class="keyword">if</span> <span class="keyword">not</span> succeeded:</span><br><span class="line">             <span class="comment"># should not be possible, try re-register</span></span><br><span class="line">             self.registerGlobally( <span class="string">&quot;ELM&quot;</span>, onRegister )</span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">registerLoader</span>(<span class="params"> self, entityLoader </span>):</span><br><span class="line">         <span class="comment"># append the mailbox of an entityLoader into our list</span></span><br><span class="line">         <span class="comment"># might have to verify it is not re-registered though</span></span><br><span class="line">         self.entityLoaderList.append( entityLoader )</span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">onTimer</span>(<span class="params"> self, timerId, userData </span>):</span><br><span class="line">         <span class="keyword">if</span> userData == <span class="number">999</span>:</span><br><span class="line">             <span class="comment"># distribute entity creation tasks to every registered</span></span><br><span class="line">             <span class="comment"># EntityLoader in a load spreading manner</span></span><br><span class="line">             <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>( <span class="built_in">len</span>( self.entityLoaderList ) ):</span><br><span class="line">             <span class="comment"># prepare the argument for entity creation</span></span><br><span class="line">             args = ...</span><br><span class="line">             self.entityLoaderList[i].createEntities( args )</span><br><span class="line">         <span class="keyword">if</span> allJobFinished:</span><br><span class="line">             <span class="comment"># remove the timer if not required any more</span></span><br><span class="line">             delTimer( timerId )</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EntityLoader</span>( BigWorld.Base ):</span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"> self </span>):</span><br><span class="line">         self.registerWithELM()</span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">registerWithELM</span>():</span><br><span class="line">         <span class="keyword">if</span> BigWorld.globalBases.has_key( <span class="string">&quot;ELM&quot;</span> ):</span><br><span class="line">             <span class="comment"># if EntityLoaderManager is available register with it now</span></span><br><span class="line">             elm = BigWorld.globalBases[<span class="string">&quot;ELM&quot;</span>]</span><br><span class="line">             elm.registerLoader( self )</span><br><span class="line">         <span class="keyword">else</span>:</span><br><span class="line">             <span class="comment"># otherwise wait a bit</span></span><br><span class="line">             self.addTimer( <span class="number">1</span> )</span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">onTimer</span>(<span class="params"> self, timerId, userData </span>):</span><br><span class="line">         <span class="comment"># retry registering</span></span><br><span class="line">         self.registerWithELM()</span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">createEntities</span>(<span class="params"> self, args </span>):</span><br><span class="line"> 	<span class="comment"># create the entities according to the arguments</span></span><br></pre></td></tr></table></figure>

<p>Example file <em>&lt;res&gt;</em>&#x2F;scripts&#x2F;base&#x2F;SpaceManager.py</p>
</li>
<li><p><strong>On the CellApp:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SpaceManager</span>( BigWorld.Entity ):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"> self </span>):</span><br><span class="line">        <span class="comment"># add the geometry mapping</span></span><br><span class="line">        <span class="comment"># this maps the set of .chunk files we want into the space</span></span><br><span class="line">        BigWorld.addSpaceGeometryMapping( self.spaceID, <span class="literal">None</span>, <span class="string">&quot;geometry/path&quot;</span> )</span><br></pre></td></tr></table></figure>

<p>Example file <em>&lt;res&gt;</em>&#x2F;scripts&#x2F;cell&#x2F;SpaceManager.py</p>
</li>
</ul>
<h3 id="13-5-Global-Data"><a href="#13-5-Global-Data" class="headerlink" title="13.5. Global Data"></a><strong>13.5. Global Data</strong></h3><p>BigWorld提供了几种将全局数据分发到其组件的机制。这些机制中的大多数还在修改特定全局数据时提供回调，从而有效地将它们转化为全局事件分布机制。</p>
<p>与大多数编程环境一样，应该谨慎对待全局数据，因为它们给代码维护带来了挑战。在像BigWorld这样的分布式系统中，globals应该更少地使用，因为数据分布对性能的影响，以及竞争条件的风险。</p>
<h4 id="13-5-1-globalData-baseAppData-and-cellAppData"><a href="#13-5-1-globalData-baseAppData-and-cellAppData" class="headerlink" title="13.5.1. globalData, baseAppData and cellAppData"></a><strong>13.5.1.</strong> <strong>globalData</strong>, baseAppData <strong>and</strong> <strong>cellAppData</strong></h4><p>BigWorld提供了三个在BigWorld组件中复制的Python字典。它们的复制范围不同:</p>
<ul>
<li><strong>BigWorld.globalData</strong> - 在所有的BaseApps和CellApps上复制。</li>
<li><strong>BigWorld.baseAppData</strong> - 在所有BaseApps上复制。</li>
<li><strong>BigWorld.cellAppData</strong> - 在所有的CellApps上复制。</li>
</ul>
<p>键和值必须是可pickle的Python对象。值类型可以是任何可pickle的Python对象。如果该值是一个BigWorld实体，那么它将被转换为该实体当前不驻留的组件上的邮箱。</p>
<p>当字典中的条目被修改时，会调用以下回调函数:</p>
<table>
<thead>
<tr>
<th>Global</th>
<th>Add or modified</th>
<th>Deleted</th>
</tr>
</thead>
<tbody><tr>
<td>baseAppData</td>
<td>BWPersonality.onBaseAppData</td>
<td>BWPersonality.onDelBaseAppData</td>
</tr>
<tr>
<td>cellAppData</td>
<td>BWPersonality.onCellAppData</td>
<td>BWPersonality.onDelCellAppData</td>
</tr>
<tr>
<td>globalData</td>
<td>BWPersonalityonGlobalData</td>
<td>BWPersonalityonDelGlobalData</td>
</tr>
</tbody></table>
<p><em>通过操作全局数据调用的回调函数。</em></p>
<p>BigWorld只在项目被分配给不同的对象时检测到它的变化，而不是当对象的一部分发生变化时。例如:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BigWorld.globalData[ <span class="string">&quot;list&quot;</span> ] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment"># addition is detected</span></span><br><span class="line">BigWorld.globalData[ <span class="string">&quot;list&quot;</span> ][<span class="number">1</span>] = <span class="number">7</span> <span class="comment"># modification not detected</span></span><br><span class="line">BigWorld.globalData[ <span class="string">&quot;list&quot;</span> ] = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>] <span class="comment"># modification is detected</span></span><br></pre></td></tr></table></figure>

<p>如果未检测到修改，则更改将不会复制到其他组件，从而导致本地副本和远程副本之间不一致。</p>
<p>每个值对象都是单独pickle的。这将导致该值是原始值的副本。例如:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">drinks = [ <span class="string">&quot;juice&quot;</span>, <span class="string">&quot;wine&quot;</span> ]</span><br><span class="line"><span class="comment"># BigWorld.globalData[ &quot;fridge&quot; ] will have its own copy of [ &quot;juice&quot;,&quot;wine&quot; ]</span></span><br><span class="line">BigWorld.globalData[ <span class="string">&quot;fridge&quot;</span> ] = drinks</span><br><span class="line"><span class="comment"># BigWorld.globalData[ &quot;cupboard&quot; ] will have its own copy of[ &quot;juice&quot;,&quot;wine&quot; ]</span></span><br><span class="line">BigWorld.globalData[ <span class="string">&quot;cupboard&quot;</span> ] = drinks</span><br></pre></td></tr></table></figure>

<h3 id="13-6-Space-Data"><a href="#13-6-Space-Data" class="headerlink" title="13.6. Space Data"></a><strong>13.6. Space Data</strong></h3><h3 id="13-7-Global-Bases"><a href="#13-7-Global-Bases" class="headerlink" title="13.7. Global Bases"></a><strong>13.7. Global Bases</strong></h3><h2 id="14-XML-Data-File-Access"><a href="#14-XML-Data-File-Access" class="headerlink" title="14. XML Data File Access"></a><strong>14. XML Data File Access</strong></h2><p><strong>14.1.</strong> <strong>ResMgr.DataSection</strong></p>
<p>服务器组件脚本可以访问存储在XML文件中的自定义数据。它们通常用于存储游戏数据资源，例如从玩法表到配置数据的任何内容。数据存储在XML层次结构中，可以通过遍历每个XML文件中定义的树来访问。</p>
<h2 id="14-2-Accessing-Data"><a href="#14-2-Accessing-Data" class="headerlink" title="14.2. Accessing Data"></a><strong>14.2. Accessing Data</strong></h2><p>假设一个数据文件定义如下:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">character</span>&gt;</span> Sir Manfred</span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span> White knight <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">modelName</span>&gt;</span> sets/main/characters/knight.model <span class="tag">&lt;/<span class="name">modelName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">race</span>&gt;</span> human <span class="tag">&lt;/<span class="name">race</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gender</span>&gt;</span> 0 <span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">character</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">character</span>&gt;</span> Sofia</span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span> Evil queen <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">modelName</span>&gt;</span> sets/main/characters/queen.model <span class="tag">&lt;/<span class="name">modelName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">race</span>&gt;</span> undead <span class="tag">&lt;/<span class="name">race</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gender</span>&gt;</span> 1 <span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slaves</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">character</span>&gt;</span> Underling</span><br><span class="line">                <span class="tag">&lt;<span class="name">description</span>&gt;</span> Hapless underling <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">modelName</span>&gt;</span> sets/main/characters/guard.model <span class="tag">&lt;/<span class="name">modelName</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">race</span>&gt;</span> undead <span class="tag">&lt;/<span class="name">race</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">gender</span>&gt;</span> 1 <span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">character</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">character</span>&gt;</span> Servant</span><br><span class="line">                <span class="tag">&lt;<span class="name">description</span>&gt;</span> Unpaid slave <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">modelName</span>&gt;</span> sets/main/characters/servant.model <span class="tag">&lt;/<span class="name">modelName</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">race</span>&gt;</span> undead <span class="tag">&lt;/<span class="name">race</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">gender</span>&gt;</span> 1 <span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">character</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">slaves</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">character</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Example XML file ‐ <em>&lt;res&gt;</em>&#x2F;scripts&#x2F;data&#x2F;Characters.xml</p>
<p>您可以通过使用ResMgr创建一个新的DataSection来访问这些数据。openSection方法。使用的路径参数是相对于资源路径的。下面的例子说明了这一点:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ds = ResMgr.openSection( <span class="string">&#x27;scripts/data/Characters.xml&#x27;</span> )</span><br><span class="line"><span class="comment"># this will retrieve &quot;Sir Manfred&quot;</span></span><br><span class="line">ds.child( <span class="number">0</span> ).asString</span><br><span class="line"><span class="comment"># this will retrieve &quot;White knight&quot;</span></span><br><span class="line">ds.child( <span class="number">0</span> )[<span class="string">&#x27;description&#x27;</span>].asString</span><br><span class="line"><span class="comment"># this will retrieve 1</span></span><br><span class="line">ds.child( <span class="number">0</span> )[<span class="string">&#x27;gender&#x27;</span>].asInt</span><br></pre></td></tr></table></figure>

<h4 id="14-2-1-Opening-a-Section-Within-an-XML-File"><a href="#14-2-1-Opening-a-Section-Within-an-XML-File" class="headerlink" title="14.2.1. Opening a Section Within an XML File"></a><strong>14.2.1. Opening a Section Within an XML File</strong></h4><p>你可以通过在ResMgr.openSection的路径末尾添加section名来访问XML文件中的section:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dsChild = ResMgr.openSection( <span class="string">&#x27;scripts/data/Characters.xml/character&#x27;</span> )</span><br></pre></td></tr></table></figure>

<h3 id="14-3-Data-Types"><a href="#14-3-Data-Types" class="headerlink" title="14.3. Data Types"></a><strong>14.3. Data Types</strong></h3><p>可用的数据类型有：</p>
<table>
<thead>
<tr>
<th>Data type</th>
<th>Accessed by</th>
</tr>
</thead>
<tbody><tr>
<td>64位浮点数</td>
<td>.asDouble</td>
</tr>
<tr>
<td>64位的整数</td>
<td>.asInt64</td>
</tr>
<tr>
<td>BLOB数据</td>
<td>.asBlob</td>
</tr>
<tr>
<td>浮点数</td>
<td>.asFloat</td>
</tr>
<tr>
<td>整数</td>
<td>.asInt</td>
</tr>
<tr>
<td>矩阵</td>
<td>.asMatrix</td>
</tr>
<tr>
<td>XML节点的原始二进制表示形式</td>
<td>.asBinary</td>
</tr>
<tr>
<td>string</td>
<td>.asString</td>
</tr>
<tr>
<td>Vector2</td>
<td>.asVector2</td>
</tr>
<tr>
<td>Vector3</td>
<td>.asVector3</td>
</tr>
<tr>
<td>Vector4</td>
<td>.asVector4</td>
</tr>
<tr>
<td>Wide strings</td>
<td>.asWideString</td>
</tr>
</tbody></table>
<p>要了解更多细节，请参见客户端Python API的条目Class List→DataSection。</p>
<h3 id="14-4-Writing-Data"><a href="#14-4-Writing-Data" class="headerlink" title="14.4. Writing Data"></a><strong>14.4. Writing Data</strong></h3><p>可以通过引用适当的.as&lt;数据类型&gt;属性写入属性，然后保存XML文件。</p>
<p><strong>这个特性只用于服务器工具，你应该避免在游戏脚本中使用它。</strong></p>
<p>需要注意的一个重要限制是，只能保存通过引用XML文档打开的DataSection。不可能直接保存由文件中子元素的路径检索的部分。</p>
<p>例如，下面的代码将不起作用:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># this will not work, throws IOError</span></span><br><span class="line">dsChild = ResMgr.openSection( <span class="string">&#x27;scripts/data/Characters.xml/character&#x27;</span> )</span><br><span class="line">dsChild.asString = <span class="string">&quot;Sir Lancelot&quot;</span></span><br><span class="line">dsChild.save()</span><br></pre></td></tr></table></figure>

<p>另一方面，下面的代码将会工作:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># this will work</span></span><br><span class="line">dsRoot = ResMgr.openSection( <span class="string">&#x27;scripts/data/Characters.xml&#x27;</span> )</span><br><span class="line">dsChild = dsRoot.child( <span class="number">0</span> )</span><br><span class="line">dsChild.asString = <span class="string">&quot;Sir Lancelot&quot;</span></span><br><span class="line">dsRoot.save()</span><br></pre></td></tr></table></figure>

<p>你也可以在每个数据段中添加或删除子元素:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># get the document data section</span></span><br><span class="line">dsRoot = ResMgr.openSection( <span class="string">&#x27;scripts/data/Characters.xml&#x27;</span> )</span><br><span class="line"><span class="comment"># this will delete the first character</span></span><br><span class="line">dsRoot.deleteSection( <span class="string">&#x27;character&#x27;</span> )</span><br><span class="line"><span class="comment"># create a new character, which is appended to the top-level</span></span><br><span class="line">newChild = dsRoot.createSection( <span class="string">&#x27;character&#x27;</span> )</span><br><span class="line">newChild.asString = <span class="string">&quot;King Arthur&quot;</span></span><br><span class="line">newChild.createSection( <span class="string">&#x27;description&#x27;</span> )</span><br><span class="line">newChild.createSection( <span class="string">&#x27;modelName&#x27;</span> )</span><br><span class="line">newChild.createSection( <span class="string">&#x27;race&#x27;</span> )</span><br><span class="line">newChild.createSection( <span class="string">&#x27;gender&#x27;</span> )</span><br><span class="line">newChild.createSection( <span class="string">&#x27;slaves&#x27;</span> )</span><br><span class="line">newChild[<span class="string">&#x27;description&#x27;</span>].asString = <span class="string">&quot;The King of Camelot&quot;</span></span><br><span class="line">newChild[<span class="string">&#x27;modelName&#x27;</span>].asString = <span class="string">&#x27;sets/main/character/knight.model&#x27;</span></span><br><span class="line">newChild[<span class="string">&#x27;race&#x27;</span>].asString = <span class="string">&#x27;human&#x27;</span></span><br><span class="line">newChild[<span class="string">&#x27;gender&#x27;</span>].asInt = <span class="number">0</span></span><br><span class="line">dsRoot.save()</span><br></pre></td></tr></table></figure>

<p>运行下面的代码摘录，并假设一个Characters.xml如“Accessing Data” 中所述，结果将是下面的文件:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">character</span>&gt;</span> Sofia</span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span> Evil queen <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">modelName</span>&gt;</span> sets/main/characters/queen.model <span class="tag">&lt;/<span class="name">modelName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">race</span>&gt;</span> undead <span class="tag">&lt;/<span class="name">race</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gender</span>&gt;</span> 1 <span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slaves</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">character</span>&gt;</span> Underling</span><br><span class="line">                <span class="tag">&lt;<span class="name">description</span>&gt;</span> Hapless underling <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">modelName</span>&gt;</span> sets/main/characters/guard.model <span class="tag">&lt;/<span class="name">modelName</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">race</span>&gt;</span> undead <span class="tag">&lt;/<span class="name">race</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">gender</span>&gt;</span> 1 <span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">character</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">character</span>&gt;</span> Servant</span><br><span class="line">                <span class="tag">&lt;<span class="name">description</span>&gt;</span> Unpaid slave <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">modelName</span>&gt;</span> sets/main/characters/servant.model <span class="tag">&lt;/<span class="name">modelName</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">race</span>&gt;</span> undead <span class="tag">&lt;/<span class="name">race</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">gender</span>&gt;</span> 1 <span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">character</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">slaves</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">character</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">character</span>&gt;</span> King Arthur</span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span> The King of Camelot <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">modelName</span>&gt;</span> sets/main/character/knight.model <span class="tag">&lt;/<span class="name">modelName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">race</span>&gt;</span> human <span class="tag">&lt;/<span class="name">race</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gender</span>&gt;</span> 0 <span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slaves</span>&gt;</span> <span class="tag">&lt;/<span class="name">slaves</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">character</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Resulting <em>&lt;res&gt;</em>&#x2F;scripts&#x2F;data&#x2F;Characters.xml</p>
<h3 id="14-5-Performance-Issues"><a href="#14-5-Performance-Issues" class="headerlink" title="14.5. Performance Issues"></a><strong>14.5. Performance Issues</strong></h3><p>访问磁盘上的XML文件可能会暂停游戏处理。这可以通过磁盘I&#x2F;O和解析结果数据来实现。在读取和写入XML文件时都可能出现这种处理停顿，应该尽可能避免。</p>
<h3 id="14-6-API-Reference"><a href="#14-6-API-Reference" class="headerlink" title="14.6. API Reference"></a><strong>14.6. API Reference</strong></h3><p>ResMgr记录了数据部分的方法，可以在BaseAPpPythonAPI、CellAppPythonAPI和Client PythonAPI中找到。</p>
<h2 id="15-External-Services"><a href="#15-External-Services" class="headerlink" title="15. External Services"></a><strong>15. External Services</strong></h2><p>从你的游戏脚本，你可能想访问外部服务，如计费或购物系统。当这样做时，重要的是不要阻塞I&#x2F;O，因为暂停太长时间的进程可能会被其他服务器组件认为是死的。为了避免I&#x2F;O阻塞，你可以这样做:</p>
<ol>
<li>使用非阻塞方法并处理通知(反应器模式)。</li>
<li>从后台线程调用阻塞方法(线程池模式)。</li>
</ol>
<p>(不作过多研究)</p>
<h2 id="16-Fault-Tolerance"><a href="#16-Fault-Tolerance" class="headerlink" title="16. Fault Tolerance"></a><strong>16. Fault Tolerance</strong></h2><h3 id="16-1-CellApp-Fault-Tolerance"><a href="#16-1-CellApp-Fault-Tolerance" class="headerlink" title="16.1. CellApp Fault Tolerance"></a><strong>16.1. CellApp Fault Tolerance</strong></h3><h4 id="16-1-1-Overview"><a href="#16-1-1-Overview" class="headerlink" title="16.1.1. Overview"></a><strong>16.1.1. Overview</strong></h4><p>每个单元实体的完整副本定期备份到基本实体上。只有具有关联基本实体的单元实体是容错的。CellApp备份周期指定单元实体备份到基本实体的频率，并在bw.xml选项&lt; CellApp &#x2F;backupPeriod&gt;中指定。</p>
<p>如果CellApp进程不可用，位于该进程上的单元上的实体将由其对应的基本实体恢复到其他CellApp。恢复的单元实体的单元数据状态与从单元实体到基本实体的最近备份所给出的状态相同。</p>
<h4 id="16-1-2-Restoration-process"><a href="#16-1-2-Restoration-process" class="headerlink" title="16.1.2. Restoration process"></a><strong>16.1.2. Restoration process</strong></h4><p>CellApp恢复过程通常遵循以下步骤：</p>
<ol>
<li>CellApp进程不可用。</li>
<li>在现在不可用的CellApp进程上具有单元实体的基本实体将其相应的真实实体恢复到其他CellApp。</li>
<li>恢复的单元格实体调用了onRestore()回调函数。由于恢复的单元数据是从最后一次备份到基本单元实体的单元数据中获取的，因此此副本最多可以是备份周期的两倍。这个回调应该检查实体的属性是否处于一致状态。</li>
<li>对于播放器单元实体，它们对应的客户端播放器实体会调用onRestore()回调函数。</li>
</ol>
<p>在单元实体上调用回调onRestore()来通知它正在恢复。</p>
<p>下面的代码片段说明了它在cell实体上的实现:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SomeEntity</span>( BigWorld.Entity ):</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"> self </span>):</span><br><span class="line">        <span class="comment"># set up initial property values</span></span><br><span class="line">        ...</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">onRestore</span>(<span class="params"> self </span>):</span><br><span class="line">        <span class="comment"># check that property values are consistent, and</span></span><br><span class="line">        <span class="comment"># perform any cleanups that need to occur</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<p>Example file <em>&lt;res&gt;</em>&#x2F;scripts&#x2F;cell&#x2F;<em>SomeEntity</em>.py</p>
<h4 id="16-1-3-Example"><a href="#16-1-3-Example" class="headerlink" title="16.1.3. Example"></a><strong>16.1.3. Example</strong></h4><img src="E:\markDown\image\bigworld\06_19.png" alt="06_19" style="zoom:80%;" />

<p>在上图中CellApp中有三个cell实体4156,5712和2114，其中4156和2114分别在BaseApp1，BaseApp2中有base实体，假如此时CellApp4崩溃，4156和5712将会从BaseApp中恢复上次备份的数据，并创建cell4156和cell5712而cell2114则不会被创建。</p>
<p>恢复的可能与当前丢失的cell实体不一致，cell实体的备份可以在多步骤事务的中间进行备份。脚本回调Entity.onRestore()可以用于检查未处理事务的状态，并且可以在脚本中决定回滚或继续它们。</p>
<h3 id="16-2-BaseApp-Fault-Tolerance"><a href="#16-2-BaseApp-Fault-Tolerance" class="headerlink" title="16.2. BaseApp Fault Tolerance"></a><strong>16.2. BaseApp Fault Tolerance</strong></h3><p>有了BaseApp的容错功能，BaseApp会备份基本实体数据，并定期将所有基本实体的数据cell备份到其他BaseApp进程。</p>
<p>如果主BaseApp不可用，那么它的所有实体都将从备份进程中恢复。在这种情况下，BaseApp调用基实体或代理实体上的onRestore回调，其过程与CellApp恢复的过程类似。此回调应确保实体上的所有属性处于一致状态。</p>
<p>详情（Server Overview’s section <em>Server Components</em> → “BaseApp” → “Fault Tolerance”）</p>
<h2 id="17-Disaster-Recovery"><a href="#17-Disaster-Recovery" class="headerlink" title="17. Disaster Recovery"></a><strong>17. Disaster Recovery</strong></h2><p>BigWorld的容错能力确保了在单个进程丢失时，服务器将继续运行。服务器还提供了称为灾难恢复的第二级容错。服务器的状态可以定期写入数据库。如果整个服务器都出现故障，则可以使用此信息重新启动服务器。</p>
<p>这个归档的速率由配置选项在文件&lt;res&gt;&#x2F;server&#x2F;bw.xml的&lt; baseApp &#x2F; archivePeriod &gt;和&lt; cellAppMgr &#x2F; archivePeriod &gt;中指定。</p>
<p>CellAppMgr进程负责将空间数据和游戏时间写入数据库。</p>
<p>具有有效数据库条目的实体也会定期存档(通过基本实体上的非零databaseID表示)。要将实体写入数据库，从而启用其归档，请在基实体或单元实体上调用writeToDB()方法。</p>
<p>具有有效数据库条目的实体也会定期存档(通过基本实体上的非零databaseID表示)。要将实体写入数据库，从而启用其归档，请在基实体或单元实体上调用writeToDB()方法。</p>
<p>每次存档实体时，都会调用它的onWriteToDB()回调函数。</p>
<h2 id="18-Controlled-Startup-and-Shutdown"><a href="#18-Controlled-Startup-and-Shutdown" class="headerlink" title="18. Controlled Startup and Shutdown"></a><strong>18. Controlled Startup and Shutdown</strong></h2><p>有时可能需要关闭服务器，然后以类似的状态重新启动。本章描述了该场景下脚本的相关细节。</p>
<h3 id="18-1-Controlled-Shutdown"><a href="#18-1-Controlled-Shutdown" class="headerlink" title="18.1. Controlled Shutdown"></a><strong>18.1. Controlled Shutdown</strong></h3><p>控制停机过程如下：</p>
<ol>
<li><p>LoginApp进程接收到USR1信号。</p>
</li>
<li><p>LoginApp进程立即关闭。</p>
</li>
<li><p>CellAppMgr收到一条消息来安排关闭(在游戏时间内)。</p>
</li>
<li><p>CellAppMgr向其他进程发送一条消息，通知它们何时计划关闭。</p>
</li>
<li><p>CellApp个性脚本的onAppShutingDown回调被调用。</p>
<p>这一步和下一步的个性脚本应该执行适当的完成任务，比如结束长时间的任务，如战斗或交易，通知玩家，停止新的长时间任务。</p>
</li>
<li><p>调用BaseApp个性脚本的onAppShuttingDown回调函数。</p>
</li>
<li><p>一旦执行了这些回调，将调用方法BigWorld.isShuttingDown返回True。</p>
</li>
<li><p>其他服务器进程(CellApps, BaseAppMgr, BaseApps, Backup BaseApps, DBMgr, Reviver)不会立即停止，而是执行任何完成的任务。</p>
<p>这个延迟可以通过使用配置选项&lt; shutingdowndelay &gt;在res&#x2F;server&#x2F;bw.xml文件中指定。</p>
</li>
<li><p>关闭游戏时间达到。</p>
</li>
<li><p>游戏停止运行，但进程没有关闭。</p>
<p>这意味着游戏时间不再增加，也没有勾选游戏对象。</p>
</li>
<li><p>当准备关闭时，CellAppMgr将游戏时间写入数据库。如果配置为archiiving, CellAppMgr也会将空间数据写入数据库。</p>
</li>
<li><p>此步骤与第11步并行进行。</p>
<p>每个BaseApp执行以下步骤:</p>
<ul>
<li><p>接收一条消息以断开任何已连接的客户端。</p>
</li>
<li><p>在断开客户端连接之前调用带有0参数的onAppShutDown回调函数。</p>
<p>对于每个断开连接的客户机，将调用代理的回调onClientDeath。</p>
</li>
<li><p>在将每个带有数据库条目的实体写入数据库之前，调用参数为1的onAppShutDown回调函数</p>
</li>
<li><p>调用参数为2的onAppShutDown回调函数。</p>
</li>
</ul>
</li>
<li><p>所有服务器进程关闭。</p>
</li>
</ol>
<h3 id="18-2-Controlled-Startup"><a href="#18-2-Controlled-Startup" class="headerlink" title="18.2. Controlled Startup"></a><strong>18.2. Controlled Startup</strong></h3><p>当启动时，DBMgr最初会等待，直到所有组件都准备好。BaseApp和CellApp进程的最小数目可以在bw.xml中通过 &lt;desiredBaseApps&gt; 和&lt;desiredCellApps&gt;。一旦准备好，DBMgr将空间数据加载回系统(如果它是由CellAppMgr归档的)。</p>
<p>然后通过创建基本实体将自动加载实体加载到系统中。</p>
<p>如果需要，则由脚本创建单元实体。在启动期间创建单元实体通常与在其他时间创建单元实体不同。通常是Base方法。使用单元实体邮箱调用createCellEntity，以指示实体的空间。但是在启动期间，实体的空间ID会被恢复并设置在base.cellData地图。基本实体脚本可以通过调用不带参数的base.createCellEntity方法。</p>
<p>一旦服务器准备好开始运行，来自人格脚本的onAppReady回调将在BaseApps和CellApps上调用。</p>
<h2 id="19-Transactions-and-Handling-Fault-Tolerance-and-Disaster-Recovery"><a href="#19-Transactions-and-Handling-Fault-Tolerance-and-Disaster-Recovery" class="headerlink" title="19. Transactions and Handling Fault Tolerance and Disaster Recovery"></a><strong>19. Transactions and Handling Fault Tolerance and Disaster Recovery</strong></h2><h3 id="19-1-Transaction-logic"><a href="#19-1-Transaction-logic" class="headerlink" title="19.1. Transaction logic"></a><strong>19.1. Transaction logic</strong></h3><p>我们在这里给出了一个交易事务的例子，即在两个玩家实体之间传送一个道具。</p>
<h3 id="19-2-Fault-Tolerance-Behaviour"><a href="#19-2-Fault-Tolerance-Behaviour" class="headerlink" title="19.2. Fault Tolerance Behaviour"></a><strong>19.2. Fault Tolerance Behaviour</strong></h3><h4 id="19-2-1-CellApp-Fault-Tolerance"><a href="#19-2-1-CellApp-Fault-Tolerance" class="headerlink" title="19.2.1. CellApp Fault Tolerance"></a><strong>19.2.1. CellApp Fault Tolerance</strong></h4><p>如果Alice和&#x2F;或Bob的单元实体所在的CellApp退出，所有具有基本实体的单元实体将被恢复到另一个CellApp。在这个示例场景和描述的事务中，没有太多关于恢复单元实体的行为的问题，因为事务只涉及到BaseApps。</p>
<p>然而，假设库存系统的实现是这样的，玩家单元实体需要关于道具的知识，例如，玩家手中持有什么道具，这将需要OTHER_CLIENTS或ALL_CLIENTS单元实体属性，以便其他玩家能够查看玩家所持有的道具。如果单元实体在最后一次备份到基本实体时从其单元实体数据的旧版本恢复，则单元实体状态可能与基本实体状态不一致。</p>
<p>例如，如果Alice被恢复到另一个CellApp，她的单元实体可以检查她的基础实体是否仍然拥有她持有的物品，如果不是，她的单元实体应该删除该物品。</p>
<p>被恢复的单元实体不会调用它们的_<em>init</em>_()方法，相反，在使用来自基本实体的单元备份数据恢复它们之后，它们会调用它们的onRestore()方法，并且可以在此方法中执行诸如此类的检查，以确保状态与基本实体状态一致。</p>
<h4 id="19-2-2-BaseApp-Fault-Tolerance"><a href="#19-2-2-BaseApp-Fault-Tolerance" class="headerlink" title="19.2.2. BaseApp Fault Tolerance"></a><strong>19.2.2. BaseApp Fault Tolerance</strong></h4><p>如果Alice和&#x2F;或Bob的base实体所在的BaseApp退出，如果这些base实体存在，它们将被恢复到其他BaseApp(如果只有一个BaseApp，它们无法恢复)。</p>
<p>与单元实体一样，恢复的基本实体没有_<em>init</em>_()调用，相反，当从它们最近的基本实体备份数据恢复它们时，它们有onRestore()调用。这是检查未完成事务的好地方。</p>
<p>例如，如果包含Alice的BaseApp退出，并且Alice被恢复到另一个BaseApp上(也许Bob也被恢复到另一个BaseApp上，它可能是一个不同的BaseApp)，那么我们需要重播可能正在进行的任何事务。</p>
<p>对于Alice事务列表中的每个事务条目，实体需要根据它所处的状态重放每个事务。</p>
<p>例如，如果它处于BEGIN状态，则通过查找Bob的基本实体，并继续从步骤3恢复事务。</p>
<p>如果我们是Bob，我们可能有处于REMOVE状态的事务，因此我们从步骤继续事务6，我们告诉Alice(或者交易玩家的名字指的是谁)，他们应该在自己的一端完成交易。</p>
<h4 id="19-3-Disaster-Recovery-Behaviour"><a href="#19-3-Disaster-Recovery-Behaviour" class="headerlink" title="19.3. Disaster Recovery Behaviour"></a><strong>19.3. Disaster Recovery Behaviour</strong></h4><p>当我们启动服务器并从数据库中恢复时，基本实体将被恢复，并且每个实体都将对它们调用_<em>init</em>_()。对于恢复的基本实体，变量BigWorld.hasStarted将为False，因此我们可以进行与BaseApp容错部分类似的检查。基本实体也要负责重新创建单元实体，通常是通过createCellEntity().。空间ID在它被写入数据库时与实体一起存档，它出现在基实体的cellData字典中。</p>
<h2 id="20-Implementing-Common-Systems"><a href="#20-Implementing-Common-Systems" class="headerlink" title="20. Implementing Common Systems"></a><strong>20. Implementing Common Systems</strong></h2><p>本章讨论了程序员在执行游戏系统时应该记住的一些一般性问题，并提供了一些mmog中常用系统的设计和实现示例。</p>
<h3 id="20-1-General-Scalability"><a href="#20-1-General-Scalability" class="headerlink" title="20.1. General Scalability"></a><strong>20.1. General Scalability</strong></h3><p>一般来说，如果玩家和实体密度保持不变，服务器处理负载、内网带宽和外网带宽与玩家数量呈线性关系。随着密度的增加，会有一个小的额外成本。</p>
<p>容量可通过以下方式增加：</p>
<ul>
<li>增加更多的BaseApps以获得更多的外部连接点和连接处理能力</li>
<li>增加更多的CellApps以获得更多的空间处理能力</li>
<li>添加更多BaseApps和更多CellApps的组合，以增加游戏脚本处理能力</li>
</ul>
<p>CellAppMgr、BaseAppMgr和DBMgr是单一实例，理论上是扩展瓶颈。CellAppMgr和BaseAppMgr只关心管理CellApp和基础应用程序，并且负载非常低。它们可以扩展到处理成千上万的基本应用程序和单元应用程序。虽然BigWorld的设计没有大量使用数据库，但缩放的主要问题是DBMgr。下面将在BigWorld数据库可伸缩性中讨论。</p>
<h3 id="20-2-Internal-inter-component-communication"><a href="#20-2-Internal-inter-component-communication" class="headerlink" title="20.2. Internal inter-component communication"></a><strong>20.2. Internal inter-component communication</strong></h3><p>为实体提供充分服务所需的BaseApps和CellApps的数量通常应该随实体的数量线性增长。实体之间的大多数通信都是与邻近的实体进行的。这是通过将这些实体尽可能多地放在CellApps上来处理的。其他通信包括使用远程方法调用的点对点通信。这里的主要问题是尽量减少需要在全球范围内查找实体的情况。</p>
<p>用于写入实体状态的DBMgr功能分布在每个baseapp的辅助数据库中，并在实体退役时进行整合。</p>
<p>解决游戏脚本瓶颈的一般策略是尽可能避免全局游戏系统，例如让单一实体控制游戏的某些操作，例如交易。通常情况下，这些瓶颈可以通过重组游戏脚本和使用分布式对象方法来实现全局子系统来避免，而不是将请求处理委托给单个实体。下面给出了一个这样的例子(请参阅下面基于aoi的交易)。</p>
<h3 id="20-3-Player-AoI-Updates"><a href="#20-3-Player-AoI-Updates" class="headerlink" title="20.3. Player AoI Updates"></a><strong>20.3. Player AoI Updates</strong></h3><p>对玩家AoI中某些实体的更新就会被传播到玩家的客户端(默认情况下，游戏更新赫兹是10Hz)。发送到播放器客户端的更新数据量被限制为一个下游比特率(默认情况下，发送到第二个客户端的比特率是20kbps)。</p>
<p>这些更新包括属性更改和方法调用。每个单元实体都保存这些更改的历史，对于玩家AoI中的每个实体，玩家都会定期逐步更新该实体。实体的位置和方向数据经过特别处理，以便只将这些属性的最新值（所谓的volatie属性）发送给客户，而不是属性的完整历史。</p>
<p>在内部，AoI中的实体位于优先级队列中。玩家的实体在AoI中的优先级决定了该实体的下一次更新需要多长时间。</p>
<p>然而，非常高的实体密度可能会导致问题，因为这会导致对玩家客户端的每次定期更新都被过量的实体事件数据溢出。回想一下，下游带宽的数量是一个可配置的常数。由于在玩家的AoI中实体的变化事件的优先级，如果有更多的实体更靠近玩家，这可能会导致更远的实体的更新被饥饿。增加下游带宽可以改善这种情况下，但最终，通常是客户端成为限制因素。每个实体的处理成本，例如：</p>
<ul>
<li>处理每个实体的位置和方向的通知</li>
<li>处理每个实体属性更改的通知</li>
<li>处理每个实体的方法调用的通知</li>
<li>将物理规则应用于每个实体</li>
<li>每个实体的渲染</li>
</ul>
<p>玩家能够理解的信息量也是有限的。当附近有大量的实体时，远处的实体需要的信息就会更少。</p>
<p>通过良好的游戏设计，可以避免可能会对最终用户体验产生负面影响的极端实体密度。</p>
<h3 id="20-4-BigWorld-Database-Scalability"><a href="#20-4-BigWorld-Database-Scalability" class="headerlink" title="20.4. BigWorld Database Scalability"></a><strong>20.4. BigWorld Database Scalability</strong></h3><p>当实体签出数据库时，它们被分配给负载最少的BaseApp。一旦实体被加载到一个BaseApp上，它们通常不会从这个BaseApp上迁移出去，除非这个BaseApp进程终止，在这种情况下，它们会在系统中的其他BaseApp上恢复。</p>
<p>对于驻留在它上面的每个实体，BaseApp负责收集该实体在签出生命周期内的所有显式脚本写入(从对BigWorld.writeToDB()的调用)，以及对该实体的定期备份。这些写操作是在存储在BaseApp机器上的辅助数据库上执行的。</p>
<h3 id="20-5-Player-Look-up"><a href="#20-5-Player-Look-up" class="headerlink" title="20.5. Player Look-up"></a><strong>20.5. Player Look-up</strong></h3><h4 id="20-5-1-Requirements"><a href="#20-5-1-Requirements" class="headerlink" title="20.5.1. Requirements"></a><strong>20.5.1. Requirements</strong></h4><p>每个玩家必须能够通过名字查询另一个玩家的状态:</p>
<ul>
<li>不管他们是否已经登录。</li>
<li>如果他们已经登录，就获取他们的玩家邮箱</li>
</ul>
<h4 id="20-5-2-Design"><a href="#20-5-2-Design" class="headerlink" title="20.5.2. Design"></a><strong>20.5.2. Design</strong></h4><p>使用BigWorld.lookUpBaseByName()会导致对DBMgr的查询(这会导致对主数据库的读取)，虽然对于许多场景来说足够了(并且在许多基于bigworld发布的游戏中都有效)，但也引入了一个潜在的瓶颈。下面的讨论概述了一个玩家姓名到玩家邮箱的分布式映射设计，它有效地将这个负载转移到BaseApp游戏脚本，可以通过添加更多的BaseApp来扩展。</p>
<p>我们的想法是拥有多个包含玩家姓名到玩家邮箱的分布式映射的PlayerRegistry Base实体。这些PlayerRegistry实体没有地理空间表示，它们只作为系统服务存在，因此不会产生与AoI更新相关的负载。</p>
<p>每个BaseApp都有一个对应的PlayerRegistry实体——这将PlayerRegistry实体扩展开来，防止BaseApp失败。每个BaseApp拥有一个以上的PlayerRegistry实体不会增加任何额外的冗余好处。</p>
<p>PlayerRegistry实体实例在全局注册自己。全局注册的基的邮箱在全局基映射中的字符串键下注册，该映射在每个baseapp之间同步。玩家名称根据已知的玩家注册表数量进行散列，并且一个特定的玩家注册表实例通过全局基础机制进行定位。</p>
<p>当玩家实体被创建时，他们通过将自己的名字散列到适当的PlayerRegistry实体将自己添加到分布式注册表中，并向PlayerRegistry实体注册自己的基本邮箱。注销时，他们联系同一PlayerRegistry通知它注销，这将导致删除该玩家姓名和该玩家邮箱之间的映射。当添加或删除一个新的PlayerRegistry时，我们可以实现一个重新平衡玩家注册表条目的方案，即在PlayerRegistry实体间重新平衡条目。</p>
<p>对于特定玩家名的查询是通过首先将玩家名散列到适当的PlayerRegistry中进行查找，然后通过远程方法查询多个PlayerRegistry实体中的一个，以及带有邮箱的回调远程方法。对玩家查找的请求是异步的，调用者实体实现一个回调方法，当查找完成时被回调。</p>
<p>为了容错，每个PlayerRegistry都需要一个持久的邮箱列表，这样，如果它之前所在的BaseApp失败，注册表就会连同PlayerRegistry实体一起恢复到另一个BaseApp。在这种情况下，它很可能会被恢复到另一个已经有自己的PlayerRegistry的BaseApp，所以应该重新平衡，然后销毁恢复的PlayerRegistry。</p>
<p>通过增加BaseApps的数量来处理查询，这个系统可以进行扩展。分层请求模式还可以用来避免大量全局注册的基础实体成为瓶颈。</p>
<h3 id="20-6-Friends-lists"><a href="#20-6-Friends-lists" class="headerlink" title="20.6. Friends lists"></a><strong>20.6. Friends lists</strong></h3><h4 id="20-6-1-Requirements"><a href="#20-6-1-Requirements" class="headerlink" title="20.6.1. Requirements"></a><strong>20.6.1. Requirements</strong></h4><p>每个玩家都维护一个其他玩家的列表，他们可以用于以下目的:</p>
<ul>
<li>联系朋友</li>
<li>给朋友发私人信息</li>
<li>存在更新</li>
</ul>
<h4 id="20-6-2-Design"><a href="#20-6-2-Design" class="headerlink" title="20.6.2. Design"></a><strong>20.6.2. Design</strong></h4><p>假设友谊关系是对称的，所以如果A在B的朋友列表上，那么B在A的朋友列表上。一个朋友列表可以被实现为一个数组的FIXED_DICT，包含一个STRING名称属性，和播放器的邮箱(或None，如果离线)，utit8布尔标志hasresponsiveness表明这个播放器已经响应了我们的请求，添加该播放器为朋友。</p>
<h5 id="20-6-2-1-Adding-new-friends"><a href="#20-6-2-1-Adding-new-friends" class="headerlink" title="20.6.2.1. Adding new friends"></a><strong>20.6.2.1. Adding new friends</strong></h5><p>让添加朋友的玩家被称为玩家A，而被添加到玩家A的列表中的朋友被称为玩家B。</p>
<ol>
<li><p>玩家A检查玩家B是否还不在A的朋友列表中。玩家A使用玩家B的名称通过玩家查找机制查找B的状态和邮箱（如果在线）。</p>
</li>
<li><p>如果B不在线，那么我们的操作就失败了。可以实施适应这种情况的方案，但为了简单起见，这里不讨论。</p>
<p>如果玩家B是在线的，那么玩家A将玩家B添加到它的好友列表中，将已响应的标记设置为False，并使用Base.writeToDB()将自己写入数据库，在数据库写完成时注册一个回调。</p>
</li>
<li><p>如果写入失败，那么我们通过删除玩家B的FIXED_DICT元素来回滚好友列表，并中止这个过程，并通知玩家A的客户端系统错误。</p>
<p>否则，写入将成功完成，因此玩家A通过远程方法调用通知玩家B，将玩家A添加到玩家B的列表中，并传递玩家A的名称和邮箱。</p>
<p>玩家A会周期性地重新发送这些未完成的请求(通过好友列表中的hasresponses为False来表示)，每隔3秒。每次重发邮件时都要查看邮箱，以防玩家B已经恢复到另一个BaseApp，或者玩家B已经注销和&#x2F;或再次登录。如果玩家B在重试期间不在线，那么操作将失败，玩家a的客户端将被告知玩家B不在线。</p>
</li>
<li><p>通常情况下，玩家B不会已经有玩家A作为好友，所以玩家B通过为玩家A创建包含玩家A姓名和邮箱的FIXED_DICT元素来添加本地好友列表，并将hasresponses标志设置为True。用回调请求对数据库的写操作。</p>
<p>玩家B的好友列表中可能已经有玩家A的条目。如果玩家A和玩家B同时试图添加对方为好友，就会发生这种情况(在这种情况下，hasresponses将为False)。如果玩家B被恢复到另一个BaseApp，或者在等待写数据库的过程中被销毁并重新创建，或者写数据库花费了很长时间，玩家A重新发送了请求，在这些情况下，hasResponded将会是True。</p>
<p>如果hasresponses标志为True，那么它立即向玩家A发出操作成功的信号。如果hasresponses标志为False，那么它应该设置为True，并且在向玩家A发送成功信号之前将数据库写入并从数据库中回调。</p>
</li>
<li><p>通常情况下，写入成功，玩家B就会回调玩家A以表明请求成功。</p>
<p>在特殊情况下，写操作可能会失败。玩家B在好友列表中删除玩家A的FIXED_DICT条目，并回调玩家A以指示操作失败。</p>
<p>在这种情况下，玩家A应该尝试删除玩家B的FIXED_DICT元素，这应该通过将玩家A写入数据库来持久化。然而，玩家a有可能在第二次数据库写入失败，而之前的数据库写入成功，这使得玩家a的好友列表在数据库中不一致。有一些方法可以处理这种情况:</p>
<ul>
<li>不要在玩家A的列表中删除玩家B的FIXED_DICT条目，而是让玩家A定期向玩家B重试请求，直到玩家B成功回应。</li>
<li>在玩家A写入数据库时，定期删除玩家B的FIXED_DICT条目。</li>
</ul>
<p>这两种方法都假定数据库写失败是暂时现象。可能是由于BaseApp辅助数据库没有足够的磁盘空间，当系统管理员创建更多空间时就会清理磁盘空间。可以保留一个重试计数，在重试计数超过某个阈值后从朋友列表中删除FIXED_DICT条目，并且应该通知玩家A的客户端失败。</p>
</li>
<li><p>当玩家B成功回调时，玩家a将hasresponses标志设置为True。此时不需要写数据库，因为可以依赖定期的备份和归档系统来最终保存它。在系统重启或Player A被恢复到另一个BaseApp的情况下，定期重试hasresponder设置为False的FIXED_DICT条目将获得第二次成功的回调，并最终被写入。</p>
</li>
</ol>
<p>对于所有玩家来说，添加好友列表并不是一种频繁的操作，玩家通常分布在可用的BaseApps中。</p>
<p>将玩家从好友列表中移除也可以采用类似的方法。</p>
<h5 id="20-6-2-2-Private-messages-to-friends"><a href="#20-6-2-2-Private-messages-to-friends" class="headerlink" title="20.6.2.2. Private messages to friends"></a><strong>20.6.2.2. Private messages to friends</strong></h5><p>请参阅下面的聊天部分。一旦有了玩家邮箱，就可以使用一个简单的远程方法调用向他们发送聊天消息。</p>
<h5 id="20-6-2-3-Presence-information"><a href="#20-6-2-3-Presence-information" class="headerlink" title="20.6.2.3. Presence information"></a><strong>20.6.2.3. Presence information</strong></h5><p>存在通知可以简单地通过在每个玩家的朋友列表中调用一个方法来实现，表明他们已经登录或注销(这表示邮箱是无效的，应该在相应的FIXED_DICT在数组中设置为None)。</p>
<p>玩家状态通知(例如离开键盘)也可以以类似的方式完成。玩家基础实体会通知他们的客户端好友状态的任何变化，这样他们就可以更新好友列表的用户界面。</p>
<h5 id="20-6-2-4-Cache-of-friend-player-mailboxes"><a href="#20-6-2-4-Cache-of-friend-player-mailboxes" class="headerlink" title="20.6.2.4. Cache of friend player mailboxes"></a><strong>20.6.2.4. Cache of friend player mailboxes</strong></h5><p>当好友登录时，好友列表可以作为玩家邮箱的缓存，并且不需要使用通用的玩家查找机制来与他们的好友玩家实体通信。当朋友注销时，朋友邮箱被设置为“无”。</p>
<p>缓存不需要是持久性的，因此不会向数据库添加任何额外的处理成本。</p>
<h5 id="20-6-2-5-Fault-tolerance-handling"><a href="#20-6-2-5-Fault-tolerance-handling" class="headerlink" title="20.6.2.5. Fault tolerance handling"></a><strong>20.6.2.5. Fault tolerance handling</strong></h5><p>当一个玩家被恢复时，一些朋友可能已经在线或离线(或离线，然后在线)，因为该玩家和好友列表上次被备份。在恢复或初始化时，玩家实体应该对其好友列表中的所有玩家执行查找。它还应该在恢复时通知所有在线的朋友它的新邮箱。</p>
<h3 id="20-7-Chat"><a href="#20-7-Chat" class="headerlink" title="20.7. Chat"></a><strong>20.7. Chat</strong></h3><ul>
<li>P2P chat</li>
<li>AoI-based chat</li>
<li>Channel-based chat(包括guid聊天，世界聊天)</li>
</ul>
<h4 id="20-7-1-P2P"><a href="#20-7-1-P2P" class="headerlink" title="20.7.1. P2P"></a><strong>20.7.1. P2P</strong></h4><h5 id="20-7-1-1-Requirements"><a href="#20-7-1-1-Requirements" class="headerlink" title="20.7.1.1. Requirements"></a><strong>20.7.1.1. Requirements</strong></h5><p>玩家需要能够向其他玩家发送信息。玩家是按名字命名的</p>
<h5 id="20-7-1-2-Design"><a href="#20-7-1-2-Design" class="headerlink" title="20.7.1.2. Design"></a><strong>20.7.1.2. Design</strong></h5><p>参见上文玩家查找部分。玩家间的聊天涉及以下内容:</p>
<ul>
<li>需要获取目标播放器的邮箱。这可以通过以下方式之一实现:<ul>
<li>由玩家单元实体提供，因为目标实体在玩家的AoI中</li>
<li>本地查找您的朋友列表邮箱缓存</li>
<li>使用上面描述的玩家查找机制查找他们的邮箱</li>
</ul>
</li>
<li>使用聊天消息内容调用该邮箱上的聊天远程方法。</li>
</ul>
<p>为了节省查找的远程方法成本，玩家邮箱可以作为非持久实体属性缓存在玩家实体上。例如，发送给非好友玩家的私人消息往往会导致对话，所以将玩家姓名映射到玩家邮箱的本地缓存将在每次发送进一步聊天消息时节省查找时间。</p>
<h4 id="20-7-2-AoI-based-broadcast-chat"><a href="#20-7-2-AoI-based-broadcast-chat" class="headerlink" title="20.7.2. AoI-based broadcast chat"></a><strong>20.7.2. AoI-based broadcast chat</strong></h4><h5 id="20-7-2-1-Requirements"><a href="#20-7-2-1-Requirements" class="headerlink" title="20.7.2.1. Requirements"></a><strong>20.7.2.1. Requirements</strong></h5><p>玩家需要能够在他们邻近的空间附近向玩家广播信息。</p>
<h5 id="20-7-2-2-Design"><a href="#20-7-2-2-Design" class="headerlink" title="20.7.2.2. Design"></a><strong>20.7.2.2. Design</strong></h5><p>基于AoI的聊天可以通过广播远程方法调用实现给在他们的AoI中有说话播放器的所有播放器实体。这并不需要在脚本中遍历所有实体，并且在CellApp上得到了有效的实现。chat方法调用使用与任何其他广播方法调用相同的机制广播给客户实体，或者当ALL_CLIENTS或OTHER_CLIENTS属性改变时。</p>
<p>可以为聊天方法调用指定易失性距离约束，这样只有初始玩家的特定半径内的玩家才能收到方法调用消息。</p>
<h4 id="20-7-3-Non-AoI-based-broadcast-chat"><a href="#20-7-3-Non-AoI-based-broadcast-chat" class="headerlink" title="20.7.3. Non-AoI-based broadcast chat"></a><strong>20.7.3. Non-AoI-based broadcast chat</strong></h4><h5 id="20-7-3-1-Requirements"><a href="#20-7-3-1-Requirements" class="headerlink" title="20.7.3.1. Requirements"></a><strong>20.7.3.1. Requirements</strong></h5><p>非基于aoi的聊天通道是不需要在相同空间位置的实体的聊天通道。这可以用于公会范围的聊天和世界范围的聊天。</p>
<h5 id="20-7-3-2-Design"><a href="#20-7-3-2-Design" class="headerlink" title="20.7.3.2. Design"></a><strong>20.7.3.2. Design</strong></h5><p>非基于aoi的通道可以实现为ChatChannel实体，它包含连接到该聊天通道的播放机的播放机邮箱列表。</p>
<p>当玩家想要连接到一个频道，一个频道查找被执行为特定的ChatChannel实体。这可以通过与上述玩家查找机制类似的机制来实现。一旦找到通道的邮箱，播放器将其基本邮箱注册到ChatChannel实体，该实体将其添加到连接的播放器邮箱列表中。</p>
<p>一个连接的播放器通过一个带有该频道内容的远程方法调用广播到该频道。ChatChannel实体负责广播该消息到每个连接的播放器基础邮箱。</p>
<h3 id="20-8-Mail"><a href="#20-8-Mail" class="headerlink" title="20.8. Mail"></a><strong>20.8. Mail</strong></h3><h4 id="20-8-1-Requirements"><a href="#20-8-1-Requirements" class="headerlink" title="20.8.1. Requirements"></a><strong>20.8.1. Requirements</strong></h4><p>每个玩家都必须有能力向其他玩家发送邮件。这封邮件包括一些文本和可选的游戏内项目。</p>
<h4 id="20-8-2-Design"><a href="#20-8-2-Design" class="headerlink" title="20.8.2. Design"></a><strong>20.8.2. Design</strong></h4><p>这里可以利用SMTP&#x2F;IMAP邮件服务器的可伸缩性。请注意，这些游戏邮件服务器完全是游戏内部的——不允许公众访问(尽管这取决于游戏设计)。</p>
<p>每个玩家都有一个相关的电子邮件地址。BaseApps可以使用BigWorld注册的TCP套接字异步查询IMAP服务器，而不会阻塞游戏脚本。Python很好地支持通过套接字与IMAP通信(参见<em>Non-Blocking Socket I&#x2F;O Using Mercury</em>)</p>
<p>道具可以使用特殊的附件或特殊的邮件标题赠送，这取决于所使用的道具系统。道具数据永远不会通过电子邮件直接发送，相反地，通过电子邮件赠送的道具将被托管，就像基于aoi的玩家道具交易一样。参见下面的库存和道具交易。</p>
<h3 id="20-9-Inventory-System"><a href="#20-9-Inventory-System" class="headerlink" title="20.9. Inventory System"></a><strong>20.9. Inventory System</strong></h3><h4 id="20-9-1-Requirements"><a href="#20-9-1-Requirements" class="headerlink" title="20.9.1. Requirements"></a><strong>20.9.1. Requirements</strong></h4><p>在相同空间附近的玩家实体必须能够协商交易他们所拥有的道具。</p>
<p>每个玩家向对方提出报价，将他们所提供的物品放在托管中。一旦双方玩家都接受对方玩家的提议，交易就成功了，物品就可以交易了。如果一名玩家取消交易，所有提供的道具将返还给各自的玩家。</p>
<p>物品买卖交易不得造成物品重复或物品丢失。</p>
<h4 id="20-10-2-Design"><a href="#20-10-2-Design" class="headerlink" title="20.10.2. Design"></a><strong>20.10.2. Design</strong></h4><p>BigWorld可以随时提供玩家AoI中任何玩家实体的基本邮箱。否则，如果与玩家AoI之外的特定人物进行交易，就需要玩家查找。</p>
<p>托管（Escrow）实体是在交易的整个生命周期中创建的，并持有两个实体的邮箱。托管实体持久化到数据库。贸易包括两个阶段，谈判阶段和转移阶段。托管实体在最少加载的BaseApp上创建。</p>
<p>谈判阶段是一系列从玩家实体到托管实体的报价操作，然后每个报价都被转发给对立的玩家实体。</p>
<p>如果服务器在事务中间停止，托管(Escrow)实体有足够的持久信息来在恢复时取消自己，并将项目返回给他们拥有的玩家实体。</p>
<p>服务器上的玩家实体以第三方托管实体的远程方法请求的形式向其他玩家提供道具(以响应来自他们的玩家客户端的GUI交互)。在此过程中，他们将这些道具从库存转移到服务器上的玩家实体的一个特殊存放区域。玩家的客户端不能以任何其他目的进入这个保存区域，除非将道具从当前的供应中移除，这样就会将道具移回他们的库存中。</p>
<p>每次从玩家库存转移到交易持有区都会导致:</p>
<ul>
<li>通过远程方法调用向托管实体提供的项目更改通知。</li>
<li>数据库写入托管实体。</li>
<li>从托管实体返回到原始播放器实体的确认远程方法调用。</li>
<li>从保存区域移除物品，并在数据库中写入玩家实体。</li>
</ul>
<p>如果由于某种原因(临时的或其他原因)，数据库写入失败，整个交易将被取消，道具将通过远程方法调用返回给玩家，玩家将通过远程方法调用返回到托管实体。当托管实体收到来自两个玩家的确认交易已经取消，它从数据库中删除自己。</p>
<p>每个玩家都可以向托管实体发出信号，表示愿意接受交易的现状。一旦托管实体收到双方的积极通知，它就会通过向玩家发送他们已经交易的道具数据，将道具所有权转移给相应的对手玩家。</p>
<ul>
<li>托管实体将所有权转移给每个玩家他们相应的交易道具。</li>
<li>在收到物品后，每个玩家开始写入数据库。当这被确认为OK时，玩家实体通过调用托管实体来承认他们拥有道具。</li>
<li>托管实体等待两个确认返回，然后销毁自己并从数据库中删除自己。</li>
</ul>
<p>总数据库写:每个报价2个，至少有2个报价。3为过渡阶段。</p>
<p>这说明，就磁盘写操作而言，交易可能是一种昂贵的操作。然而，所有的写操作都分布在相关的实体中，并且大多数会被写到辅助数据库中。当第三方托管实体被销毁时，只有一个数据库写操作会导致主数据库被使用，以便从持久存储中删除第三方托管实体。</p>
<p>请注意，交易事务中的每个参与实体不需要处于相同的进程中。这可以很好地扩展，因为可以有任意数量的BaseApps，玩家和托管实体将均匀分布在BaseApps中。回想一下，虽然CellApps有映射到它们所在空间的播放器分布，但BaseApps上的基本实体没有这种空间关系。</p>
<p>与每个托管实体的创建和销毁相关联的主数据库会有成本。这种设计可以通过合并托管操作来改进，以目标为预先存在的EscrowManager实体，而不是创建和销毁托管实体。一个类似的方案可以通过每个BaseApp有一个EscrowManager实体来实现PlayerRegistry实体。交易实体将提名并同意随机使用一个第三方托管管理器用于他们的交易交易。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/06/bigworld_05_02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Avatar.png">
      <meta itemprop="name" content="华">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keep Running">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Keep Running">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/11/06/bigworld_05_02/" class="post-title-link" itemprop="url">BIGWORLD 客户端编程指南02</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-11-06 11:20:31" itemprop="dateCreated datePublished" datetime="2024-11-06T11:20:31+08:00">2024-11-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-11-07 09:22:41" itemprop="dateModified" datetime="2022-11-07T09:22:41+08:00">2022-11-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/BigWorld/" itemprop="url" rel="index"><span itemprop="name">BigWorld</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="BIGWORLD-05-Client-Programming-Guide-02"><a href="#BIGWORLD-05-Client-Programming-Guide-02" class="headerlink" title="BIGWORLD_05_Client Programming Guide_02"></a>BIGWORLD_05_Client Programming Guide_02</h1><h2 id="11-Animation-System"><a href="#11-Animation-System" class="headerlink" title="11. Animation System"></a><strong>11. Animation System</strong></h2><p>BigWorld引擎中的动画系统结合了许多复杂的技术，可以通过一个易于使用的界面访问。该系统允许游戏开发者快速创建逼真的角色和环境。这一系统所解决的问题是将美工创造的原始内容整合到可信的动态游戏世界中。</p>
<p>使用3dsMax或Maya等设计工具的工作者可以创建模型和动画，然后使用BigWorld导出插件将它们导出为图形引擎可以理解的数据文件。</p>
<p>模型编辑器工具可以用来查看这些模型并回放动画。然后使用它从这些动画创建一个操作列表，这些动画是游戏引擎中python可访问的界面。</p>
<h3 id="11-1-Basic-keyframed-animations"><a href="#11-1-Basic-keyframed-animations" class="headerlink" title="11.1. Basic keyframed animations"></a><strong>11.1. Basic keyframed animations</strong></h3><p>一个对象在一段时间内的运动可以存储为一组关键帧，这些关键帧描述了一个对象(或一个对象的一部分)在不同时间点的位置、旋转和比例。然后将这些关键帧作为参考值，通过在关键帧数据之间插值来计算中间位置和旋转。</p>
<p>更真实的复杂对象被描述为表示骨骼层次结构的节点树。一个例子是一个简单的两足动物角色，其典型的层次结构如下所示:</p>
<p><img src="/image%5Cbigworld%5C05_06.png" alt="05_06"></p>
<p><em><span style='color:write;background:write;font-size:14px;'>典型的两足动物层次结构</span></em></p>
<p>每个节点表示一个对象的一个部分的空间状态。这些图形可以直接映射到渲染几何图形的刚性对象(如液压机器)，或作为用于更新皮肤网格的骨骼变换（每个几何图形顶点具有一组用于定义每个骨骼如何影响其移动的权重）。</p>
<h3 id="11-2-Animation-layering-and-blending"><a href="#11-2-Animation-layering-and-blending" class="headerlink" title="11.2. Animation layering and blending"></a><strong>11.2. Animation layering and blending</strong></h3><p>一个简单的动画，比如一个男人挥手，可能由整个骨骼树子集的关键帧数组组成，例如，仅用于Torso、UpperArmRight和LowerArmRight。</p>
<p>一个不同的动画的人行走可能只包括Torso和Pelvis树。这两个动画可以看作是整体运动的不同层次。在BigWorld框架中，这个分层是通过使用模型编辑器工具设置节点的alpha值来实现的，如下图所示:</p>
<p><img src="D:\笔记\image\bigworld\05_07.png" alt="05_07"></p>
<p>在引擎中，我们可以看到不同的图层在不同的动画轨道上播放，这将控制身体特定部位动画的停止和开始(通常将身体分成上下两部分，从而能够在游戏中顺畅且独立地处理动作)。</p>
<p>可以同时播放任意数量的动画，并使所产生的运动是所有动画的混合插值。这本质上是与关键帧插值相同的过程，因为我们正在插值位置、旋转和缩放数据。当不同的动画层需要合并成一个单一的运动时，重叠在不同轨道上的节点需要混合在一起。</p>
<p>动画之间的过渡可以通过创建所有可能的动画过渡来实现，并允许所有动画在开始一个新的动画之前完成它们的循环。</p>
<p>一种适应性更强和更健壮的方法是混合动画结束，并且在一段时间内混合开始动画。只要动画列表足够大，可以考虑到可能出现的不和谐的过渡。例如，除了站立和奔跑的动画，还包括行走和慢跑的动画，然后这个系统与优秀的动画相结合，在游戏角色中创造流畅的逼真行为。</p>
<h3 id="11-3-Animation-data-files"><a href="#11-3-Animation-data-files" class="headerlink" title="11.3. Animation data files"></a><strong>11.3. Animation data files</strong></h3><p>BigWorld导出输出以下数据文件(所有文件类型导出到资源树&lt;res&gt;):</p>
<ul>
<li><p>.visual 文件</p>
<p>定义对象的骨骼结构和材质数据。</p>
</li>
<li><p>.primitive 文件</p>
<p>定义蒙皮对象的顶点数据，如偏移量和权重值，并在适当的地方包含BSP数据。</p>
</li>
<li><p>.animation 文件</p>
<p>定义动画的关键帧数据。</p>
</li>
</ul>
<h3 id="11-4-Animation-data-streaming"><a href="#11-4-Animation-data-streaming" class="headerlink" title="11.4. Animation data streaming"></a><strong>11.4. Animation data streaming</strong></h3><p>动画数据以一系列块(block)的形式存储，这些块根据需要异步流到内存中。</p>
<p>所有这些块的总和被称为流块缓存，其大小受到限制，以防止过多的内存使用。要指定缓存的大小，在<engine_config>.xml中设置animation&#x2F;streamChacheSizeKB标签</p>
<p>Memory&#x2F;StreamedBlocks_CacheSize和Memory&#x2F;StreamedBlocks_CacheMaxSize两个监视器分别显示当前缓存大小和字节数限制。</p>
<h3 id="11-5-Actions"><a href="#11-5-Actions" class="headerlink" title="11.5. Actions"></a><strong>11.5. Actions</strong></h3><p>动作是一个将动画与游戏内的行为和事件联系起来的包装器对象。动作对象与动画对象所保存的信息不同，如下所述：</p>
<ul>
<li>动画对象(Animation object)<ul>
<li>原始关键帧数据。</li>
<li>帧速率信息。</li>
<li>关于如何在模型上发挥自己的功能。</li>
</ul>
</li>
<li>动作对象(Action object)<ul>
<li>混合时间信息。</li>
<li>关于动作是否为循环的信息。</li>
<li>关于动画是否为运动的信息。</li>
<li>动画匹配数据，指定特定对象状态值当一个动作被执行。</li>
</ul>
</li>
</ul>
<p>描述操作的原始数据以XML格式定义在.model文件中(位于&lt;res&gt;资源树下的各种子文件夹中，例如，&lt;res&gt;&#x2F;environments， &lt;res&gt;&#x2F;flora，&lt; res &gt; &#x2F;sets&#x2F;vehicles等…). .该数据是由Model Editor工具生成的。</p>
<p>有关详细信息，请参见<strong>Action Matcher</strong>。</p>
<h2 id="12-Integrating-With-BigWorld-Server"><a href="#12-Integrating-With-BigWorld-Server" class="headerlink" title="12. Integrating With BigWorld Server"></a><strong>12. Integrating With BigWorld Server</strong></h2><h3 id="12-1-Overview"><a href="#12-1-Overview" class="headerlink" title="12.1. Overview"></a><strong>12.1. Overview</strong></h3><p>本章介绍如何将任意客户端与BigWorld Server集成。</p>
<p>一个名为ProcessDefs的工具解析实体定义并生成c++代码，用于与使用相同实体定义的BigWorld服务器交互。实体行为可以用C语言实现或者可以编写glue代码来允许实体行为以另一种语言实现，例如Lua或Objective-C。通过生成包含通常从实体定义文件中读取的所有实体类型数据(方法调用和属性)的代码，这允许客户端应用程序不使用Python作为他们的游戏脚本语言。</p>
<p>要实现特定于实体的行为，可以对每个实体类型生成的存根类(stub class)进行扩展，以提供特定的行为，以响应来自服务器的方法调用请求或属性更新。所有实体类型通用的更多通用行为可以在派生自BWEntity的用户定义超类(superclass)中实现。</p>
<p><img src="/image%5Cbigworld%5C05_08.png" alt="05_08"></p>
<p>例如，上面的类图从一组实体定义中显示了一个名为Avatar的实体类型。代码生成器将为Avatar_Stub、CellMB::Avatar和BaseMB::Avatar类生成存根文件，这些类封装了访问属性和调用远程方法的所有访问器和成员。客户端上Avatar实体类型的具体实现在用户定义的中实现Avatar类(也生成了一个可以用作基础的模板)。</p>
<p>所有实体类必须有BWEntity作为它们继承的祖先超类(superclasses)之一，但它们也可以从一个用户定义的自定义类继承，该自定义类提供了所有实体类通用的一般游戏特定功能。例如，Avatar_Stub派生自MyEntity而不是上面的BWEntity，允许Avatar类使用从MyEntity继承的成员方法和数据。</p>
<p>连接库提供了c++类，可以用来连接和验证到BigWorld服务器。一旦连接，volatile数据，属性更新，方法调用就可以在客户端和服务器之间发送和接收。</p>
<h3 id="12-2-Generating-Code-With-the-ProcessDefs-tool"><a href="#12-2-Generating-Code-With-the-ProcessDefs-tool" class="headerlink" title="12.2. Generating Code With the ProcessDefs tool"></a><strong>12.2. Generating Code With the ProcessDefs tool</strong></h3><p>在最基本的级别上，ProcessDefs命令行工具解析一组实体定义文件，并调用Python模块中定义的处理函数，该函数具有表示已解析实体定义的数据结构。</p>
<p>默认情况下，它将使用ProcessDefs Python模块，该模块与process_defs可执行文件位于同一目录，该模块将实体定义输出到标准输出流并退出。</p>
<p>为了生成c++源文件，将使用提供的GenerateCPlusPlus模块。</p>
<p>所需的Python模块可以使用-m &#x2F;–module开关指定模块名。例如，对于选择GenerateCPlusPlus模块:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./process_defs -m GenerateCPlusPlus ...</span><br></pre></td></tr></table></figure>

<h4 id="12-2-1-ProcessDefs-x2F-GenerateCPlusPlus-Operation"><a href="#12-2-1-ProcessDefs-x2F-GenerateCPlusPlus-Operation" class="headerlink" title="12.2.1. ProcessDefs&#x2F;GenerateCPlusPlus Operation"></a><strong>12.2.1. ProcessDefs&#x2F;GenerateCPlusPlus Operation</strong></h4><p>使用–help开关运行process_defs可执行文件将提供一般选项，以及所选Python模块支持的模块特定选项列表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">$ ./process_defs -m GenerateCPlusPlus --help</span><br><span class="line">usage: process_defs [OPTION] scriptArgs</span><br><span class="line">This program parses the BigWorld entity definition files. A Python object is</span><br><span class="line">then created representing the entity descriptions. This is passed to a Python</span><br><span class="line">callback moduleName.functionName. By default, this is ProcessDefs.process.</span><br><span class="line">This module (ProcessDefs.py) should be placed in modulePath. This is the</span><br><span class="line">current working directory by default.</span><br><span class="line">Options:</span><br><span class="line"> -r directory 	 			 	 Specifies a resource path. Can be used</span><br><span class="line"> 								multiple times, in order of deccreasing</span><br><span class="line"> 								priority.</span><br><span class="line"> -f, --function funcName 		  The Python function to call. &quot;process&quot; by</span><br><span class="line"> 								default.</span><br><span class="line"> -m, --module moduleName 		  The Python module to load. &quot;ProcessDefs&quot;</span><br><span class="line"> 								by default.</span><br><span class="line"> -p, --path directory 			  The directory to find the module. Current </span><br><span class="line"> 								working directory by default.</span><br><span class="line"> -v, --verbose 					 Displays more verbose output.</span><br><span class="line"> -h, --help 					 Displays this message.</span><br><span class="line">Script Options:</span><br><span class="line"> -h, --help 					 show this help message and exit</span><br><span class="line"> -o FILE, --output=FILE</span><br><span class="line"> 								Directory to output generated files. Defaults to</span><br><span class="line"> 								&quot;GeneratedCPlusPlus&quot;.</span><br><span class="line"> --base-class-header=CLASS_NAME_INCLUDE_PATH</span><br><span class="line">                                   Path to a header file containing the declaration for</span><br><span class="line">                                   the base class for generated entity classes. Defaults</span><br><span class="line">                                   to &quot;connection/bw_entity.hpp&quot;.</span><br><span class="line"> -b CLASS_NAME, --base-class=CLASS_NAME</span><br><span class="line">                                   The base class for generated entity classes. Defaults</span><br><span class="line">                                   to &quot;BWEntity&quot;.</span><br><span class="line"> --generated-header-path=HEADERPATH</span><br><span class="line">                                   This indicates the directory of where to find the</span><br><span class="line">                                   generated sources, and is used for generating the</span><br><span class="line">                                   #include lines for generated headers. Defaults to</span><br><span class="line">                                   &quot;GeneratedEntities&quot;.</span><br><span class="line"> --entity-header-path=HEADERPATH</span><br><span class="line">                                   This indicates the directory of where to find your</span><br><span class="line">                                   entity class header files, and is used for generating</span><br><span class="line">                                   the #include lines for entity header files. Defaults</span><br><span class="line">                                   to &quot;Entities&quot;</span><br><span class="line"> --entity-template-source-extension=EXT</span><br><span class="line">                                   Specifies the extension suffix given to generated</span><br><span class="line">                                   entity stub and template C++ source files. Defaults to</span><br></pre></td></tr></table></figure>

<p>可以使用- r选项指定资源目录，后面跟着资源目录的路径。如果指定多个目录，可以多次使用该选项，按照优先级递减的顺序指定资源路径。通常，bigworld&#x2F;res目录被指定为最后一个资源路径。</p>
<p>通常，生成的源代码作为更大项目的一部分进行编译，并放置在项目目录结构中自己的目录中。您可以使用ProcessDefs工具通过使用-o &#x2F;–output命令行选项直接编译到它们的目标目录。</p>
<p>…</p>
<h4 id="12-2-2-Generating-C-Code"><a href="#12-2-2-Generating-C-Code" class="headerlink" title="12.2.2. Generating C++ Code"></a><strong>12.2.2. Generating C++ Code</strong></h4><p>GenerateCPlusPlus模块接受实体定义描述符对象，并写出几个生成的文件，这些文件可用于连接到运行相同实体定义的服务器。</p>
<p>对于每个实体类型，GenerateCPlusPlus模块将生成一个存根类，该类将实体类型名称合并到类名中。这个存根类实现了实体属性流和客户端方法分派。</p>
<p>如果需要，GenerateCPlusPlus模块还将生成用于调用服务器端远程方法的远程实体类(如果它们在实体类型的定义文件中定义)。</p>
<ul>
<li><p><em>Entity</em>_Stub.hpp and <em>Entity</em>_Stub.cpp</p>
<p>Avatar_Stub类间接派生自BWEntity，并包含属性成员变量和访问器，以及为其每个从服务器端填充的属性成员实现流操作符。</p>
<p>它通过ServerEntityMailBox子类包含对单元格和单元格(如果适用)的访问器，该子类包含调用在实体定义中声明的远程基方法和单元方法的方法。</p>
<p>它包含可以从服务器端远程调用的客户端方法的纯虚方法声明。</p>
<p>具体的Avatar类直接从Avatar_Stub派生，并实现纯虚拟方法，继承属性访问器以及基和单元远程实体句柄。</p>
</li>
<li><p><em>Entity</em>_CellMB.hpp and <em>Entity</em>_CellMB.cpp</p>
<p>Avatar类实现了从客户端到服务器端的单元实体的远程方法调用。如果Avatar实体类型的实体定义没有声明任何公开的CellMethods，那么这可能是不可用的。</p>
</li>
<li><p><em>Entity</em>_BaseMB.hpp and <em>Entity</em>_BaseMB.cpp</p>
<p>Avatar类实现了从客户端到服务器端基本实体的远程方法调用。如果Avatar实体类型的实体定义没有声明任何公开的basemethod，那么这可能不可用</p>
</li>
<li><p><em>Entity</em>.hpp and <em>Entity</em>.cpp</p>
<p>还将生成具体的Avatar实体类的模板，该模板可以用作实际具体Avatar实体类实现的基础。它提供了所需的客户端方法和属性setter回调的空实现。这些具体的实体模板源位于输出目录的一个子目录中，名为templates。</p>
</li>
</ul>
<p>GenerateCPlusPlus模块还将输出几个通用的源文件，如下所示:</p>
<ul>
<li><p>DefsDigest.hpp and DefsDigest.cpp</p>
<p>DefsDigest命名空间包含一个方法，该方法返回实体定义摘要的字符串值。当登录到服务器以验证服务器实体定义是否匹配客户端的实体定义时，使用此摘要值。</p>
</li>
<li><p>EntityFactory.hpp and EntityFactory.cpp</p>
<p>EntityFactory类实现了BWEntityFactory接口，并创建了一个新的BWEntity实例，该实例的名称与给定实体类型ID所引用的实体类型相同(例如，Account类用于Account实体类型)。</p>
</li>
<li><p>GeneratedTypes.hpp and GeneratedTypes.cpp</p>
<p>此头文件和源文件描述从FIXED_DICT数据类型派生而来的生成类型。它们在FIXED_DICT数据类型的定义中被标记，它们要么出现在scripts&#x2F;entity_defs&#x2F;alias.xml文件中，要么出现在使用&lt;Label&gt;标记，以便为该FIXED_DICT类型生成的类命名。例如:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">InventoryEntry</span>&gt;</span> FIXED_DICT</span><br><span class="line">        <span class="tag">&lt;<span class="name">TypeName</span>&gt;</span> InventoryEntry <span class="tag">&lt;/<span class="name">TypeName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">itemType</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Type</span>&gt;</span> ITEMTYPE <span class="tag">&lt;/<span class="name">Type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">itemType</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">serial</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Type</span>&gt;</span> ITEMSERIAL <span class="tag">&lt;/<span class="name">Type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">serial</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">lockHandle</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Type</span>&gt;</span> LOCKHANDLE <span class="tag">&lt;/<span class="name">Type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">lockHandle</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">InventoryEntry</span>&gt;</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>上面的示例将生成一个名为InventoryEntry的类，并将其用作存根类中成员数据的类型，而存根类中的实体类型将InventoryEntry类型作为其客户端可见属性之一的类型。</p>
<p>标记所有FIXED_DICT类型非常重要，因为如果不这样做，将会导致问题，因为分配给未标记FIXED_DICT类型的任意数字标签(例如，FixedDict0、FixedDict1等)。如果解析顺序发生了变化，那么引用那些未标记FIXED_DICT类型的实体源文件可能会在新的解析顺序中引用不正确的类型，从而在使用子属性访问器时导致编译错误。</p>
</li>
</ul>
<h3 id="12-3-Customising-ProcessDefs-Output"><a href="#12-3-Customising-ProcessDefs-Output" class="headerlink" title="12.3. Customising ProcessDefs Output"></a><strong>12.3. Customising ProcessDefs Output</strong></h3><p>可能有必要改变生成的代码输出，以便根据特定的游戏开发需求定制它。这可以通过修改GenerateCPlusPlus模块用于生成源代码的模板来完成，或者为ProcessDefs工具实现一个全新的处理模块。</p>
<h4 id="12-3-1-Modifying-the-Generated-Code-Templates"><a href="#12-3-1-Modifying-the-Generated-Code-Templates" class="headerlink" title="12.3.1. Modifying the Generated Code Templates"></a><strong>12.3.1. Modifying the Generated Code Templates</strong></h4><p>GenerateCPlusPlus模块使用提供的jina2 Python模板库来生成代码。jinja模板位于模块目录中名为templates的目录下。使用的模板有:</p>
<ul>
<li><p>DefsDigest.hpp and DefsDigest.cpp</p>
<p>用于生成定义摘要访问器函数( digest accessor)的模板。</p>
</li>
<li><p>EntityFactory.hpp and EntityFactory.cpp</p>
<p>用于生成实体工厂类的模板。</p>
</li>
<li><p>EntityMailBoxTemplate.hpp and EntityMailBoxTemplate.cpp</p>
<p>用于生成基本邮箱和单元邮箱对象的模板，用于调用服务器端远程方法。</p>
</li>
<li><p>EntityStubTemplate.hpp and EntityStubTemplate.cpp</p>
<p>用于生成实现客户端实体方法分派和客户端实体属性流功能的实体存根类的模板。</p>
</li>
<li><p>EntityTemplate.hpp and EntityTemplate.cpp</p>
<p>用于生成空实体类模板的模板。</p>
</li>
<li><p>GeneratedTypes.hpp and GeneratedTypes.cpp</p>
<p>用于生成FIXED_DICT等效类型的模板。</p>
</li>
</ul>
<h4 id="12-3-2-Implementing-a-New-Processing-Module"><a href="#12-3-2-Implementing-a-New-Processing-Module" class="headerlink" title="12.3.2. Implementing a New Processing Module"></a><strong>12.3.2. Implementing a New Processing Module</strong></h4><p>对于代码生成过程的最终控制，一个新的处理模块可以与ProcessDefs一起使用。</p>
<p>每个ProcessDefs处理模块实现一个函数，该函数传递一个数据结构，该数据结构描述了由ProcessDefs解析的实体定义。默认情况下，函数名为process();ProcessDefs上的命令行选项可以更改调用哪个模块函数。</p>
<p>传递给处理函数的数据结构是一个Python字典，其键值如下:</p>
<ul>
<li>constants</li>
</ul>
<p>  这是一个用于连接到服务器的常量字典。特别是，它包含：</p>
<ul>
<li><p>digest</p>
<p>该值是实体定义摘要的字符串，用于验证客户端资源与服务器上的资源是否一致。</p>
</li>
<li><p>maxClientServerPropertyCount</p>
<p>此值是跨所有实体类型的客户机-服务器属性的最大计数。</p>
</li>
<li><p>maxExposedBaseMethodCount</p>
<p>此值是所有实体类型公开的基方法的最大计数。</p>
</li>
<li><p>maxExposedCellMethodCount</p>
<p>此值是跨所有实体类型公开的单元格方法的最大计数。</p>
</li>
<li><p>maxExposedClientMethodCount</p>
<p>此值是跨所有实体类型的客户端方法的最大计数。</p>
</li>
<li><p>entityTypes</p>
<p>该值是一个字典对象序列，每个对象描述一个实体类型。每个实体类型字典有以下键:</p>
<ul>
<li><p>clientMethods</p>
<p>这个值包含一个字典序列，描述这个实体类型的每个客户端方法。</p>
</li>
<li><p>baseMethods</p>
<p>该值包含一个字典序列，描述此实体类型的每个基本方法。</p>
</li>
<li><p>cellMethods</p>
<p>此值包含一个字典序列，描述此实体类型的每个单元格方法。</p>
</li>
<li><p>allProperties</p>
<p>此值包含所有属性的属性描述字典序列。</p>
</li>
<li><p>clientProperties</p>
<p>此值包含从服务器传播的所有客户端属性的属性描述字典序列。</p>
</li>
<li><p>baseToClientProperties</p>
<p>这个值包含BASE_AND_CLIENT属性的属性描述字典序列。</p>
</li>
<li><p>cellToClientProperties</p>
<p>这个值包含一个OWN_CLIENT, OTHER_CLIENT和ALL_CLIENT属性的属性描述字典序列。</p>
</li>
</ul>
<p>每个方法描述字典对象包含以下键:</p>
<ul>
<li><p>name</p>
<p>属性的名称。</p>
</li>
<li><p>index</p>
<p>属性的索引——只对调试重要。</p>
</li>
<li><p>clientServerFullIndex</p>
<p>用于在服务器和客户机之间的通信中标识此属性的属性的索引。</p>
</li>
<li><p>isGhostedData</p>
<p>ALL_CLIENTS, OTHER_CLIENTS或CELL_PUBLIC属性将此值设置为True，否则为False。</p>
</li>
<li><p>isOtherClientData</p>
<p>ALL_CLIENTS和OTHER_CLIENTS属性将此值设置为True，否则为False。</p>
</li>
<li><p>isOwnClientData</p>
<p>OWN_CLIENT属性将此值设置为True，否则为False</p>
</li>
<li><p>isCellData</p>
<p>ALL_CLIENT, OWN_CLIENTS, OTHER_CLIENTS, CELL_PRIVATE和CELL_PUBLIC属性的值设置为True，否则为False。</p>
</li>
<li><p>isBaseData</p>
<p>BASE和BASE_AND_CLIENT属性将此值设置为True，否则为False。</p>
</li>
<li><p>isClientServerData</p>
<p>BASE_AND_CLIENT, ALL_CLIENTS, OTHER_CLIENTS, OWN_CLIENT属性将此值设置为True，否则为False。</p>
</li>
<li><p>isPersintent</p>
<p>如果这是一个持久(persitent)属性，该值设置为True，否则为False。</p>
</li>
<li><p>isIdentifier</p>
<p>如果此属性是其实体类型的标识符属性，则该值设置为True，否则为False。</p>
</li>
<li><p>isIndexed</p>
<p>如果在数据库中索引了此属性，则该值设置为True，否则为False。</p>
</li>
<li><p>isUnique</p>
<p>如果此属性在数据库中标记为唯一，则该值设置为True，否则为False。</p>
</li>
</ul>
</li>
</ul>
<h3 id="12-4-The-connection-model-Library"><a href="#12-4-The-connection-model-Library" class="headerlink" title="12.4. The connection_model  Library"></a><strong>12.4. The</strong> <strong>connection_model</strong>  <strong>Library</strong></h3><p>connection_model库包含用于连接到BigWorld服务器的类。它使用较低级的连接库。</p>
<p>BWConnecton类包含连接BigWorld服务器的大部分功能，并提供了连接的简单API。连接是异步执行的，并要求经常点击连接对象（通常是每次游戏点击一次），以处理来自网络的事件。</p>
<p>BWEntity类是实体类型的基类。通常，一个特定的游戏将有自己的基类来扩展BWEntity类，然后每个实体类型将进一步从BWEntity派生的基类中派生，以实现特定于实体类型的行为。</p>
<p>例如，sdl客户端(位于bigworld&#x2F;src&#x2F;examples&#x2F;c_plus_plus&#x2F;sdl)包含一个MyEntity类，它派生自BWEntity。Account实体类派生自MyEntity。</p>
<p>当构造BWConnection实例时，需要一个实现BWEntityFactory接口的类。这个工厂负责根据服务器发送的实体类型ID创建一个新的BWEntity实例。实体类型ID反映了特定实体类型在entities.xml文件中出现的顺序。</p>
<p>当使用代码生成时，将生成一个BWEntityFactory的子类，其中包含实例化特定的BWEntity类的逻辑，该类以实体类型ID标识的实体类型命名。</p>
<h4 id="12-4-1-Dependencies"><a href="#12-4-1-Dependencies" class="headerlink" title="12.4.1. Dependencies"></a><strong>12.4.1. Dependencies</strong></h4><p>connection_model库依赖于:</p>
<ul>
<li>conneciton,用于连接到服务器的低级类和接口。</li>
<li>cstdmf,在BigWorld中使用的一个通用实用程序库。</li>
<li>network,一个用于实现Mercury协议的网络库。</li>
<li>math,一个普通的数学库。</li>
<li>OpenSSL库</li>
</ul>
<h4 id="12-4-2-BWConnection"><a href="#12-4-2-BWConnection" class="headerlink" title="12.4.2. BWConnection"></a><strong>12.4.2. BWConnection</strong></h4><p>这个类表示到服务器的连接。BWConnection类的简单接口允许应用程序连接到服务器，并用位置和方向数据、属性更新和远程方法调用处理填充BWEntity对象。</p>
<h5 id="12-4-2-1-LoginApp-Public-Key"><a href="#12-4-2-1-LoginApp-Public-Key" class="headerlink" title="12.4.2.1. LoginApp Public Key"></a><strong>12.4.2.1. LoginApp Public Key</strong></h5><p>为了与服务器通信，必须在连接对象上配置和设置用于加密服务器登录详细信息的公钥。这是通过调用setLoginAppPublicKeyString()或setLoginAppPublicKeyPath()方法来完成的。</p>
<p>setLoginAppPublicKeyString()方法根据包含公钥的字符串设置LoginApp公钥。例如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> g_publicKeyString[] = <span class="string">&quot;-----BEGIN PUBLIC KEY-----\n&quot;</span> \</span><br><span class="line"><span class="string">&quot;MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA7/MNyWDdFpXhpFTO9LHz\n&quot;</span> \</span><br><span class="line"><span class="string">&quot;CUQPYv2YP5rqJjUoxAFa3uKiPKbRvVFjUQ9lGHyjCmtixBbBqCTvDWu6Zh9Imu3x\n&quot;</span> \</span><br><span class="line"><span class="string">&quot;KgCJh6NPSkddH3l+C+51FNtu3dGntbSLWuwi6Au1ErNpySpdx+Le7YEcFviY/ClZ\n&quot;</span> \</span><br><span class="line"><span class="string">&quot;ayvVdA0tcb5NVJ4Axu13NvsuOUMqHxzCZRXCe6nyp6phFP2dQQZj8QZp0VsMFvhh\n&quot;</span> \</span><br><span class="line"><span class="string">&quot;MsZ4srdFLG0sd8qliYzSqIyEQkwO8TQleHzfYYZ90wPTCOvMnMe5+zCH0iPJMisP\n&quot;</span> \</span><br><span class="line"><span class="string">&quot;YB60u6lK9cvDEeuhPH95TPpzLNUFgmQIu9FU8PkcKA53bj0LWZR7v86Oco6vFg6V\n&quot;</span> \</span><br><span class="line"><span class="string">&quot;sQIDAQAB\n&quot;</span></span><br><span class="line"><span class="string">&quot;-----END PUBLIC KEY-----\n&quot;</span></span><br><span class="line">BWConnection <span class="built_in">connection</span>( ... );</span><br><span class="line">connection.<span class="built_in">setLoginAppPublicKeyString</span>( g_publicKeyString );</span><br></pre></td></tr></table></figure>

<p>setLoginAppPublicKeyPath()方法根据位于给定路径的文件设置LoginApp公钥。路径本身是一个普通的文件系统路径;它没有通过资源文件系统解析。</p>
<p>有关客户端和服务器之间使用的加密的更多信息，请参阅加 <em>Encrypting Client-Server Traffic</em>。</p>
<h5 id="12-4-2-2-Entity-Definitions-Digest"><a href="#12-4-2-2-Entity-Definitions-Digest" class="headerlink" title="12.4.2.2. Entity Definitions Digest"></a><strong>12.4.2.2. Entity Definitions Digest</strong></h5><p>为了让方法和属性能够通过网络传输，客户端和服务器之间的实体定义必须是相同的。为了防止不一致的实体定义，服务器和客户端接受实体定义的摘要，并且客户端在登录时发送其摘要，以便与服务器进行比较。</p>
<p>BWConnection对象要求使用setDigest()方法设置摘要。</p>
<p>当使用ProcessDefs&#x2F;GenerateCPlusPlus生成代码时，会生成函数DefsDigest::constants()，它返回一个常量对象，其中包含定义摘要字符串，以及其他对流属性和方法很重要的常量。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GeneratedSource/DefsDigest.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;connection/bw_connection.hpp&quot;</span></span></span><br><span class="line">...</span><br><span class="line"> BWConnection * pConnection = <span class="keyword">new</span> <span class="built_in">Connection</span>( *pEntityFactory,</span><br><span class="line"> DefsDigest::<span class="built_in">constants</span>() );</span><br></pre></td></tr></table></figure>

<h5 id="12-4-2-3-Ticking-the-Connection-Instance"><a href="#12-4-2-3-Ticking-the-Connection-Instance" class="headerlink" title="12.4.2.3. Ticking the Connection Instance"></a><strong>12.4.2.3. Ticking the Connection Instance</strong></h5><p>客户端通常会有一个渲染循环，在每一帧中进行渲染。作为每一帧的一部分BWConnection实例应该定期勾选，定期调用BWConnection::update()方法。</p>
<p>update()方法要求传入自上次更新以来所经过的时间。</p>
<p>在某些框架下，可以设置计时器来调用update()。例如，在iOS下的Apple Objective-C中，NSTimer可用于定期勾选连接实例。Cocos2D也有类似的计时器。</p>
<h5 id="12-4-2-4-Logging-Into-a-Server"><a href="#12-4-2-4-Logging-Into-a-Server" class="headerlink" title="12.4.2.4. Logging Into a Server"></a><strong>12.4.2.4. Logging Into a Server</strong></h5><p>在设置了LoginApp公钥之后，实体定义摘要并勾选连接实例，可以通过使用logOnTo()方法登录到服务器来启动连接。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::string serverAddress = <span class="string">&quot;10.1.1.1&quot;</span>;</span><br><span class="line">std::sttring username = <span class="string">&quot;MyUser&quot;</span>;</span><br><span class="line">std::string password = <span class="string">&quot;pass&quot;</span>;</span><br><span class="line">pConnection-&gt;<span class="built_in">logOnTo</span>( serverAddress, username, password );</span><br></pre></td></tr></table></figure>

<p>serverAddress字符串参数指定要连接的地址和端口。如果未指定端口，则默认为20013。要指定端口，使用<ip_address>:&lt;port&gt;格式。</p>
<p>可以通过在连接上设置ServerConnectionHandler对象来处理登录成功、失败和断开连接事件。连接库中的ServerConnectionHandler接口允许您捕捉以下事件:</p>
<ul>
<li><p>onLoggedOn()</p>
<p>当连接尝试成功时调用。</p>
</li>
<li><p>onLoggedOff()</p>
<p>当连接已断开时调用。</p>
</li>
<li><p>onLogOnFailure()</p>
<p>当连接尝试失败时调用。字符串错误消息作为参数提供。</p>
</li>
</ul>
<p>可以在调用logOnTo()之前在连接对象上设置处理程序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyConnectionHandler handler;</span><br><span class="line">pConnection-&gt;<span class="built_in">setHandler</span>( &amp;handler );</span><br></pre></td></tr></table></figure>

<h4 id="12-4-3-BWEntity"><a href="#12-4-3-BWEntity" class="headerlink" title="12.4.3. BWEntity"></a><strong>12.4.3. BWEntity</strong></h4><p>BWEntity类是所有实体类的超类(superclass)。BWEntity类的实例是使用在构造时向BWConnection注册的BWEntityFactory实例创建的。</p>
<h5 id="12-4-3-1-Avatar-Filtering"><a href="#12-4-3-1-Avatar-Filtering" class="headerlink" title="12.4.3.1. Avatar Filtering"></a><strong>12.4.3.1. Avatar Filtering</strong></h5><p>每当从服务器接收到位置和方向数据时，每个BWEntity实例都可以有一个关联的过滤器对象。然后，这个过滤器对象用于根据从服务器接收到的输入输出每帧的位置和方向。</p>
<p>可以使用预定义的过滤器，例如AvatarFilter类，它是用于基于windows的BWClient中的大多数实体的通用过滤器。您可以通过调用pFilter()方法简单地初始化实体的过滤器对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MyEntity::<span class="built_in">MyEntity</span>() :</span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line"> <span class="keyword">this</span>-&gt;<span class="built_in">pFilter</span>( <span class="keyword">new</span> <span class="built_in">AvatarFilter</span>( environment ) );</span><br></pre></td></tr></table></figure>

<p>在构造FilterBase子类时需要一个筛选环境对象(派生自FilterEnvironment接口类)。这通常是特定于引擎的，所以每个特定的游戏引擎都需要一个特定的FilterEnvironment。</p>
<p>FilterEnvironment(可以在连接库中找到)实现了这些虚方法:</p>
<ul>
<li><p>void updateCoordinateSystem( EntityBase * pEntity, SpaceID spaceID, EntityID</p>
<p>vehicleID )</p>
<p>每当实体改变了它的坐标系统时，这个方法就会被调用，通常是通过上车或下车车辆。当玩家实体传送和改变空间时，它也会被调用。此方法用于对传入实体执行任何统计(bookkeeping)，以支持新的更新坐标空间，以及处理车辆(vehicle)更改。</p>
</li>
<li><p>void transformIntoCommon( SpaceID spaceID, EntityID vehicleID, Position3D &amp;</p>
<p>position, Vector3 &amp; direction ) or </p>
<p>void transformFromCommon( SpaceID spaceID, EntityID vehicleID, Position3D &amp;</p>
<p>position, Vector3 &amp; direction )</p>
<p>这两种方法用于将车辆空间(vehicle-space)坐标转换为通用世界空间坐标。</p>
</li>
<li><p>bool filterDropPoint( EntityBase * pEntity, const Position3D &amp; fall, Position3D</p>
<p>&amp; land, Vector3 * pGroundNormal )</p>
<p>这种方法用于在场景中最近的地形或其他障碍上获得下降位置。如果接地法线是非null，它也应该在pGroundNormal参数中提供。</p>
</li>
<li><p>bool resolveOnGroundPosition( Position3D &amp; position, bool &amp; isOnGround )</p>
</li>
</ul>
<p>  这种方法被用来确定一个特定的点是否可以被认为是“地面”。这是用来优化客户端和服务器之间的网络通信，如果双方都同意一个玩家实体在地面上，因为这允许在发送中省略y位置。</p>
<p>为了创建新的过滤器，可以实现FilterBase接口类的新子类。每个filter对象都需要实现以下方法:</p>
<ul>
<li><p>void input( double time, SpaceID spaceID, EntityID vehicleID, const Position3D</p>
<p>&amp; position, const Vector3 &amp; positionError, float * auxFiltered )</p>
<p>调用此方法来接收来自服务器的特定于特定时间的位置和方向更新。auxFiltered参数指向一个包含偏航、俯仰和横摇(yaw,pitch,roll)的3个元素的数组。</p>
</li>
<li><p>void output( double time )</p>
</li>
</ul>
<p>  调用此方法来设置在给定时间内实体的位置和方向的最佳估计。这通常在视觉渲染前调用每一帧来设置实体位置。</p>
<ul>
<li><p>void reset()</p>
<p>当需要重置筛选器状态时，调用此方法。这通常是当一个实体第一次进入感兴趣的领域，或当它已经传送。</p>
</li>
<li><p>void getLastInput()</p>
<p>调用此方法来检索从服务器接收到的最后一个输入。</p>
</li>
</ul>
<h4 id="12-4-4-BWEntityFactory"><a href="#12-4-4-BWEntityFactory" class="headerlink" title="12.4.4. BWEntityFactory"></a><strong>12.4.4. BWEntityFactory</strong></h4><p>BWEntityFactory接口类的子类负责创建与给创建方法的实体类型ID相匹配的BWEntity实例。</p>
<p>生成的代码将包括一个实现BWEntityFactory的具体类，称为EntityFactory，它创建适当的具体BWEntity类，具有与实体类型名称相同的名称。</p>
<p>构造BWConnection实例需要一个BWEntityFactory实例。</p>
<h4 id="12-4-5-BWEntitiesListener"><a href="#12-4-5-BWEntitiesListener" class="headerlink" title="12.4.5. BWEntitiesListener"></a><strong>12.4.5. BWEntitiesListener</strong></h4><p>当玩家进入一个空间时，该空间中的实体将进入或离开客户端感兴趣的区域，当发生这种情况时服务器将通知客户端。当这种情况发生时，捕获它是有用的，因此BWConnection允许注册一个BWEntitiesListener对象来接收实体进入和离开事件。</p>
<p>BWEntitiesListener子类实现了以下方法:</p>
<ul>
<li><p>void onEntityEnter( BWEntity * pEntity )</p>
<p>当实体进入客户端的AoI时，将调用此函数。</p>
</li>
<li><p>void onEntityLeave( BWEntity * pEntity )</p>
<p>当离开进入客户端的AoI时，将调用此函数。</p>
</li>
</ul>
<h4 id="12-4-6-Server-Discovery"><a href="#12-4-6-Server-Discovery" class="headerlink" title="12.4.6. Server Discovery"></a><strong>12.4.6. Server Discovery</strong></h4><p>服务器发现用于在开发过程中找到同一LAN段上本地运行的服务器，并获取启动连接的详细信息。它不打算用于生产客户端。</p>
<p>抽象ServerFinder类的一个子类用于此目的。通过实现ServerFinder的一个新的具体子类，实例化它并将其传递给BWConnection的findServers()方法，将执行对本地运行服务器的搜索。findServers()中的timeout参数可用于设置搜索的超时时间;默认为10秒。</p>
<p> 当找到服务器、搜索完成或超时时，将调用虚方法回调。ServerFinder的子类应该实现以下方法:</p>
<ul>
<li><p>onServerFound() </p>
<p>在找到单个服务器时调用。它传递一个ServerInfo对象，该对象包含连接的地址和端口，以及运行服务器的用户的Unix用户ID。</p>
</li>
<li><p>onFinished()</p>
<p>在搜索过程成功完成时调用。</p>
</li>
<li><p>onRelease() </p>
<p>在搜索完成或搜索超时时调用。这通常用于清理对象。</p>
</li>
</ul>
<h5 id="12-4-6-1-Probing-a-Running-Server"><a href="#12-4-6-1-Probing-a-Running-Server" class="headerlink" title="12.4.6.1. Probing a Running Server"></a><strong>12.4.6.1. Probing a Running Server</strong></h5><p>来自ServerFinder的信息只提供要传递的数字地址和端口</p>
<p>ServerFinder中的信息只提供了要传递给BWConnection::logOnTo()的数字地址和端口，以及运行服务器实例的用户的数字Unix用户ID。可以探测服务器以提供更多信息，例如运行LoginApp的机器的名称，以及运行服务器的用户的用户名。这可以通过使用ServerFinder的sendProbe()方法发送一个服务器探测来完成。</p>
<p>服务器探测结果由ServerProbeHandler接口类的子类处理。要实现的相关虚拟方法有:</p>
<ul>
<li><p>onKeyValue()</p>
<p>这用于获取探测中特定键值结果的结果。键是:</p>
<ul>
<li><p>hostName</p>
<p>LoginApp机器的名称。</p>
</li>
<li><p>ownerName</p>
<p>运行服务器实例的用户名。</p>
</li>
<li><p>userCount</p>
<p>这个LoginApp处理的成功登录的次数</p>
</li>
<li><p>universeName</p>
<p>未使用，用于向后兼容</p>
</li>
<li><p>spaceName</p>
<p>未使用，用于向后兼容</p>
</li>
<li><p>binaryID</p>
<p>未使用，用于向后兼容</p>
</li>
</ul>
</li>
<li><p>onSuccess()</p>
<p>当探测成功完成时，调用这个函数。</p>
</li>
<li><p>onFailure()</p>
<p>当探测超时或以其他方式失败时，将调用此函数。</p>
</li>
<li><p>onFinished()</p>
<p>该方法在调用onSuccess()或onFailure()之后被调用，应该用于清除探测处理程序对象。</p>
</li>
</ul>
<h3 id="12-5-Example-Clients"><a href="#12-5-Example-Clients" class="headerlink" title="12.5. Example Clients"></a><strong>12.5. Example Clients</strong></h3><p>BigWorld提供了示例源代码，演示如何从其他客户端应用程序集成BigWorld服务器。这些示例客户机可以在bigworld&#x2F;src&#x2F;examples&#x2F;client_integration目录中找到。</p>
<h3 id="12-5-1-python-x2F-simple"><a href="#12-5-1-python-x2F-simple" class="headerlink" title="12.5.1. python&#x2F;simple"></a><strong>12.5.1. python&#x2F;simple</strong></h3><p>这个示例客户端是一个连接到BigWorld服务器的基本应用程序，它演示了连接到服务器并发送玩家移动所需的最小工作量，以及如何将属性更新应用到基于python的实体。</p>
<p>此示例可在Linux和Windows下编译。</p>
<h4 id="12-5-2-c-plus-plus-x2F-sdl"><a href="#12-5-2-c-plus-plus-x2F-sdl" class="headerlink" title="12.5.2. c_plus_plus&#x2F;sdl"></a><strong>12.5.2. c_plus_plus&#x2F;sdl</strong></h4><p>DL的例子是一个简单的客户端，它提供了一个使用simple Directmedia Library (<a target="_blank" rel="noopener" href="http://www.libsdl.org)来连接到fantasydemo服务器的自顶向下gui./">http://www.libsdl.org)来连接到FantasyDemo服务器的自顶向下GUI。</a></p>
<p>它使用ProcessDefs工具生成实体代码。</p>
<p>这个例子可以在Linux和Mac OS x下编译。它需要SDL和SDL_image库。</p>
<p>在CentOS Linux下，可以通过安装SDL-devel和SDL_image-devel包来安装这些库。</p>
<p>SDL和SDL_image的Mac OS X框架库以及如何安装它们的说明可以在SDL站点上找到。</p>
<p>为了运行这个例子，需要在命令行上指定FantasyDemo的资源路径以及服务器地址，例如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./client_integration -r ../../../../fantasydemo/res -r ../../../res -s</span><br><span class="line"> localhost</span><br></pre></td></tr></table></figure>

<p>当在Xcode下运行时，你需要在client_integration方案中设置这些命令行参数Run→arguments→启动时传递的参数。</p>
<h4 id="12-5-3-c-plus-plus-x2F-ios"><a href="#12-5-3-c-plus-plus-x2F-ios" class="headerlink" title="12.5.3. c_plus_plus&#x2F;ios"></a><strong>12.5.3. c_plus_plus&#x2F;ios</strong></h4><p>这个例子是一个连接到FantasyDemo服务器的简单iOS客户端，提供了一个自上而下的GUI来可视化客户端感兴趣的区域。</p>
<p>项目文件位于bigworld&#x2F;src&#x2F;examples&#x2F;client_integration&#x2F;c_plus_plus&#x2F;ios&#x2F;FantasyDemo.xcodeproj。它需要XCode 4.3及以上版本，并安装可选的XCode命令行工具。要安装，请转到Preferences→Downloads→Components，并安装命令行工具组件。</p>
<h2 id="13-Server-Communications"><a href="#13-Server-Communications" class="headerlink" title="13. Server Communications"></a><strong>13. Server Communications</strong></h2><p>与服务器的通信使用基于udp的底层协议Mercury。在“服务器概述”一节“进程间通信(Mercury)”中详细描述了Mercury。</p>
<p>服务器通信可以通过c++和Python脚本访问</p>
<h3 id="13-1-Login"><a href="#13-1-Login" class="headerlink" title="13.1. Login"></a><strong>13.1. Login</strong></h3><p>登录时，客户端使用Mercury向登录服务器发送UDP报文，使用知名端口。报文中包含客户端进行身份验证时所需要的所有帐号和字符信息，并选择一个字符。</p>
<p>如果登录成功，登录服务器将为角色添加一个实体到BigWorld服务器系统，并将客户端指向代理服务器，代理服务器将处理所有游戏内的通信。然后双方开始互相发送数据。有关登录过程的更多详细信息，请参见Server Overview’s section <em>Design Introduction</em> → “Use Cases” → “Logging In”.</p>
<h3 id="13-2-Online"><a href="#13-2-Online" class="headerlink" title="13.2. Online"></a><strong>13.2. Online</strong></h3><p>在代理和客户端之间创建Mercury通道。在丢包的情况下，只有被列为可靠的选定数据才会重新发送。由于平均包速率和预期的网络延迟，如果一个包的序列号比它更早收到，它就被归类为丢弃。</p>
<p>由于客户机是在高延迟条件下运行的，服务器在向客户机发送其他未决信息之前不等待被丢弃的数据包重新发送。因此，客户端必须处理接收各种无序消息。</p>
<p>消息通过ServerConnection类发送到服务器。玩家的位置每秒被发送到服务器10次。在输入循环期间，这个类从服务器接收消息，并将消息分发给实体管理器中的处理程序。</p>
<ul>
<li><p>服务器端可以向客户端发送的消息类型如下:</p>
<ul>
<li><p><strong>enterEntity</strong></p>
<p>通知客户端具有给定ID的实体已进入其AoI。</p>
</li>
<li><p><strong>leaveEntity</strong></p>
<p>通知客户端具有给定ID的实体已离开其AoI。</p>
</li>
<li><p><strong>createEntity</strong></p>
<p>在响应来自客户端的查询时，提供实体的类型和其他即时数据。</p>
</li>
<li><p><strong>avatarUpdate</strong></p>
<p>更新位置不稳定的实体的位置。</p>
<p>这些消息的发送是不可靠的(即，如果包丢失，它们不会重新发送)。</p>
</li>
<li><p><strong>entityMessage</strong></p>
<p>向实体的客户端表示发送脚本消息或更新其属性。</p>
</li>
</ul>
</li>
<li><p>客户端可以发送给服务器的消息类型如下:</p>
<ul>
<li><p><strong>avatarUpdate</strong></p>
<p>通知服务器客户端的玩家实体的位置。</p>
</li>
<li><p><strong>requestEntityUpdate</strong></p>
<p>请求关于刚刚进入客户端的AoI的具有给定ID的实体的信息。</p>
<p>这通过有效地将实体(对正在请求的客户端)的最后一次更新时间设置为此消息中包含的时间来实现。</p>
<p>自那时以来已更改的属性将重新发送。</p>
</li>
<li><p><strong>entityMessage</strong></p>
<p>向实体的服务器端发送脚本消息(在基础上或单元上)</p>
</li>
</ul>
</li>
</ul>
<h3 id="13-3-Firewalls"><a href="#13-3-Firewalls" class="headerlink" title="13.3. Firewalls"></a><strong>13.3. Firewalls</strong></h3><p>大众市场在线游戏的祸根是防火墙，尤其是企业防火墙。我们的协议被设计成能顺利通过所有防火墙，除了最偏执的防火墙。</p>
<p>从防火墙的角度来看，它应该显示客户端已经启动了登录和代理信息流——因为登录回复信息流包含了要发送的代理服务器地址，所以客户端可以立即开始发送数据，这让服务器觉得它也启动了这个信息流，也就是说，它“在防火墙上打了一个洞”。</p>
<p>BigWorld服务器正确地处理了这样的情况:在客户端向它发送任何数据之前，它将数据发送给客户端(如果客户端在防火墙之后，这些数据可能会丢失)——丢失的数据会重新发送。</p>
<p>为了使这些协议工作，防火墙需要支持的是在转发一个传出的数据包时存储一个UDP应答映射项，这样当一个应答数据包以完全相反的地址到达时(源和目的IP和端口从请求数据包交换)，它被转发回请求客户机。这与普遍存在的Internet域名服务(DNS)的需求是相同的，几乎所有的防火墙都支持DNS。</p>
<p>BigWorld服务器不需要客户端从任何特定的端口发出请求，所以如果防火墙伪装了端口和IP，也不会混淆。</p>
<h2 id="14-Particles"><a href="#14-Particles" class="headerlink" title="14. Particles"></a><strong>14. Particles</strong></h2><p>粒子是一个有纹理的矩形或小网格，可以快速和简单地绘制，通常使用添加的混合模式。它们主要用于创建有趣的图形效果。</p>
<p>粒子是在粒子系统对象中管理的，它跟踪许多具有相似属性的粒子，并使用相同的函数管道来描述其粒子属性的转变。</p>
<h3 id="14-1-Particle-Systems"><a href="#14-1-Particle-Systems" class="headerlink" title="14.1. Particle Systems"></a><strong>14.1. Particle Systems</strong></h3><p>粒子系统是用c++实现的，可以从脚本环境和c++中访问。用于粒子系统的Python模块名为Pixie。</p>
<p>每个粒子系统目前负责一组相同纹理的粒子。虽然粒子系统可以动态地改变粒子纹理颜色，但需要不同同时纹理的效果需要单独的粒子系统。</p>
<p>一个粒子系统是以下因素的集合体:</p>
<ul>
<li><p>Particles</p>
<p>这是一个容器，它具有由渲染器类型确定的特定分配要求。目前有一些相邻的粒子，它们具有最佳的插入&#x2F;擦除特性;和FixedIndex粒子，这些行为就像一个循环缓冲区，并确保粒子索引在其生命周期内保持不变。FixedIndexParticles是跟踪渲染和网格粒子渲染的必要条件。</p>
</li>
<li><p>Particle Actions</p>
<p>它们负责粒子的移动(这些动作完成了移动、创造和摧毁每个粒子的所有工作)。</p>
</li>
<li><p>Particle Rederer</p>
<p>它负责绘制粒子。</p>
</li>
</ul>
<p>粒子系统本身为所有三个对象提供了一个公共接入点。</p>
<p>粒子渲染器大部分隐藏在粒子系统中。同样，粒子本身也无法被外界接触到。大多数与粒子系统相关的游戏代码都涉及特殊粒子动作的创造。</p>
<p>粒子操作只在客户端的更新阶段工作。它们在粒子系统的滴答法(tick method)中依次被调用，每一个的联合作用产生系统的整体粒子效应。</p>
<p>对于每个粒子系统类，都有一个对应的python包装类。例如，MetaParticleSystem被PyMetaParticleSystem包装。这些python包装器不保存状态，它们只保存一个指向底层c++对象的智能指针引用。将c++对象和它们的python等价对象分开的原因是允许在后台线程中完整地构造粒子系统(Python对象只能在主线程中构造。)</p>
<p>还有一个粒子系统类，它是ChunkParticles类。这完全是c++的，并且为粒子系统实现了一个ChunkItem，它允许粒子系统通过world被放置在世界中编辑器工具(World Editor tool)。注意，这样的粒子系统应该是自动时间触发的，因为在python中没有办法在运行时访问它们并打开或关闭它们。</p>
<p>目前，使用粒子系统的程序包括以下步骤:</p>
<ul>
<li>粒子系统是使用粒子编辑器创建的</li>
<li>粒子编辑器用于创建控制粒子的不同类型的粒子动作。</li>
<li>设置任何纹理和材质效果。</li>
<li>粒子系统被添加到模型中，以便显示和更新。</li>
</ul>
<p>粒子系统可以很容易地在BigWorld粒子编辑器中创建并保存为XML文件-通常在资源树&lt;res&gt;文件夹下。在客户端中，它们可以直接使用世界编辑器，或从Python中这样调用:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Pixie</span><br><span class="line">ps = Pixie.create( <span class="string">&quot;my_particle_system.xml&quot;</span> )</span><br><span class="line">BigWorld.player().model.node( <span class="string">&quot;biped head&quot;</span> ).attach( ps )</span><br></pre></td></tr></table></figure>

<p>请注意，粒子系统可能需要相当长的时间来构建——对于一个中等复杂的系统来说，解析xml文件、创建所有子系统并将它们连接在一起可能需要5ms。因此，强烈建议脚本编写器使用Pixie异步加载Particle Systems。createBG方法，BigWorld。loadResourceListBG方法，或使用实体先决条件。例如:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Example <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">import</span> Pixie</span><br><span class="line">    ps = Pixie.createBG( <span class="string">&quot;my_particle_system.xml&quot;</span>, self.onLoadPS )</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">onLoadPS</span>(<span class="params"> self, ps </span>):</span><br><span class="line">        BigWorld.player().model.node( <span class="string">&quot;biped head&quot;</span> ).attach( ps )</span><br><span class="line">Example <span class="number">2</span>:</span><br><span class="line">     <span class="keyword">import</span> BigWorld</span><br><span class="line">     BigWorld.loadResourceListBG( (<span class="string">&quot;particles/one.xml&quot;</span>, <span class="string">&quot;particles/two.xml&quot;</span>),self.onLoadResources )</span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">onLoadResources</span>(<span class="params"> self, resources </span>):</span><br><span class="line">          self.model.root.attach( resources[<span class="string">&quot;particles/one.xml&quot;</span>] )</span><br><span class="line">          self.model.root.attach( resources[<span class="string">&quot;particles/two.xml&quot;</span>] )</span><br></pre></td></tr></table></figure>

<h3 id="14-2-Particle-Actions"><a href="#14-2-Particle-Actions" class="headerlink" title="14.2. Particle Actions"></a><strong>14.2. Particle Actions</strong></h3><p>粒子作用主要有四类:</p>
<ul>
<li><p>Source</p>
<p>创建粒子</p>
</li>
<li><p>Movement</p>
<p>根据一套规则改变粒子的速度或位置。一个运动动作是特殊的，因为它将速度的影响应用到每个粒子的位置上。</p>
</li>
<li><p>Sink</p>
<p>根据一组规则从活动粒子列表中删除粒子。</p>
</li>
<li><p>Alteration</p>
<p>改变粒子的外观。</p>
</li>
</ul>
<h4 id="14-2-1-Source-actions"><a href="#14-2-1-Source-actions" class="headerlink" title="14.2.1. Source actions"></a><strong>14.2.1. Source actions</strong></h4><p>源动作可以在固定的时间内，按需创建粒子，甚至对它所附加的模型的移动很敏感。粒子的大小、颜色、速度、位置甚至年龄都可以在创建时指定。粒子矢量描述背后的关键是矢量生成子系统。</p>
<p>每个源操作都需要三个矢量生成器。矢量生成器是一类在给定空间中随机生成矢量的对象;空间通常由生成器的类型和给定的参数来定义。例如，球面生成器可以接受三维空间中的一个点和一个半径值，而线生成器可以接受三维空间中的两个点。</p>
<p>这三个生成器被用来找到粒子的初始位置、速度和颜色。在计算位置和速度时考虑了模型的局部空间，但仅用于粒子的创建。这意味着由(-0.5，-0.5，-0.5)到(0.5, 0.5, 0.5)两个点描述的立方体大致是位置上粒子的边界盒。</p>
<h4 id="14-2-2-Movement-actions"><a href="#14-2-2-Movement-actions" class="headerlink" title="14.2.2. Movement actions"></a><strong>14.2.2. Movement actions</strong></h4><p>运动作用于系统中的每一个粒子。有各种各样的运动可以应用到一个粒子。例如force、stream、barrier和jitter。</p>
<p>粒子的基本运动由于速度在粒子系统内自动计算，也考虑到风。</p>
<p>粒子也可以经历整个场景的碰撞-例如，用过的子弹滚下台阶。</p>
<h4 id="14-2-3-Sink-actions"><a href="#14-2-3-Sink-actions" class="headerlink" title="14.2.3. Sink actions"></a><strong>14.2.3. Sink actions</strong></h4><p>沉降动作将粒子从系统中移除，无论是由于年龄增长还是由于移动到指定的边界之外。下沉动作的例子有下沉、障碍和飞溅。</p>
<p>需要注意的是，如果没有下沉动作，一旦创建的粒子将永远不会离开系统，最终迫使它达到粒子极限。</p>
<h4 id="14-2-4-Alteration-actions"><a href="#14-2-4-Alteration-actions" class="headerlink" title="14.2.4. Alteration actions"></a><strong>14.2.4. Alteration actions</strong></h4><p>改变作用影响粒子的外观。随着时间的推移，他们可以修改阴影、alpha级别和粒子的大小。它们通常用于烟雾效果，温和的淡出和发光效果。如果指定的纹理是动画纹理，粒子纹理可以被动画化。</p>
<h3 id="14-3-Particle-types"><a href="#14-3-Particle-types" class="headerlink" title="14.3. Particle types"></a><strong>14.3. Particle types</strong></h3><p>粒子系统渲染器与主要的粒子系统计算是分开的，它不仅允许基于纹理的粒子，还允许基于精灵和基于网格的粒子。多个粒子系统可以共享同一个渲染器。</p>
<p>网格粒子渲染器可以使用任何视觉效果，但为了最佳性能，特定用于粒子系统的网格应该从3ds Max或Maya中导出，每组15个，在其各自的导出对话框中选择网格粒子选项按钮。</p>
<h3 id="14-4-Attaching-particle-systems-to-bones"><a href="#14-4-Attaching-particle-systems-to-bones" class="headerlink" title="14.4. Attaching particle systems to bones"></a><strong>14.4. Attaching particle systems to bones</strong></h3><p>要让粒子系统跟随骨骼并定位到外部目标，你应该将它连接到一个节点，然后使用跟踪器指向该节点。</p>
<p>BigWorld模块(BigWorld. tracker)提供的跟踪器类可以使用各种DirectionProviders将节点指向适当的方向:</p>
<ul>
<li><p><strong>EntityDirProvider</strong></p>
<p>将节点指向实体所面对的方向</p>
</li>
<li><p><strong>DiffDirProvider</strong></p>
<p>将节点指向MatrixProvider给出的位置(例如，指向另一个实体的头部节点，或指向一个恒定的世界方向)。</p>
</li>
<li><p><strong>ScanDirProvider</strong></p>
<p>使一个节点绕其y轴来回摆动(例如，模拟一个安全摄像机)</p>
</li>
</ul>
<p>根据您的特定游戏，您可能无法使用跟踪器来指向源模型上的节点。例如，节点可能是角色骨架的一部分，并带有一些网格，所以你可能不希望实际指向这个骨架(只有连接到它的粒子系统)。如果是这种情况，那么你将需要创建一个新的节点来安装你的粒子系统-要求制作者在他们的模型中建立虚拟节点来挂载FX。</p>
<p>要让粒子系统存在于一个不是由骨骼提供的位置，您应该将其附加到一个单独的模型，并使用Entity.addModel显示单独的模型。使用实体。添加model而不是Entity.model.node(xxx)。附加意味着模型存在于独立于实体的位置——事实上，它意味着没有人会设置模型的位置&#x2F;方向，这完全取决于脚本。</p>
<p>一旦你有一个独立的模型，你可以设置它的位置和方向到任何MatrixProvider，通过使用Servo Motor。正如在Client Python API中解释的那样，Servo类是一个Motor，它将模型的转换设置为给定的MatrixProvider——当MatrixProvider被更新时，模型将移动。signal属性是设置模型转换的MatrixProvider。</p>
<p>这样，您可以使用Servo Motor移动模型到任何动态矩阵提供的位置。如果独立模型有一个要指向的节点，那么您可以使用Tracker来设置它的方向，如上所述。这允许您将粒子系统的位置与骨骼分离，但仍然将粒子系统的方向设置为骨骼的方向，或指向外部目标。</p>
<p>最后，如果你想要一个粒子系统以一个固定的点&#x2F;方向存在，那么使用particlessystem的explicitPosition和explicitDirection属性。这些只设置一次粒子系统的位置&#x2F;方向，不能设置为动态矩阵。注意，如果你使用其中一个属性，你将需要同时使用两个属性(设置其中一个属性告诉粒子系统它正在使用从两个属性派生的“显式转换”)。</p>
<p>***将粒子系统附着到骨头上时要小心!***要将粒子系统连接到骨骼，必须检索PyModelNode。如果没有现有的PyModelNode引用您想要使用的骨骼，那么它的转换在下一次绘制调用之前都是未定义的。因为python脚本是在调用draw之前更新的，所以在第一次获取节点时无法知道节点在哪里。因此在本例中，您应该只在知道PyModelNode已更新时才将粒子系统附加到PyModelNode。你可能的选择是:</p>
<ul>
<li><p>在创建模型时检索并保留对骨骼的引用。这将确保以后当粒子系统附着在骨头上时，骨头的位置是众所周知的。</p>
</li>
<li><p>检索到您需要的骨骼的引用，并回调自己的下一帧来将粒子系统连接到它。例如:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BigWorld.callback( <span class="number">0.0</span>, partial( self.model.node(<span class="string">&quot;HP particles&quot;</span>).attach,self.particles ) )</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="15-Detail-Objects"><a href="#15-Detail-Objects" class="headerlink" title="15. Detail Objects"></a><strong>15. Detail Objects</strong></h2><p>一个细节对象是一个在相机位置周围的地形上大量绘制的小网格。为了提高效率，它们与普通模型分开了。这些对象的选择和放置在很大程度上是自动的-它是基于底层地形使用的纹理。</p>
<p>细节对象的例子有:草、蕨类植物、芦苇、鹅卵石和岩石。用户不与细节对象交互(例如，不执行碰撞检测)。</p>
<h3 id="15-1-Flora"><a href="#15-1-Flora" class="headerlink" title="15.1. Flora"></a><strong>15.1. Flora</strong></h3><p>在任何时候，BigWorld默认有大约60000个三角形的植物群活跃，其中大约15000个将在任何时候被绘制。你可以通过改变flora配置文件中的vb_size标记值来改变顶点缓冲区的大小(该值由配置文件&lt;res&gt;&#x2F;resources.xml中的environment&#x2F;floraXML标记来指定</p>
<h4 id="15-1-1-Placement"><a href="#15-1-1-Placement" class="headerlink" title="15.1.1. Placement"></a><strong>15.1.1. Placement</strong></h4><p>由于涉及的对象众多，用手放置细节对象是不切实际的。相反，BigWorld拥有生态类型。</p>
<p>生态类型定义的对象自动放置在世界中，由地形纹理引导。它们是用XML定义的，具有以下属性:</p>
<ul>
<li>一个或多个单位(Moo视觉效果)。</li>
<li>一个或多个纹理，用于将地形与生态类型匹配。</li>
<li>声音标签，用于人物脚步。</li>
</ul>
<p>例如，一个草生态类型可以包含两个单独的网格:一个用于低高度的草，另一个用于中等高度的草。</p>
<p>当前活动的生态类型集由Flora类管理，它还管理单独的活动详细对象，根据需要分配和取消分配它们。</p>
<p>每个地形块可以有四个纹理，每个纹理可以有一个相关的生态类型。这允许每个地形块有四个不同的生态类型。因此，在细节范围内(距相机50米半径)可以看到多达16种不同的生态类型。</p>
<p>细节对象不能精确地放置在地形块中，这将创建细节对象的正方形区域。在查询地形的细节映射之前，详细对象“抖动”它们的位置。这将有效地反对别名的量化细节映射。</p>
<p>植物区由世界编辑器计算并存储在地形文件中。</p>
<h5 id="15-1-1-1-Visual-consistency"><a href="#15-1-1-1-Visual-consistency" class="headerlink" title="15.1.1.1. Visual consistency"></a><strong>15.1.1.1. Visual consistency</strong></h5><p>细节对象直接从地形纹理映射。从视觉上看，这是正确的，因为在现实生活中，地形的颜色实际上是由数百万个细节对象(草叶等)的颜色构成的。因此，一个绿色的“草”地形纹理可以完美地映射到一个草生态类型。</p>
<p>在BigWorld中，无论何时使用一个纹理，都会显示其伴随的细节对象。</p>
<h4 id="15-1-2-Implementation"><a href="#15-1-2-Implementation" class="headerlink" title="15.1.2. Implementation"></a><strong>15.1.2. Implementation</strong></h4><p>绘制细节对象是一个非常关键的性能领域，因为所有例程每帧要运行数千次。</p>
<p>顶点缓冲区是完美的解决方案。细节对象被保存在一个大的顶点缓存中。因此，每个6个顶点处的1000片草意味着世界空间的顶点缓冲区有6000个顶点。这允许所有草被绘制使用一个调用视频卡，使用一个变换矩阵。3D加速器非常快地执行这种批处理渲染。</p>
<p>当玩家在游戏世界中移动时，他会看到附近(50m)的细节对象。实际上，这意味着细节对象的活动集合必须根据相机的位置而改变。使用alpha混合淡出刚刚进入alpha的细节对象。</p>
<p>flora配置XML文件&lt;flora&gt;.xml(关于该文件语法的详细信息，请参见文档文件语法指南的章节“&lt;flora&gt;.xml”)可以静态定义顶点缓冲区的大小，也可以通过FLORA_DENSITY图形设置将顶点缓冲区的大小定义为用户可选择的一组选项。</p>
<h4 id="15-1-3-Frame-coherency"><a href="#15-1-3-Frame-coherency" class="headerlink" title="15.1.3. Frame coherency"></a><strong>15.1.3. Frame coherency</strong></h4><p>在一个多目标系统中，必须充分利用帧相干性。最明显的框架一致性选择是顶点变换。每个细节对象在世界空间的顶点缓冲区中保持转换，直到它的地形贴图(或“flora block”)离开细节半径，此时另一个地形贴图将移动到细节半径中。然后，新贴图的细节对象将被转换，并放置在释放的顶点缓冲区内存中。</p>
<p>平均而言，细节对象在帧之间显示出97%左右的一致性，这大大节省了转换成本。</p>
<h4 id="15-1-4-Animation"><a href="#15-1-4-Animation" class="headerlink" title="15.1.4. Animation"></a><strong>15.1.4. Animation</strong></h4><p>为了创造一个沉浸式的、活生生的、会呼吸的世界，大多数东西都必须是有生命的。</p>
<p>动态的细节对象大大增加了世界的幻觉。BigWorld客户端使用基于(wx, wz，time)的3D Perlin噪声为细节对象创建可信的程序动画。选择Perlin噪声是因为它是一种制造时空相干噪声的廉价方法。这个实现在顶点着色器中高效地执行动画。</p>
<h4 id="15-1-5-Lighting"><a href="#15-1-5-Lighting" class="headerlink" title="15.1.5. Lighting"></a><strong>15.1.5. Lighting</strong></h4><p>当使用简化的网格(这是至关重要的在一个数千对象装饰系统)，照明变得具有挑战性。考虑一个纵横交错的草物体垂直地从地形中升起。如果使用标准程序点燃，这些纵横交错的物体会在傍晚的太阳下燃烧起来。</p>
<p>在BigWorld客户端中，细节对象的照明是使用从实际地形计算的光照图来执行的。因此，它也可以拾取地形阴影。这是一个基本正确的解决方案，因为基于网格的地形本身实际上是数以百万计的细节对象的简化版本。</p>
<h4 id="15-1-6-File-format"><a href="#15-1-6-File-format" class="headerlink" title="15.1.6. File format"></a><strong>15.1.6. File format</strong></h4><p>XML植物群文件定义了要使用的灯光图，以及生态类型和噪声生成函数。关于该文件语法的详细信息，请参见文档文 File Grammar Guide’s section “&lt;flora&gt;.xml”。</p>
<h2 id="16-Water"><a href="#16-Water" class="headerlink" title="16. Water"></a>16. Water</h2><p>水体可以通过世界编辑器放置在世界中，使用提供的帮助文件bigworld&#x2F;res&#x2F; helpers&#x2F;misc&#x2F;water.xml -详细信息，请参阅文档 Content Creation Manual’s lesson <strong>Add Water to the World</strong></p>
<p>因为所有的水对象都是VLO的，每个实例将在chunk文件夹中创建两个新文件(以每个实例的唯一ID命名):</p>
<ul>
<li><p>.vlo 文件</p>
<p>包含水对象的XML块项目部分。</p>
</li>
<li><p>. odata 文件</p>
<p>包含与VLO相关的二进制信息(在本例中，水的逐顶点透明度&#x2F;边缘数据)。</p>
</li>
</ul>
<h3 id="16-1-Code-overview"><a href="#16-1-Code-overview" class="headerlink" title="16.1. Code overview"></a><strong>16.1. Code overview</strong></h3><p>水的实现包含在bigworld&#x2F;src&#x2F;lib&#x2F;romp库中，具体来说，在以下文件中:</p>
<ul>
<li><p><strong>chunk_water.cpp,chunk_water.hpp</strong></p>
<p>水与BigWorld分块系统的联系。</p>
<p>参见:bigworld&#x2F;src&#x2F;lib&#x2F;chunk&#x2F;chunk_vlo.cpp和bigworld&#x2F;src&#x2F;lib&#x2F;chunk&#x2F; chunk_vlo.hpp。</p>
</li>
<li><p><strong>editor_chunk_water.cpp,editor_chunk_water.hpp</strong></p>
<p>与编辑器相关的功能，如保存、移动和编辑。</p>
<p>参见:bigworld&#x2F;src&#x2F;lib&#x2F;chunk&#x2F;editor_chunk_vlo.cpp和bigworld&#x2F;src&#x2F;lib&#x2F;chunk&#x2F; editor_chunk_vlo.hpp。</p>
</li>
<li><p><strong>water.cpp,water.hpp,water.ipp</strong></p>
<p>主要文件。包含曲面图形&#x2F;设置</p>
</li>
<li><p><strong>water_scene_renderer.cpp,water_scene_renderer.hpp</strong></p>
<p>实现水景(反射&#x2F;折射)的生成</p>
</li>
<li><p><strong>water_simulation.cpp,water_simulation.hpp</strong></p>
<p>实现水面的模拟。</p>
</li>
<li><p><strong>water.fx</strong></p>
<p>水的主要表面着色器。</p>
</li>
<li><p><strong>simulation.fx</strong></p>
<p>用于GPU水交互模拟的着色器。</p>
</li>
</ul>
<p>世界上的每个ChunkWater都创建自己的水对象。ChunkWater是由ChunkVLO遇到的第一个引用创建的。水是一个非常大的对象(VLO)，这意味着它可以跨越&#x2F;属于多个块。这是通过在水重叠的每个块中放置一个VLO引用对象(ChunkVLO)来实现的。每个引用都被视为实际的大对象，从它那里传递和检索数据。</p>
<p>每个水对象在每一帧添加自己到绘制列表，使用Waters::addToDrawList。然后，引擎通过调用Waters::drawWaters来绘制水面列表。</p>
<h3 id="16-2-Scene-generation"><a href="#16-2-Scene-generation" class="headerlink" title="16.2. Scene generation"></a><strong>16.2. Scene generation</strong></h3><p>反射场景会根据当前的水质水平进行渲染(详细信息 “Setting the quality”)。反射场景是一个渲染目标，在主游戏循环中更新，在调用TextureRenderer:: updatdynamics期间。</p>
<p>多个水面可以共享一个反射渲染目标(水景类)，如果他们都在y轴上的相同位置。水景生成假设水在定义的y轴位置周围反射&#x2F;剪辑一个平面。</p>
<p>折射场景使用包含主渲染目标副本的失真通道纹理。</p>
<h3 id="16-3-Render-settings"><a href="#16-3-Render-settings" class="headerlink" title="16.3. Render settings"></a><strong>16.3. Render settings</strong></h3><p>地形总是会被绘制出来，但是其他的一切都与当前的质量设置相关，这些设置由以下变量定义:</p>
<ul>
<li><p><strong>WaterSceneRenderer::s_drawDynamics_</strong></p>
<p>确定动态对象是否被绘制到水景中。</p>
</li>
<li><p><strong>WaterSceneRenderer::s_drawPlayer_</strong></p>
<p>确定玩家模型是否被绘制到水景中。</p>
</li>
<li><p><strong>WaterSceneRenderer::s_drawTrees_</strong></p>
<p>确定树是否被绘制到水景中。</p>
</li>
<li><p><strong>WaterSceneRenderer::s_maxReflectionDistance_</strong></p>
<p>动态物体离水面的最大距离。缺省值为25。</p>
</li>
<li><p><strong>WaterSceneRenderer::s_maxReflections_</strong></p>
<p>要绘制的最大动态对象数。缺省值为10。</p>
</li>
<li><p><strong>WaterSceneRenderer::s_useClipPlane_</strong></p>
</li>
<li><p>切换硬件裁剪平面的使用。</p>
</li>
</ul>
<h4 id="16-3-1-Setting-the-quality"><a href="#16-3-1-Setting-the-quality" class="headerlink" title="16.3.1. Setting the quality"></a><strong>16.3.1. Setting the quality</strong></h4><p>Water::init方法用于初始化图形设置选项菜单链接和FX文件，只调用一次。它将提供以下菜单项:</p>
<ul>
<li><p><strong>Water Quality</strong> → <strong>High</strong> –Waters::setQualityOption</p>
<p>所有世界项目都绘制在水景中。最高细节着色器也被使用。</p>
</li>
<li><p><strong>Water Quality</strong> → <strong>Mid</strong>–Waters::setQualityOption</p>
<p>除了动态对象，所有的世界项目都绘制在水景中。</p>
</li>
<li><p><strong>Water Quality</strong> → <strong>Low</strong>–Waters::setQualityOption</p>
<p>玩家，树和天空在反射中绘制。反射纹理尺寸减小。</p>
</li>
<li><p><strong>Water Quality</strong> → <strong>Lowest</strong>–Waters::setQualityOption</p>
<p>动态对象、玩家绘图、地形和树木都被禁用。只有天空会被反射进来</p>
</li>
<li><p><strong>Water Simulation Quality</strong> → <strong>High</strong>– Waters::setSimulationOption</p>
<p>扰动可以在cell之间传播</p>
</li>
<li><p><strong>Water Simulation Quality</strong> → <strong>Low</strong>– Waters::setSimulationOption </p>
<p>模拟仅限于单个cell</p>
</li>
<li><p><strong>Water Simulation Quality</strong> → <strong>Off</strong>– Waters::setSimulationOption</p>
<p>模拟被禁用</p>
</li>
</ul>
<h3 id="16-4-Simulation"><a href="#16-4-Simulation" class="headerlink" title="16.4. Simulation"></a><strong>16.4. Simulation</strong></h3><p>水面被划分成大小由水面定义的单元格(默认为100.0单位)。每个单元都定义了一个可以活动的水域模拟区域。</p>
<p>有一个公共的模拟纹理池(大小为MAX_SIM_TEXTURE_BLOCKS)由SimulationManager类维护。</p>
<p>当移动进入其定义的区域时，单元格被激活，并在一段时间不活动后被停用(由SimulationManager::maxIdleTime_定义，默认值为5.0秒)。</p>
<p>当选择高细节模拟选项时，水的运动将传播(并激活)邻近的cell。</p>
<p>活动移动的最大数量由MAX_SIM_MOVEMENTS定义。水的运动通过Sway系统传入模拟管理器—详细信息 Client C API’s entry Class List → ChunkWater**, Public Member Fuction** <strong>sway</strong></p>
<h3 id="16-5-Rain"><a href="#16-5-Rain" class="headerlink" title="16.5. Rain"></a><strong>16.5. Rain</strong></h3><p>水会自动受到雨的影响——在SimulationManager中还有另一个模拟纹理块，它用于雨。</p>
<h3 id="16-6-Water-depth"><a href="#16-6-Water-depth" class="headerlink" title="16.6. Water depth"></a><strong>16.6. Water depth</strong></h3><p>水深由水下最低地形点决定。根据这个值生成的边界框也可以用来定义游戏中的水量。这可以通过在bigworld&#x2F;src&#x2F;lib&#x2F;romp&#x2F;water.cpp中搜索bbDeep_引用来找到。</p>
<p>该深度信息还用于根据水面的实际每像素深度为水的折射着色。这使用了在主场景渲染中生成的MRT(多重渲染目标)深度纹理。使用此信息还可以添加泡沫边缘效果。</p>
<h3 id="16-7-Watchers"><a href="#16-7-Watchers" class="headerlink" title="16.7. Watchers"></a><strong>16.7. Watchers</strong></h3><p>为了配置水系统的行为，使用了下面的观察者(所有观察者的前缀都是<strong>Client Settings&#x2F;Water&#x2F;</strong>):</p>
<ul>
<li><p><strong>character impact</strong></p>
<p>在其中一个运动强度将冲击水面模拟</p>
</li>
<li><p><strong>draw</strong></p>
<p>定义是否绘制水面。</p>
</li>
<li><p><strong>Draw Dynamics</strong></p>
<p>连接到WaterSceneRenderer:: s_drawDynamics_</p>
</li>
<li><p><strong>Draw Player</strong></p>
<p>连接到WaterSceneRenderer::s_drawPlayer_.</p>
</li>
<li><p><strong>Draw Trees</strong></p>
<p>连接到WaterSceneRenderer:: s_drawTrees_</p>
</li>
<li><p><strong>Max Reflection Distance</strong></p>
<p>连接到WaterSceneRenderer:: s_maxReflectionDistance_</p>
</li>
<li><p><strong>Max Reflections</strong></p>
<p>连接到WaterSceneRenderer:: s_maxReflections_</p>
</li>
<li><p><strong>Scene&#x2F;Use Clip Plane</strong></p>
<p>连接到WaterSceneRenderer:: s_useClipPlane_</p>
</li>
<li><p><strong>water speed square</strong></p>
<p>波浪在水中传播的速度。</p>
</li>
<li><p><strong>wireframe</strong></p>
<p>切换水面线框模式。</p>
</li>
</ul>
<h2 id="17-Graphical-User-Interface-GUI"><a href="#17-Graphical-User-Interface-GUI" class="headerlink" title="17. Graphical User Interface (GUI)"></a><strong>17. Graphical User Interface (GUI)</strong></h2><p>BigWorld的GUI可以分为独立的(菜单和选项界面)和游戏内覆盖。</p>
<p>游戏内的叠加需要3D集成，因此有一个单独的设计。游戏内部界面的独特功能支持:</p>
<ul>
<li>链接到游戏内的对象(特别是模型的边界框)，</li>
<li>混合，或者叠加在场景上，</li>
<li>特殊效果，如缩放，旋转，颜色变化，淡入淡出，运动模糊。</li>
</ul>
<p>游戏内界面最重要的功能是当不使用时可以消失。这让游戏设计师能够创造出更具沉浸感的游戏世界体验。虽然GUI需要将重要信息与玩家联系起来，但它应该只在需要这些信息时才这么做。在其他时候，玩家不应该被叠加内容分心，而应该完全沉浸在3D世界中。</p>
<p>以下是一些游戏内部界面的例子:</p>
<ul>
<li>目标</li>
<li>当前项目显示</li>
<li>玩家生命值和伤害</li>
<li>聊天窗口</li>
</ul>
<h3 id="17-1-C-GUI-support"><a href="#17-1-C-GUI-support" class="headerlink" title="17.1. C++ GUI support"></a><strong>17.1. C++ GUI support</strong></h3><p>有两个支持GUI的c++基类:</p>
<ul>
<li>SimpleGUIComponent</li>
<li>GUIShader</li>
</ul>
<p>还有一个管理类:</p>
<ul>
<li>SimpleGUI</li>
</ul>
<h4 id="17-1-1-SimpleGUIComponent"><a href="#17-1-1-SimpleGUIComponent" class="headerlink" title="17.1.1. SimpleGUIComponent"></a><strong>17.1.1. SimpleGUIComponent</strong></h4><p>simpleguiccomponent类只是一个有纹理的矩形。派生类TextGUIComponent绘制文本，派生类FrameGUIComponent使用三个位图(角、边、背景)绘制可调整大小的框架。</p>
<p>SimpleGUIComponent有很多属性，主要从Python和XML文件访问。</p>
<p>组件只有在父组件绘制子组件时才具有层次性;孩子不会继承父母的转变。windowGUIComponent是这个规则的一个例外——子组件会被父组件自动剪切和转变。注意，这是windowGUIComponent的一个特性，而不是一般的GUI系统。</p>
<h4 id="17-1-2-GUIShader"><a href="#17-1-2-GUIShader" class="headerlink" title="17.1.2. GUIShader"></a><strong>17.1.2. GUIShader</strong></h4><p>GUIShader类改变了组件绘制的方式，以类似于顶点着色器的形式(事实上，99%的GUI着色器只操作临时变量，而不是顶点，硬件TnL支持)。</p>
<ul>
<li>ClipGUIShader将GUIComponents按其原始长度的比例进行剪辑，这对于制作生命条非常有用。</li>
<li>ColourGUIShader为组件着色。</li>
<li>AlphaGUIShader淡入一个组件。</li>
<li>MatrixGUIShader对组件进行转换。</li>
</ul>
<p>着色器应用于所有的子组件-所以使用MatrixGUIShader来实现窗口，和AlphaGUIShader来淡入&#x2F;淡出整个组件树。</p>
<h4 id="17-1-3-SimpleGUI"><a href="#17-1-3-SimpleGUI" class="headerlink" title="17.1.3. SimpleGUI"></a><strong>17.1.3. SimpleGUI</strong></h4><p>这是GUI的根，它在每一帧都被勾选和绘制。使用SimpleGUI::addSimpleComponent()和SimpleGUI::removeSimpleComponent()来构建GUI组件树。请注意，您通常不会从c++中调用这些方法，因为它们大多是由脚本调用的。</p>
<h3 id="17-2-Python-GUI-support"><a href="#17-2-Python-GUI-support" class="headerlink" title="17.2. Python GUI support"></a><strong>17.2. Python GUI support</strong></h3><p>大多数时候，您可能会使用Python和XML创建GUI。不存在BigWorld GUI编辑器，因此目前所有的GUI都是使用Python控制台在游戏中创建的。</p>
<p>下面的代码显示了一个示例:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> GUI</span><br><span class="line"><span class="comment">#create a simple GUI component</span></span><br><span class="line">s=GUI.Simple( <span class="string">&quot;maps/guis/stats_bar.dds&quot;</span> )</span><br><span class="line"><span class="comment">#width/height initially in pixels. can use widthRelative/heightRelative</span></span><br><span class="line"><span class="comment">#to designate the component uses clip coordinates ( -1 .. +1 ) instead.</span></span><br><span class="line">s.width = <span class="number">64</span></span><br><span class="line">s.height = <span class="number">16</span></span><br><span class="line"><span class="comment">#colour attribute is ( r,g,b,a )</span></span><br><span class="line">s.colour = ( <span class="number">255</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">255</span> )</span><br><span class="line"><span class="comment">#the materialFX is simply the blend mode. can be &quot;BLEND&quot;,&quot;SOLID&quot;,&quot;ADD&quot;... </span></span><br><span class="line">s.materialFX = <span class="string">&quot;BLEND&quot;</span></span><br><span class="line"><span class="comment">#the position is always in clip coordinates ( -1 .. +1 )</span></span><br><span class="line">s.position = ( <span class="number">0</span>, <span class="number">0.85</span>, <span class="number">0.5</span> )</span><br><span class="line"><span class="comment">#the anchors determine what the position means with respect to the width </span></span><br><span class="line"><span class="comment">#and height. in this example, the position of (0,0.85,0.5) and anchors</span></span><br><span class="line"><span class="comment">#&quot;TOP,CENTER&quot; means that the top centre of the component will rest at </span></span><br><span class="line"><span class="comment">#the given position.</span></span><br><span class="line"><span class="comment">#The component will hang down from y=0.85, and will be centred on x=0.0</span></span><br><span class="line">s.verticalAnchor = <span class="string">&quot;TOP&quot;</span></span><br><span class="line">s.horizontalAnchor = <span class="string">&quot;CENTER&quot;</span></span><br><span class="line"><span class="comment">#create a clipper for the health amount. clip shaders are used to</span></span><br><span class="line"><span class="comment">#implement stats bars. the constructor parameter &quot;RIGHT&quot; means the </span></span><br><span class="line"><span class="comment">#shader will clip the component from the right hand side.</span></span><br><span class="line">c=GUI.ClipShader( <span class="string">&quot;RIGHT&quot;</span> )</span><br><span class="line"><span class="comment">#all shaders animate their values. the speed indicates how long the</span></span><br><span class="line"><span class="comment">#internal parameter will change from the old value to the new. This speed</span></span><br><span class="line"><span class="comment">#indicates the health bar will always take 1/2 a second to change.</span></span><br><span class="line">c.speed = <span class="number">0.5</span></span><br><span class="line"><span class="comment">#the value is what the game normally changes if player&#x27;s health changes.</span></span><br><span class="line">c.value = <span class="number">1.0</span></span><br><span class="line"><span class="comment">#this line adds the shader. Note that you can call your shader any name</span></span><br><span class="line"><span class="comment">#you like. Internally, the simple GUI component sees you are trying to </span></span><br><span class="line"><span class="comment">#add a GuiShader to it, under the name of clipper.</span></span><br><span class="line"><span class="comment">#Internally it will call SimpleGUIComponent::addShader()</span></span><br><span class="line">s.clipper = c</span><br><span class="line"><span class="comment">#create a colourer for the health amount</span></span><br><span class="line">c=GUI.ColourShader()</span><br><span class="line"><span class="comment">#the start,middle and end simply represent colours to blend to when the</span></span><br><span class="line"><span class="comment"># value parameter is 1.0, 0.5 and 0.0 respectively.</span></span><br><span class="line">c.start=(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">192</span>)</span><br><span class="line">c.middle=(<span class="number">255</span>,<span class="number">255</span>,<span class="number">0</span>,<span class="number">192</span>)</span><br><span class="line">c.end=(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>,<span class="number">192</span>)</span><br><span class="line">c.speed=<span class="number">0.5</span></span><br><span class="line">c.value=<span class="number">1.0</span></span><br><span class="line">s.colourer=c</span><br><span class="line"><span class="comment">#and make the health bar be drawn</span></span><br><span class="line">GUI.addRoot( s )</span><br></pre></td></tr></table></figure>

<p>然后你可以通过在着色器中设置适当的值来定制新的生命条:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># player&#x27;s health went down to 80%</span></span><br><span class="line">s.clipper.value = s.colourer.value = <span class="number">0.8</span></span><br></pre></td></tr></table></figure>

<p>最后，您可以将脚本与GUI组件关联起来，以便处理输入和I&#x2F;O事件，并在其上构建高级功能。使用script属性将脚本对象与组件关联:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.script = PyGUI.Button( s )</span><br></pre></td></tr></table></figure>

<p>关于GUI脚本的更多信息，请参见“XML和Python”，以及“Input events”，详细请看 Client Python API’s entry <strong>Main Page</strong> → <strong>Client</strong> → <strong>GUI</strong> →<strong>Classes</strong> → <strong>SimpleGUIComponent</strong>.</p>
<p>如果您纯粹使用Python创建GUI，那么您必须确保在删除它时正确地删除对它的所有引用，否则将出现内存泄漏。这是因为在BigWorld引擎中关闭了Python垃圾收集，它使用引用计数来代替速度。你可能会得到如下警告信息:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---------------------------------------------------------</span><br><span class="line">Some SimpleGUIComponent instances haven&#x27;t been destroyed.</span><br><span class="line">To debug, in &lt;engine_config&gt;.xml, set:</span><br><span class="line"> 	&lt;simpleGui&gt;</span><br><span class="line"> 		&lt;breakOnAllocId&gt; AllocId &lt;/breakOnAllocId&gt;</span><br><span class="line"> 		&lt;breakOnLeak&gt; true &lt;/breakOnLeak&gt;</span><br><span class="line"> 	&lt;/simpleGui&gt;</span><br><span class="line">---------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>要删除，必须将对GUI组件的所有引用设置为None，这包括从父组件中删除组件。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> s.parent:</span><br><span class="line"> 	s.parent.delChild( s )</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"> 	GUI.delRoot( s )</span><br><span class="line">s = <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<h3 id="17-3-XML"><a href="#17-3-XML" class="headerlink" title="17.3. XML"></a><strong>17.3. XML</strong></h3><p>GUI也可以表示为XML文件。它们可以保存在&lt;res&gt;&#x2F;guis文件夹中，例如，使用上面描述的方法构造之后。</p>
<p>Python接口的优势在于，一旦你创建了GUI，只需调用:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.save( <span class="string">&quot;guis/health_bar.gui&quot;</span> )</span><br></pre></td></tr></table></figure>

<p>将创建一个XML文件，封装GUI组件、它的着色器和它的所有子组件。一旦你这样做了，就写:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GUI.delRoot( s )</span><br><span class="line">s = <span class="literal">None</span></span><br><span class="line">s = GUI.load( <span class="string">&quot;guis/health_bar.gui&quot;</span> )</span><br><span class="line">GUI.addRoot( s )</span><br></pre></td></tr></table></figure>

<p>在那之后，你将拥有完全相同的组件，它的所有着色器和子组件都设置好了。</p>
<p>高级用户会发现手工创建XML是创建GUI的最快方法。另外，GUI编辑器完全可以用Python创建。</p>
<h3 id="17-4-XML-and-Python"><a href="#17-4-XML-and-Python" class="headerlink" title="17.4. XML and Python"></a><strong>17.4. XML and Python</strong></h3><p>当你有一个GUI组件的脚本保存在XML中，你的Python脚本必须实现以下方法(至少存根它们):</p>
<ul>
<li>def onLoad( self, section )</li>
<li>def onBound( self )</li>
<li>def onSave( self, section )</li>
</ul>
<h4 id="17-4-1-onLoad-self-section"><a href="#17-4-1-onLoad-self-section" class="headerlink" title="17.4.1. onLoad(self,section)"></a><strong>17.4.1.</strong> <strong>onLoad(self,section)</strong></h4><p>onLoad方法是在调用c++ load方法、设置标准成员变量和构造相关脚本之后调用的。</p>
<p>从其中加载GUI组件的数据部分被传递到方法中。这允许定义自定义属性，特别是用于将自定义数据加载到脚本对象。</p>
<p>注意，该方法是在加载任何子组件或着色器之前调用的。</p>
<h4 id="17-4-2-onBound-self"><a href="#17-4-2-onBound-self" class="headerlink" title="17.4.2. onBound(self)"></a><strong>17.4.2.</strong> <strong>onBound(self)</strong></h4><p>onBound方法在加载完成后被调用。</p>
<p>这个方法和onLoad之间的主要区别是，在调用onBound时，整个GUI组件树已经创建好了。因此，在onBound方法中，您可以编写自定义脚本处理来操作子组件。例如，您可以在此方法中调用自己的自定义布局管理器。</p>
<h4 id="17-4-3-onSave-self-section"><a href="#17-4-3-onSave-self-section" class="headerlink" title="17.4.3. onSave(self,section)"></a><strong>17.4.3.</strong> <strong>onSave(self,section)</strong></h4><p>onSave方法在c++ save方法保存所有标准GUI组件成员之后调用，但在着色器和子组件保存之前调用。</p>
<h3 id="17-5-Input-events"><a href="#17-5-Input-events" class="headerlink" title="17.5. Input events"></a><strong>17.5. Input events</strong></h3><p>SimpleGUI提供对键盘、操纵杆和鼠标输入的支持。要捕获事件，组件需要将其属性focus设置为true，并附加相关的Python脚本。</p>
<p>当从GUI文件加载组件时，如果XML声明了脚本字段，SimpleGUIComponent的属性将自动设置。该字段的值用于实例化脚本对象(它必须是一个可调用对象，接收一个参数—正在创建的SimpleGUIComponent—并返回一个Python对象)。返回的Python对象将是为新创建的组件指定的脚本对象。</p>
<p>还可以为现有组件手动设置脚本属性，如下例所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># instantiate a new PyGUI Button class, and make it the component&#x27;s </span></span><br><span class="line"><span class="comment"># script attribute. note most scripts are passed the GUI component </span></span><br><span class="line"><span class="comment"># in their constructor so they can perform operations on them.</span></span><br><span class="line">s.script = PyGUI.Button( s )</span><br></pre></td></tr></table></figure>

<p>每一类输入事件都有单独的焦点属性，如下所述:</p>
<ul>
<li><p>focus</p>
<p>关联:键盘事件(包括角色事件)、操纵杆(轴)事件和全局鼠标按钮事件。</p>
</li>
<li><p>mouseButtonFocus</p>
<p>关联:当鼠标位置包含在组件区域内时发生的鼠标按钮事件。</p>
</li>
<li><p>crossFocus</p>
<p>关联:鼠标输入事件，鼠标离开事件。</p>
</li>
<li><p>moveFocus</p>
<p>关联的:鼠标移动事件。</p>
</li>
<li><p>dragFocus</p>
<p>关联:删除事件。</p>
</li>
</ul>
<p>要让组件开始接收输入事件，必须将相应的属性设置为True，并将其不再接收事件设置为False，如下图所示:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># start receiving key/axis events</span></span><br><span class="line">c.focus = <span class="literal">True</span></span><br><span class="line"><span class="comment"># stop receiving mouse enter/leave events</span></span><br><span class="line">c.crossFocus = <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>当组件有一个脚本并且启用了焦点时，该脚本将开始捕获输入事件。</p>
<p>脚本必须定义适当的方法来处理事件。下面的例子演示了一个脚本，它定义了处理键盘和操纵杆(轴)事件的方法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Button</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handleKeyEvent</span>(<span class="params"> self, event </span>):</span><br><span class="line">        <span class="comment"># do whatever, and return 1 if </span></span><br><span class="line">        <span class="comment"># this key event was consumed</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handleAxisEvent</span>(<span class="params"> self, event </span>):</span><br><span class="line">        <span class="comment"># do whatever, and return 1 </span></span><br><span class="line">        <span class="comment"># if this axis event was consumed</span></span><br></pre></td></tr></table></figure>

<p>下面的小节描述了SimpleGUI支持的事件。更多信息请参见Client Python API的入口Main Page→Client→GUI→Classes→<strong>SimpleGUIComponent</strong>。</p>
<h4 id="17-5-1-Keyboard-Events"><a href="#17-5-1-Keyboard-Events" class="headerlink" title="17.5.1. Keyboard Events"></a><strong>17.5.1. Keyboard Events</strong></h4><p>键盘事件与键盘、鼠标和操纵杆按钮的输入有关。它们通过handleKeyEvent方法报告给脚本对象:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">handleKeyEvent</span>(<span class="params"> self, event</span>)</span><br></pre></td></tr></table></figure>

<p>参数说明如下:</p>
<ul>
<li><p>event</p>
<p>PyKeyEvent，包含关于该事件的信息。</p>
</li>
</ul>
<p>返回值为True意味着事件已被消耗，从而有效地防止它传播到其他组件或游戏脚本。返回值为False允许进一步传播。</p>
<p>要接收key事件，组件必须将属性focus设置为True。</p>
<p>注意，通过方法handleKeyEvent报告的鼠标按钮事件与通过handleMouseButtonEvent报告的不同之处在于，鼠标光标不必在组件定义的区域内，该组件才能捕获事件。捕获的唯一要求是将属性焦点设置为True，而不是在焦点列表中使用使用事件的其他组件。</p>
<p>字符事件附加到键事件。检查PyKeyEvent。字符参数，它将是包含完整翻译字符的字符串。否则它将是None。请记住，由于更复杂的输入法(如dead-key)，字符串的长度可以大于1。</p>
<h4 id="17-5-2-Axis-Events"><a href="#17-5-2-Axis-Events" class="headerlink" title="17.5.2. Axis Events"></a><strong>17.5.2. Axis Events</strong></h4><p>轴事件与操纵杆轴输入有关。它们通过handleAxisEvent方法报告给脚本对象:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">handleAxisEvent</span>(<span class="params"> self, axis, value, dTime </span>)</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li><p>event</p>
<p>PyAxisEvent，包含关于此事件的信息。</p>
</li>
</ul>
<p>返回值True意味着事件已经被消耗，有效地阻止它传播到其他组件或游戏脚本。返回值为False允许进一步传播。</p>
<p>要接收轴事件，组件必须将属性focus设置为True。</p>
<h4 id="17-5-3-Mouse-Events"><a href="#17-5-3-Mouse-Events" class="headerlink" title="17.5.3. Mouse Events"></a><strong>17.5.3. Mouse Events</strong></h4><p>鼠标事件可以分为三类:</p>
<ul>
<li>Button events</li>
<li>Cross events</li>
<li>Move events</li>
</ul>
<p>鼠标事件从鼠标光标下方的最顶部组件向下传播到底部组件，直到由组件处理为止(通过在其事件处理方法之一中返回True)。</p>
<p>下面的小节描述了如何处理来自每一类鼠标的输入</p>
<p>注意，鼠标事件只在MouseCursor对象处于活动状态时生成。</p>
<h4 id="17-5-3-1-Button-events"><a href="#17-5-3-1-Button-events" class="headerlink" title="17.5.3.1. Button events"></a><strong>17.5.3.1. Button events</strong></h4><p>​		按钮事件与鼠标按钮输入相关。它们通过方法handleMouseButtonEvent和handlemousecickevent报告给脚本对		象。</p>
<h5 id="17-5-3-1-1-handleMouseButtonEvent"><a href="#17-5-3-1-1-handleMouseButtonEvent" class="headerlink" title="17.5.3.1.1. handleMouseButtonEvent"></a><strong>17.5.3.1.1.</strong> <strong>handleMouseButtonEvent</strong></h5><p>​		这个方法是由SimpleGUI在mouseButtonFocus设置为True的鼠标最上面的组件上调用的:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">handleMouseButtonEvent</span>(<span class="params"> self, comp, event </span>)</span><br></pre></td></tr></table></figure>

<p>​		参数说明如下:</p>
<ul>
<li><p><strong>comp</strong></p>
<p>按钮被按下或释放的部件。</p>
</li>
<li><p><strong>event</strong></p>
<p>PyKeyEvent，包含关于该事件的信息。</p>
<p>返回值True意味着事件已经被消耗，有效地阻止它传播到其他组件或游戏脚本。返回值为False允许进一步传播。</p>
<p>要接收鼠标按钮事件，组件必须将mouseButtonFocus属性设置为True</p>
</li>
</ul>
<h5 id="17-5-3-1-2-handleMouseClickEvent"><a href="#17-5-3-1-2-handleMouseClickEvent" class="headerlink" title="17.5.3.1.2. handleMouseClickEvent"></a><strong>17.5.3.1.2.</strong> <strong>handleMouseClickEvent</strong></h5><p>​	   当在组件上按下并释放鼠标左键时，SimpleGUI将调用此方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">handleMouseClickEvent</span>(<span class="params"> self, comp, pos </span>)</span><br></pre></td></tr></table></figure>

<p>​		参数说明如下:</p>
<ul>
<li><p>comp</p>
<p>按钮被按到的组件。</p>
</li>
<li><p>pos</p>
<p>点击鼠标按钮时鼠标的位置。</p>
<p>Value是一个剪辑空间浮点数的2元组，范围从-1.0 (x轴最左，y轴最上)到1.0 (x轴最右，y轴最下)。</p>
</li>
</ul>
<p>返回值True意味着事件已经被消耗，有效地阻止它传播到其他组件或游戏脚本。返回值为False允许进一步传播。</p>
<p>要接收鼠标单击事件，组件必须将属性focus设置为True。</p>
<h4 id="17-5-3-2-Cross-events"><a href="#17-5-3-2-Cross-events" class="headerlink" title="17.5.3.2. Cross events"></a><strong>17.5.3.2. Cross events</strong></h4><p>交叉事件与鼠标指针进入或离开屏幕上组件定义的区域有关。它们通过方法handleMouseEnterEvent和handlemouseleevent报告给脚本对象。</p>
<p>handleMouseEnterEvent的签名描述如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">handleMouseEnterEvent</span>(<span class="params"> self, comp, pos </span>)</span><br></pre></td></tr></table></figure>

<p>handleMouseLeaveEvent的签名描述如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">handleMouseLeaveEvent</span>(<span class="params"> self, comp, pos </span>)</span><br></pre></td></tr></table></figure>

<p>两种方法的参数说明如下:</p>
<ul>
<li><p>comp</p>
<p>鼠标进入或离开的组件。</p>
</li>
<li><p>pos</p>
<p>进入或离开组件时鼠标的第一个位置。</p>
<p>Value是一个裁切空间浮点数的2元组，范围从-1.0 (x轴最左，y轴最上)到1.0 (x轴最右，y轴最下)。</p>
</li>
</ul>
<p>返回值True意味着事件已经被消耗，有效地阻止它传播到其他组件或游戏脚本。返回值为False允许进一步传播。</p>
<p>要接收鼠标进入和离开事件，组件必须将属性focus和crossFocus设置为True。</p>
<h4 id="17-5-3-3-Move-events"><a href="#17-5-3-3-Move-events" class="headerlink" title="17.5.3.3. Move events"></a><strong>17.5.3.3. Move events</strong></h4><p>移动事件与鼠标指针悬停在由屏幕中的组件定义的区域上有关。它们通过handleMouseEvent方法报告给脚本对象:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">handleMouseEvent</span>(<span class="params"> self, comp, event </span>)</span><br></pre></td></tr></table></figure>

<p>参数说明如下:</p>
<ul>
<li><p>comp</p>
<p>鼠标光标悬停在其上的组件。</p>
</li>
<li><p>event</p>
<p>PyMouseEvent，包含关于此事件的信息。</p>
</li>
</ul>
<p>返回值True意味着事件已经被消耗，有效地阻止它传播到其他组件或游戏脚本。返回值为False允许进一步传播。</p>
<p>要接收鼠标移动事件，组件必须将属性focus和moveFocus设置为True。</p>
<h4 id="17-5-4-Drag-and-drop-events"><a href="#17-5-4-Drag-and-drop-events" class="headerlink" title="17.5.4. Drag-and-drop events"></a><strong>17.5.4. Drag-and-drop events</strong></h4><p>SimpleGUI提供对拖放功能的支持。拖放事件可以分为两类:</p>
<ul>
<li>Drag event</li>
<li>Drop event</li>
</ul>
<p>下面的小节描述了如何处理每个类别的拖放事件的输入。注意，拖放事件只在MouseCursor处于活动状态时生成。</p>
<h4 id="17-5-4-1-Drag-events"><a href="#17-5-4-1-Drag-events" class="headerlink" title="17.5.4.1. Drag events"></a><strong>17.5.4.1. Drag events</strong></h4><p>拖动事件与用户正在拖动的组件相关。它们总是在被拖动的组件上生成，并通过方法handleDragStartEvent和handleDragStopEvent报告。</p>
<h5 id="17-5-4-1-1-handleDragStartEvent"><a href="#17-5-4-1-1-handleDragStartEvent" class="headerlink" title="17.5.4.1.1. handleDragStartEvent"></a><strong>17.5.4.1.1.</strong> <strong>handleDragStartEvent</strong></h5><p>当用户试图拖动组件时，会调用此方法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">handleDragStartEvent</span>(<span class="params"> self, comp, pos </span>)</span><br></pre></td></tr></table></figure>

<p>参数说明如下:</p>
<ul>
<li><p>comp</p>
<p>用户试图拖动的组件</p>
</li>
<li><p>pos</p>
<p>事件发生时鼠标的位置。</p>
<p>Value是一个剪辑空间浮点数的2元组，范围从-1.0 (x轴最左，y轴最上)到1.0 (x轴最右，y轴最下)。</p>
</li>
</ul>
<p>True的返回值向GUI管理器发出信号，表示此组件愿意被拖动，并使用该事件。返回值为False将防止拖拽组件，并允许进一步传播事件。</p>
<p>要接收此事件，组件必须将属性dragFocus设置为True。</p>
<h5 id="17-5-4-1-2-handleDragStopEvent"><a href="#17-5-4-1-2-handleDragStopEvent" class="headerlink" title="17.5.4.1.2. handleDragStopEvent"></a><strong>17.5.4.1.2.</strong> <strong>handleDragStopEvent</strong></h5><p>当用户释放鼠标左键，因此想要放下组件时，调用此方法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">handleDragStopEvent</span>(<span class="params"> self, comp, pos</span>)</span><br></pre></td></tr></table></figure>

<p>参数说明如下:</p>
<ul>
<li><p>comp</p>
<p>被拖动的组件。</p>
</li>
<li><p>pos</p>
<p>事件发生时鼠标的位置。</p>
<p>Value是一个剪辑空间浮点数的2元组，范围从-1.0 (x轴最左，y轴最上)到1.0 (x轴最右，y轴最下)。</p>
</li>
</ul>
<p>此方法的返回值总是被忽略，并允许原始鼠标按钮事件进一步传播。</p>
<p>要接收此事件，组件必须将属性dragFocus设置为True。</p>
<h4 id="17-5-4-2-Drop-events"><a href="#17-5-4-2-Drop-events" class="headerlink" title="17.5.4.2. Drop events"></a><strong>17.5.4.2. Drop events</strong></h4><p>删除事件与一个组件被删除到另一个组件上相关。它们总是在接收组件上生成，并通过handleDragEnterEvent、handleDragEnterEvent和handleDropEvent方法报告。</p>
<h5 id="17-5-4-2-1-handleDragEnterEvent"><a href="#17-5-4-2-1-handleDragEnterEvent" class="headerlink" title="17.5.4.2.1. handleDragEnterEvent"></a><strong>17.5.4.2.1.</strong> <strong>handleDragEnterEvent</strong></h5><p>当用户刚刚将另一个组件拖到这个组件上，但还没有删除它时，就会调用这个方法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">handleDragEnterEvent</span>(<span class="params"> self, comp, pos, dropped </span>)</span><br></pre></td></tr></table></figure>

<p>参数说明如下：</p>
<ul>
<li><p>comp</p>
<p>即将接收drop的组件。</p>
</li>
<li><p>pos</p>
<p>事件发生时鼠标的位置。</p>
<p>Value是一个剪辑空间浮点数的2元组，范围从-1.0 (x轴最左，y轴最上)到1.0 (x轴最右，y轴最下)。</p>
</li>
<li><p>dropped</p>
<p>被拖动的组件。</p>
</li>
</ul>
<p>此方法的返回值用于确定接收方组件是否愿意接受drop。此事件在第一次触发时总是被认为已使用，并且不会进一步传播原始的鼠标移动事件。</p>
<p>要接收此事件，组件必须将属性dropFocus设置为True。</p>
<h5 id="17-5-4-2-2-handleDragLeaveEvent"><a href="#17-5-4-2-2-handleDragLeaveEvent" class="headerlink" title="17.5.4.2.2. handleDragLeaveEvent"></a><strong>17.5.4.2.2.</strong> <strong>handleDragLeaveEvent</strong></h5><p>当被拖动的组件不再经过这个组件时，调用这个方法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">handleDragLeaveEvent</span>(<span class="params"> self, comp, pos </span>)</span><br></pre></td></tr></table></figure>

<p>参数如下：</p>
<ul>
<li><p>comp</p>
<p>即将接收drop的组件。</p>
</li>
<li><p>pos</p>
<p>事件发生时鼠标的位置。</p>
<p>Value是一个剪辑空间浮点数的2元组，范围从-1.0 (x轴最左，y轴最上)到1.0 (x轴最右，y轴最下)。</p>
</li>
</ul>
<p>返回值为True意味着事件已经被消耗，从而有效地阻止了最初的鼠标事件传播到其他组件或游戏脚本中。返回值为False允许进一步传播。</p>
<p>要接收此事件，组件必须将属性dropFocus设置为True。</p>
<h5 id="17-5-4-2-3-handleDropEvent"><a href="#17-5-4-2-3-handleDropEvent" class="headerlink" title="17.5.4.2.3. handleDropEvent?"></a><strong>17.5.4.2.3.</strong> <strong>handleDropEvent</strong>?</h5><p>当用户在这个组件上删除了一个组件时，这个方法会被调用:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">handleDropEvent</span>(<span class="params"> self, comp, pos, dropped </span>)</span><br></pre></td></tr></table></figure>

<p>参数如下：</p>
<ul>
<li><p>comp</p>
<p>接收drop的组件。</p>
</li>
<li><p>pos</p>
<p>事件发生时鼠标的位置。</p>
<p>Value是一个剪辑空间浮点数的2元组，范围从-1.0 (x轴最左，y轴最上)到1.0 (x轴最右，y轴最下)。</p>
</li>
<li><p>dropped</p>
<p>接收drop的组件。</p>
</li>
</ul>
<p>此方法的返回值总是被忽略，并允许原始鼠标按钮事件进一步传播。</p>
<p>要接收此事件，组件必须将属性dropFocus设置为True。</p>
<h4 id="17-5-5-Component-PyGUI"><a href="#17-5-5-Component-PyGUI" class="headerlink" title="17.5.5. Component PyGUI"></a><strong>17.5.5. Component PyGUI</strong></h4><p>您可能会发现用自定义GUI组件构建自己的Python模块很有用。为此，最好的起点是模块PyGUI。</p>
<p>PyGUI是基本GUI元素的非正式Python模块，为内部项目创建，定义在fantasydemo&#x2F;res&#x2F;scripts&#x2F;client&#x2F;Helpers&#x2F;PyGUI中。</p>
<p>从SimpleGUI本机组件提供的基本功能开始，您可以用Python编写自己的GUI工具包。下面是一些你可以创建的小工具的例子:</p>
<ul>
<li>Page control</li>
<li>Drop-down List</li>
<li>Edit field</li>
<li>Multi-line text field</li>
<li>Check box</li>
</ul>
<h3 id="17-6-Mouse-cursor"><a href="#17-6-Mouse-cursor" class="headerlink" title="17.6. Mouse cursor"></a><strong>17.6. Mouse cursor</strong></h3><p>可以通过游戏脚本控制鼠标光标的行为和外观。可以通过MouseCursor对象访问鼠标光标相关的函数和属性。</p>
<p>MouseCursor对象是一个单例对象，可以通过GUI.mcursor方法获得。</p>
<p>它公布的属性如下:</p>
<ul>
<li><p>postion –Read&#x2F;write</p>
<p>鼠标光标位置</p>
</li>
<li><p>shape–Read&#x2F;write</p>
<p>鼠标光标形状</p>
</li>
<li><p>visible–Read&#x2F;write</p>
<p>鼠标光标可见状态</p>
</li>
<li><p>active–Read-only</p>
<p>鼠标活动状态</p>
</li>
<li><p>clipped–Read&#x2F;write</p>
<p>当设置为true时，鼠标光标将被剪贴到客户端窗口所在的区域</p>
</li>
</ul>
<p>MouseCursor是抽象概念InputCursor的一个实例。在任何给定时间只能有一个活动的InputCursor。</p>
<p>要激活MouseCursor，使用BigWorld.setCursor方法。要停用它，请激活另一个输入游标，或将None传递给BigWorld.setCursor。</p>
<p>鼠标和拖放事件仅在MouseCursor处于活动状态时传播到GUI组件。</p>
<p>下面的代码演示了如何使用MouseCursor:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># access and modify the mouse cursor</span></span><br><span class="line"><span class="keyword">import</span> GUI</span><br><span class="line"><span class="keyword">import</span> BigWorld</span><br><span class="line"></span><br><span class="line">mc = GUI.mcursor()</span><br><span class="line">mc.shape = <span class="string">&quot;arrow&quot;</span></span><br><span class="line">mc.visible = <span class="literal">True</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> mc.active:</span><br><span class="line">    lastPosition = mc.position</span><br><span class="line">    mc.position = ( <span class="number">0.0</span>, <span class="number">0.0</span> )</span><br><span class="line">    BigWorld.setCursor( mc )</span><br><span class="line">    <span class="comment"># mc.active is now True</span></span><br></pre></td></tr></table></figure>



<h2 id="18-Fonts"><a href="#18-Fonts" class="headerlink" title="18. Fonts"></a><strong>18. Fonts</strong></h2><p>BigWorld有一个内置的字体生成和字形缓存系统。它支持大型国际字符集。在内部，BigWorld使用GDI+，并需要安装一个真实类型的字体文件来将字形绘制到字形缓存呈现目标中。作为一种替代方法，你可以使用预先缓存的字体地图来发行游戏，但是这种方法不支持动态字形的使用，因此不适用于大型字符集。</p>
<h3 id="18-1-Creating-and-Using-Fonts"><a href="#18-1-Creating-and-Using-Fonts" class="headerlink" title="18.1. Creating and Using Fonts"></a><strong>18.1. Creating and Using Fonts</strong></h3><p>要使用字体，必须首先创建一个描述字体样式、字体大小和所需效果的字体定义文件。一旦定义了字体，就可以使用该字体在屏幕上显示文本。在屏幕上显示文本的主要方法是通过Python GUI。文本组件。</p>
<h4 id="18-1-1-Creating-a-Font-Definition-File"><a href="#18-1-1-Creating-a-Font-Definition-File" class="headerlink" title="18.1.1. Creating a Font Definition File"></a><strong>18.1.1. Creating a Font Definition File</strong></h4><p>字体定义文件是一个XML文件，描述字体本身、字形缓存的大小和任何预加载字形的详细信息:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">example_font.font</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">creation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sourceFont</span>&gt;</span> Arial <span class="tag">&lt;/<span class="name">sourceFont</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sourceFontSize</span>&gt;</span> 16 <span class="tag">&lt;/<span class="name">sourceFontSize</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">effectsMargin</span>&gt;</span> 1 <span class="tag">&lt;/<span class="name">effectsMargin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">textureMargin</span>&gt;</span> 1 <span class="tag">&lt;/<span class="name">textureMargin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dropShadow</span>&gt;</span> true <span class="tag">&lt;/<span class="name">dropShadow</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">shadowAlpha</span>&gt;</span> 192 <span class="tag">&lt;/<span class="name">shadowAlpha</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bold</span>&gt;</span> true <span class="tag">&lt;/<span class="name">bold</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">creation</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">example_font.font</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>因为字体是动态生成的，它们的字形是在运行时缓存的，所以这就是开始使用新字体所需要做的全部工作。如果指定的源字体名称在系统上不存在，则Windows将自动选择最接近的匹配字体。为了避免任何潜在的问题，请确保您授权并在终端用户的系统上安装所需的真实类型的字体(例如，作为安装脚本的一部分)。如果您决定只选择Windows字体(并假设它们存在于终端用户的机器上)，那么请注意标准字体之间有很大的差异。</p>
<h5 id="18-1-1-1-Secondary-Font-Families"><a href="#18-1-1-1-Secondary-Font-Families" class="headerlink" title="18.1.1.1. Secondary Font Families"></a><strong>18.1.1.1. Secondary Font Families</strong></h5><p>为了允许在同一个文本字符串中混合不同的字符集，同时保持对每个字符集的呈现方式的控制，可以定义次要字体族。例如，latin-1(例如英语)字符可能需要使用Arial，但是Arial不是为呈现东亚字符集而设计的(如中国)。这意味着在渲染东亚角色时，需要制作手工艺品。</p>
<p>次要字体是在创建部分中使用一个或多个次要标记定义的。辅助字体由字体名称和用于选择使用哪一种辅助字体的Unicode范围组成。</p>
<p>例如，要使用Arial和中文，你可以使用SimSun添加第二种字体:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">example_font.font</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">creation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sourceFont</span>&gt;</span> Arial <span class="tag">&lt;/<span class="name">sourceFont</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">secondary</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">sourceFont</span>&gt;</span> SimSun <span class="tag">&lt;/<span class="name">sourceFont</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">unicodeRange</span>&gt;</span> U+2F00-U+9FFF <span class="tag">&lt;/<span class="name">unicodeRange</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">secondary</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">creation</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">example_font.font</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="18-1-2-Preloading-Glyphs"><a href="#18-1-2-Preloading-Glyphs" class="headerlink" title="18.1.2. Preloading Glyphs"></a><strong>18.1.2. Preloading Glyphs</strong></h4><p>对于字形数量有限的语言(例如英语)，您可能希望将所有字形预加载到缓存中，这样客户机就不必在运行时执行更多操作。此外，对于较大的亚洲语言，您可能仍然希望用一些常用的字形预加载缓存，然后让缓存在运行时处理那些不常用的字形。字形缓存系统仍然有效，但缓存将首先包含这些字形。此外，预加载的字形将永远不会离开缓存期间的客户端。</p>
<p>要预加载符号或一系列符号，请将下列标记的任意组合添加到字体定义文件中。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">startChar</span>&gt;</span> 32 <span class="tag">&lt;/<span class="name">startChar</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">endChar</span>&gt;</span> 192 <span class="tag">&lt;/<span class="name">endChar</span>&gt;</span></span><br><span class="line">or</span><br><span class="line"><span class="tag">&lt;<span class="name">unicodeChar</span>&gt;</span> U+3000 <span class="tag">&lt;<span class="name">unicodeChar</span>&gt;</span></span><br><span class="line">    and/or</span><br><span class="line"><span class="tag">&lt;<span class="name">unicodeRange</span>&gt;</span> U+AC00-U+D7A3 <span class="tag">&lt;/<span class="name">unicodeRange</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="18-1-3-Specifying-the-widest-character"><a href="#18-1-3-Specifying-the-widest-character" class="headerlink" title="18.1.3. Specifying the widest character"></a><strong>18.1.3. Specifying the widest character</strong></h4><p>字体符号被缓存到一个纹理中，并被定位在一个规则的网格上(即每个网格元素都是相同的宽度和高度)。为了预先确定每个网格元素的大小，字形缓存必须知道最宽字符的尺寸。默认情况下使用字母’W’来计算这个大小，但这可能对某些字符集(包括中文)不合适。如果最宽的字符太窄，则会出现视觉假象(字符会被剪切，相邻字符可能会相互“泄漏”)。如果太宽，那么纹理空间就会被浪费。</p>
<p>最宽字符可以使用字体定义文件中的&lt;widestChar&gt;标记设置。例如:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">example_font.font</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">creation</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">widestChar</span>&gt;</span> U+FF1F <span class="tag">&lt;/<span class="name">widestChar</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">creation</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">example_font.font</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="18-1-4-Displaying-Text"><a href="#18-1-4-Displaying-Text" class="headerlink" title="18.1.4. Displaying Text"></a><strong>18.1.4. Displaying Text</strong></h4><p>文本GUI组件是字体用于在屏幕上显示文本的主要方式。有关Text GUI组件及其python GUI的详细信息。文本对应，请参阅Python客户端API指南，在GUI.Text一节。GUI.Text类支持“font”属性，这指定了字体定义文件的名称，相对于字体根(参见文件 File Grammar Guide &#x2F; resources.xml，了解如何选择或更改字体根文件夹)。</p>
<p>下面是如何使用上述示例字体文件的示例，目前我们假定该文件已保存到$FONT_ROOT &#x2F; example_font.font。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> GUI</span><br><span class="line">t = GUI.Text( <span class="string">&quot;Some Text&quot;</span> )</span><br><span class="line">t.font = <span class="string">&quot;example_font.font&quot;</span></span><br><span class="line">GUI.addRoot(t)</span><br></pre></td></tr></table></figure>

<h3 id="18-2-Artist-modified-Fonts"><a href="#18-2-Artist-modified-Fonts" class="headerlink" title="18.2. Artist modified Fonts"></a><strong>18.2. Artist modified Fonts</strong></h3><p>内置字体或授权字体不一定符合你的游戏外观。例如，您可能希望使用有发光效果的字体，或内部渐变填充。在这些情况下，您可以选择将字形缓存的固定快照输出为.dds文件。然后，美术人员可以对这个文件进行处理，生成他们喜欢的任何字体效果。注意，这个过程只适用于一组固定的字形，因为客户端内部不具备重新创建艺术家修改字体的步骤的能力。</p>
<h4 id="18-2-1-Generating-a-Snapshot-of-a-Font’s-Glyph-Cache"><a href="#18-2-1-Generating-a-Snapshot-of-a-Font’s-Glyph-Cache" class="headerlink" title="18.2.1. Generating a Snapshot of a Font’s Glyph Cache"></a><strong>18.2.1. Generating a Snapshot of a Font’s Glyph Cache</strong></h4><p>python API包含一个函数BigWorld。saveFontCacheMap，将字体字形缓存的内容输出到DDS文件，并将字体指标的详细信息输出到.font文件。一旦这个快照被捕获，.font文件包含一个&lt;generated&gt;节，字体将不再使用字形缓存，或者能够在运行时生成任何新的字形。要恢复此更改，只需从.font文件中删除&lt;生成的&gt;部分，并删除.dds文件。纹理将被命名为$FONT_ROOT&#x2F;$FONTNAME_font.dds。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> BigWorld</span><br><span class="line">BigWorld.saveFontCacheMap( <span class="string">&quot;super_turbo.font&quot;</span> )</span><br><span class="line"><span class="comment">#this generates super_turbo.font.dds, super_turbo.font.generated, and super_turbo.font.grid.dds</span></span><br></pre></td></tr></table></figure>

<h4 id="18-2-2-Modifying-the-Font-Texture"><a href="#18-2-2-Modifying-the-Font-Texture" class="headerlink" title="18.2.2. Modifying the Font Texture"></a><strong>18.2.2. Modifying the Font Texture</strong></h4><p>一旦创建了快照，生成的font.dds文件就可以加载到Photoshop中(你可能需要下载并安装一个.dds文件插件，这取决于你使用的Photoshop版本)。然后可以自由修改字形，但是必须注意不要超出每个字符的指定边界。网格参考位图描述了行和不行区域，它的alpha通道有一个字形副本，提供形状信息，并简单地演示哪个字符到哪里去了。</p>
<p>修改完字体纹理后，只需将其保存在*.font.DDS文件，确保它和* .font.generated文件作为资产存储库的一部分提交。磁盘上这些文件的存在指示字体系统从现在开始使用生成的映射，并且永远不要尝试扩展字形缓存。如果遇到不存在作为生成的字形缓存一部分的字形，则将向调试窗口输出警告，并使用填充字符。</p>
<h4 id="18-2-3-Explaining-the-Font-Grid-dds-File"><a href="#18-2-3-Explaining-the-Font-Grid-dds-File" class="headerlink" title="18.2.3. Explaining the Font Grid .dds File"></a><strong>18.2.3. Explaining the Font Grid .dds File</strong></h4><p>下面是一个font.grid.dds文件的一部分，在photoshop中复制了3次，提取了各种颜色通道。你可以看到三个颜色通道，其中alpha通道用白色覆盖。</p>
<p><img src="/image%5Cbigworld%5C05_09.png" alt="05_09"></p>
<p>在左侧，红色通道描述了GDI+给出的原始字形矩形。正如您在示例中所看到的，W和&#x2F;字形位于该区域之外。这是因为这个特殊的字体已经应用了投影。投影，如引擎中提供的，是字形的副本，具有单个像素偏移。下面的绿色区域展示了这一点。</p>
<p>绿色区域描述符号区域加上效果边界，是引擎将绘制的矩形。在屏幕上绘制文本时，绿色区域外的任何像素都将被剪切。还要注意的是，当字形绘制在一起时，创建一个字符串或句子，红色区域(原始大小)决定字符之间的间距，任何效果边缘都由下一个字形重叠，这确保添加效果，如投影不会增加字符串的宽度。</p>
<p>蓝色区域用于描述符号区域、效果边界和纹理边界。纹理边缘用于填充纹理映射中的符号，以避免任何过滤伪影。纹理边缘永远不应该绘制，这是浪费了很多空间。如果你确定你的字体只会在像素和文本之间以1:1的比例绘制(例如，文本将永远不会缩小，或绘制在3D中，它可以旋转和mip-map发挥作用)，然后你可以安全地做任何纹理边缘。</p>
<h2 id="19-Input-Method-Editors-IME"><a href="#19-Input-Method-Editors-IME" class="headerlink" title="19. Input Method Editors (IME)"></a><strong>19. Input Method Editors (IME)</strong></h2><p>输入法编辑器(IME)是一种高级用户界面，用于输入东亚地区的输入文本，如中文，其中的字符集比实际上可以直接映射到键盘按钮的字符集大得多。这是Windows提供的一种机制，由当前安装的键盘布局决定。</p>
<p>不幸的是，Windows使用的默认IME接口覆盖了额外的子弹出窗口，这些窗口在游戏的上下文中不能很好地工作。这些弹出窗口将与Direct3D设备发生冲突（特别是在全屏模式下），不能剥离，而且，由于Windows不知道你的游戏用户界面，它将不能与你的游戏编辑控制保持一致。因此，为了很好地与游戏集成，并为用户提供流畅的体验，IME界面应该使用游戏内的GUI系统来呈现。</p>
<p>BigWorld引擎提供了一个API，它允许Python脚本响应操作系统生成的IME事件，并根据系统输入驱动的当前状态填充游戏内的IME。</p>
<p>目前支持的IME类型有:</p>
<ul>
<li>简体中文<ul>
<li>微软拼音</li>
<li>全拼</li>
<li>搜狗拼音</li>
<li>搜狗五笔</li>
<li>谷歌拼音</li>
</ul>
</li>
<li>繁体中文<ul>
<li>微软新语音IME</li>
</ul>
</li>
<li>日语<ul>
<li>微软IME</li>
</ul>
</li>
<li>韩文<ul>
<li>微软IME</li>
</ul>
</li>
</ul>
<p>本章描述如何设置Python脚本来响应IME事件并显示相应的接口。</p>
<p>除了这个文档之外，在fantasydemo&#x2F;res&#x2F;scripts&#x2F;client&#x2F;Helpers&#x2F;PyGUI&#x2F;IME.py中还有一个示例实现。这个脚本由PyGUI.EditField类使用。</p>
<p>请注意，如果启用Scaleform IME库，BigWorld IME系统将被禁用。</p>
<h3 id="19-1-Components-of-an-IME-interface"><a href="#19-1-Components-of-an-IME-interface" class="headerlink" title="19.1. Components of an IME interface"></a><strong>19.1. Components of an IME interface</strong></h3><p>有三个组成输入法编辑器的主要组件:</p>
<ul>
<li><p>Composition string</p>
<p>它包含用户用IME组成的字符，是用户完成后将发送给应用程序的字符串。复合字符串通常绘制在编辑控件上输入光标的当前位置。</p>
</li>
<li><p>Reading window</p>
<p>通常只在中文输入法中使用，它包含最近的尚未翻译成目标语言的击键。</p>
</li>
<li><p>Candidate list</p>
<p>这是一个基于复合字符串当前内容的候选字符列表。</p>
<p>用户可以使用箭头键来循环使用可用的选项，如果有多个页面的选项，则可以使用pageup和pagedown。通过按与候选列表项对应的数字键或按高亮显示项上的enter键来选择所需的候选项。</p>
</li>
</ul>
<p>一个特定的IME可以使用全部或部分组件。Python脚本使用PyIME对象来确定何时需要绘制特定组件(例如，BigWorld.ime.readingVisible标志可以用来确定在任何特定时间是否应该绘制阅读窗口)。</p>
<p>虽然不是严格意义上的IME本身的一部分，但在编辑控件上包括一个语言指示器作为视觉辅助是有用的，可以跟踪当前活动的语言。通过改变它的颜色，您还可以指示IME的当前状态(例如，IME当前是否处于字母-数字模式)。</p>
<h4 id="19-1-1-Examples"><a href="#19-1-1-Examples" class="headerlink" title="19.1.1. Examples"></a><strong>19.1.1. Examples</strong></h4><p><img src="/image%5Cbigworld%5C05_10.png" alt="05_10"></p>
<h4 id="19-1-2-Recommended-Reading"><a href="#19-1-2-Recommended-Reading" class="headerlink" title="19.1.2. Recommended Reading"></a><strong>19.1.2. Recommended Reading</strong></h4><p>[Installing and Using Input Method Editors, MSDN - <a target="_blank" rel="noopener" href="http://msdn.microsoft.com/en-us/library/bb174599%28VS.85%29.aspx]">http://msdn.microsoft.com/en-us/library/bb174599%28VS.85%29.aspx]</a></p>
<p>[Using an Input Method Editor in a Game, MSDN - <a target="_blank" rel="noopener" href="http://msdn.microsoft.com/en-us/library/bb206300%28VS.85%29.aspx]">http://msdn.microsoft.com/en-us/library/bb206300%28VS.85%29.aspx]</a></p>
<h3 id="19-2-IME-Python-API"><a href="#19-2-IME-Python-API" class="headerlink" title="19.2. IME Python API"></a><strong>19.2. IME Python API</strong></h3><p>BigWorld IME Python API是通过BigWorld访问的。输入法设置对象。这是一个PyIME类的单例实例。有关这里提到的所有方法和属性的详细信息，请参阅Python客户端API文档。</p>
<h4 id="19-2-1-Enabling-IME"><a href="#19-2-1-Enabling-IME" class="headerlink" title="19.2.1. Enabling IME"></a><strong>19.2.1. Enabling IME</strong></h4><p>默认是禁用的，可以从Python脚本中启用和禁用IME。通常，应用程序会在文本输入界面进入焦点(例如编辑框)时启用IME，在失去焦点时再次禁用IME。PyIME对象上的enabled属性控制当前状态:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BigWorld.ime.enabled = enableBoolean</span><br></pre></td></tr></table></figure>

<p>当IME被禁用时，内部状态将被重置。</p>
<h4 id="19-2-2-接收IME事件"><a href="#19-2-2-接收IME事件" class="headerlink" title="19.2.2. 接收IME事件"></a>19.2.2. 接收IME事件</h4><p>一旦IME系统被启用，引擎将开始向个性脚本发布事件。</p>
<h4 id="19-2-2-1-BWPersonality-handleInputLangChangeEvent"><a href="#19-2-2-1-BWPersonality-handleInputLangChangeEvent" class="headerlink" title="19.2.2.1. BWPersonality.handleInputLangChangeEvent"></a><strong>19.2.2.1. BWPersonality.handleInputLangChangeEvent</strong></h4><p>BWPersonality.handleInputLangChangeEvent将在用户切换当前输入语言时被调用。该函数不接受任何参数，因此处理程序应该检查BigWorld.ime.language属性和BigWorld.localeInfo函数来检查新的语言并进行相应的更新。</p>
<p>通常，应用程序会根据新语言更新语言指示器和&#x2F;或字体。</p>
<h4 id="19-2-2-2-BWPersonality-handleIMEEvent"><a href="#19-2-2-2-BWPersonality-handleIMEEvent" class="headerlink" title="19.2.2.2. BWPersonality.handleIMEEvent"></a><strong>19.2.2.2. BWPersonality.handleIMEEvent</strong></h4><p>每当用户执行一些导致内部IME状态被更改的操作（通常是击键）时，就会调用BWPersonality.handleIMEEvent。handleIMEEvent的唯一参数是一个PyIMEEvent对象。事件对象本身没有任何数据，而是有一组标志，指示哪些BigWorld.ime属性已经更新。当发生以下事件时，将调用handeIMEEvent函数：</p>
<ul>
<li>当前输入法状态已被更改(例如在日语中在字母数字模式和平假名模式之间切换)</li>
<li>复合字符串已被修改。</li>
<li>光标在复合字符串中的位置已被修改。</li>
<li>读取窗口字符串已更改。</li>
<li>读取窗口的可见性发生了变化。</li>
<li>候选列表的可见性发生了变化。</li>
<li>候选列表项已更改。</li>
<li>用户更改了候选列表中突出显示的项。</li>
</ul>
<h4 id="19-2-2-3-Finalising-characters"><a href="#19-2-2-3-Finalising-characters" class="headerlink" title="19.2.2.3. Finalising characters"></a><strong>19.2.2.3. Finalising characters</strong></h4><p>当用户在方法编辑器中输入完所需的文本后，他们将按回车键提交字符串。当这种情况发生时，BWPersonality.handleKeyEvent将会被调用，以key code Keys.KEY_IME_CHAR的形式发布。</p>
<h4 id="19-2-3-Displaying-the-IME"><a href="#19-2-3-Displaying-the-IME" class="headerlink" title="19.2.3. Displaying the IME"></a><strong>19.2.3. Displaying the IME</strong></h4><p>根据当前的底层状态实际显示IME接口的任务是Python脚本程序员的任务。IME表示脚本的复杂性取决于需要支持多少种语言，因为每种语言都有自己的IME表示标准方法。</p>
<p> 请注意，由于单个语言可用的不同IME的数量，以及Windows XP和Windows Vista之间的差异，建议尽可能多地跨这些不同的配置进行测试。</p>
<h2 id="20-BigWorld-Web-Integration"><a href="#20-BigWorld-Web-Integration" class="headerlink" title="20 . BigWorld Web Integration"></a><strong>20 . BigWorld Web Integration</strong></h2><p>BigWorld技术引擎现在包含了开源的Mozilla项目，可以作为客户端的一部分显示和交互网页。本文暂不介绍</p>
<h2 id="21-Sounds"><a href="#21-Sounds" class="headerlink" title="21. Sounds"></a><strong>21. Sounds</strong></h2><p>BigWorld通过第三方FMOD声音库(<a target="_blank" rel="noopener" href="http://www.fmod.org)提供声音支持.有关更多信息,请参阅文档“third-party/">www.fmod.org)提供声音支持。有关更多信息，请参阅文档“Third-Party</a> Integrations”。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/06/bigworld_05_01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Avatar.png">
      <meta itemprop="name" content="华">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keep Running">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Keep Running">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/11/06/bigworld_05_01/" class="post-title-link" itemprop="url">BIG WORLD 客户端编程指南01</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-11-06 11:20:31" itemprop="dateCreated datePublished" datetime="2024-11-06T11:20:31+08:00">2024-11-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-11-07 09:22:32" itemprop="dateModified" datetime="2022-11-07T09:22:32+08:00">2022-11-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/BigWorld/" itemprop="url" rel="index"><span itemprop="name">BigWorld</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="BIGWORLD-05-Client-Programming-Guide-01"><a href="#BIGWORLD-05-Client-Programming-Guide-01" class="headerlink" title="BIGWORLD_05_Client Programming Guide_01"></a>BIGWORLD_05_Client Programming Guide_01</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a><strong>1. 概述</strong></h2><p>本文档是3d引擎技术的客户端引擎的技术设计概述。它是描述整个系统的一组更大的文档的一部分。为了提供上下文，它只包含对BigWorld服务器的引用。只对BigWorld客户端工作感兴趣的读者可能会忽略服务器信息。</p>
<p>有关API的信息，请参阅在线文档。</p>
<h3 id="1-1-Client-in-context"><a href="#1-1-Client-in-context" class="headerlink" title="1.1. Client in context"></a><strong>1.1. Client in context</strong></h3><p>BigWorld客户端提供了 客户端&#x2F;服务端架构的最终用户体验。在BigWorld客户端&#x2F;服务器实现中，客户端通过Internet使用UDP&#x2F;IP连接到服务器。</p>
<p>BigWorld客户端为用户提供逼真的沉浸式3D环境。该环境的内容是存储在客户机中的静态数据和从服务器发送的动态数据的组合。</p>
<p>用户通过自己控制的角色与世界进行互动。角色的移动和动作被传递给服务器。由其他连接用户控制的虚拟化身是服务器发送的动态数据的一部分。</p>
<p><img src="/image%5Cbigworld%5C05_01.png" alt="图片"></p>
<p>开发人员可能会选择将客户端与他们自己的服务器技术集成，但如果他们这样做，他们将不得不解决BigWorld架构已经解决的问题，比如:</p>
<ul>
<li>统一的碰撞场景(客户端和服务端端使用)。</li>
<li>统一的客户机&#x2F;服务器脚本(用于客户端和服务端)。</li>
<li>生成服务器和客户端内容的工具。</li>
<li>优化的低带宽通信协议。</li>
</ul>
<h3 id="1-2-Outline"><a href="#1-2-Outline" class="headerlink" title="1.2. Outline"></a><strong>1.2. Outline</strong></h3><p>客户端初始化自己，连接到服务器，然后在它的主线程中运行一个标准的游戏循环(每一次迭代被称为一个帧):</p>
<ul>
<li>接受输入</li>
<li>更新世界</li>
<li>绘制世界</li>
</ul>
<p>框架的每一步(frame)描述如下:</p>
<p>​	• <strong>Input</strong></p>
<p>​		使用DirectInput从附加的输入设备接收输入。在BigWorld客户端&#x2F;服务器实现中，使用WinSock 2通过网络接收来自服务器的输入。</p>
<p>​	• <strong>Update</strong></p>
<p>​		更新世界以说明自上次更新以来所经过的时间。</p>
<p>​	• <strong>Draw</strong></p>
<p>​		游戏世界是使用3D引擎Moo绘制的，它使用的是Direct3D(版本9c)。具体操作请参见3D引擎。</p>
<p>许多其他对象也属于世界的“更新然后绘制”系统。其中包括十几种与天气和大气影响(雨、星星、雾、云等)有关的脚本辅助系统(瞄准、战斗)、水池、脚印和阴影。</p>
<p>还有其他线程用于后台场景加载和其他异步任务。</p>
<h3 id="1-3-Resource-search-paths"><a href="#1-3-Resource-search-paths" class="headerlink" title="1.3. Resource search paths"></a><strong>1.3. Resource search paths</strong></h3><p>BigWorld客户端是一个通用的可执行文件，可以通过游戏特定的资源进行完全配置。这些资源的位置必须提供给客户端，这样它才能正确初始化。</p>
<p>通常，至少需要指定两个资源路径-你的项目特定的资源路径和BigWorld资源路径(提供公共资源，如标准着色器，字体，脚本等)。例如，如果你的游戏位于“my_game”中，你将定义的两个资源路径是:</p>
<ul>
<li>my_game&#x2F;res</li>
<li>bigworld&#x2F;res</li>
</ul>
<p>当引擎试图访问一个资源时，它将按照资源树被赋予引擎的顺序查找每个资源树。例如，如果客户端脚本请求名为sets&#x2F;models&#x2F;foo的资源。模型它尝试以下位置:</p>
<ul>
<li><p>my_game&#x2F;res&#x2F;sets&#x2F;models&#x2F;foo.model</p>
</li>
<li><p>bigworld&#x2F;res&#x2F;sets&#x2F;models&#x2F;foo.model</p>
</li>
</ul>
<p>搜索将在找到第一个有效文件时停止。因此，可以通过将bigworld&#x2F;res中指定的资源放置在my_game&#x2F;res中的相同位置来覆盖它。</p>
<p>有两种方式可以指定搜索路径:</p>
<h4 id="1-3-1-paths-xml"><a href="#1-3-1-paths-xml" class="headerlink" title="1.3.1. paths.xml"></a><strong>1.3.1. paths.xml</strong></h4><p>paths.xml是一个XML文件，引擎将在启动时查找它，它包含一个资源路径列表。客户机将首先尝试打开当前工作目录中的paths.xml。如果在当前目录中找不到它，那么它将尝试在与客户端可执行文件相同的文件夹中打开paths.xml。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Paths</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Path</span>&gt;</span>../../my_game/res<span class="tag">&lt;/<span class="name">Path</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Path</span>&gt;</span>../../bigworld/res<span class="tag">&lt;/<span class="name">Path</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Paths</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>路径是相对于paths .xml的位置定义的。</p>
<h4 id="1-3-2-Command-line-switch"><a href="#1-3-2-Command-line-switch" class="headerlink" title="1.3.2. Command line switch"></a><strong>1.3.2. Command line switch</strong></h4><p>默认情况下，客户端将查找上面演示的paths.xml。然而，这可以通过命令行使用——res开关来重写。多条路径以分号分隔。例如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;bwclient.exe&quot; --res ../../../my_game/res;../../../bigworld/res</span><br></pre></td></tr></table></figure>

<p>这些路径必须相对于可执行位置而不是当前工作目录来定义。</p>
<h3 id="1-4-Configuration-files"><a href="#1-4-Configuration-files" class="headerlink" title="1.4. Configuration files"></a><strong>1.4. Configuration files</strong></h3><p>配置文件是相对于资源文件夹列表中的一个条目(或&lt;res&gt;)定义的。</p>
<h4 id="1-4-1-File-resources-xml"><a href="#1-4-1-File-resources-xml" class="headerlink" title="1.4.1. File resources.xml"></a><strong>1.4.1. File</strong> <strong>resources.xml</strong></h4><p>这个文件定义了客户端引擎运行所需要的游戏特定资源。</p>
<p>xml中的条目按照列出的顺序从资源文件夹列表(或&lt;res&gt;)中的各种条目中读取。只有缺失的条目才会在后续的文件夹中读取它们的值。</p>
<p>在bigworld&#x2F;res文件夹下存在一个默认文件，它的任何资源都可以通过创建自己的文件&lt;res&gt;&#x2F;resources.xml来覆盖。</p>
<p>下面的例子说明了这种机制:</p>
<p><img src="/image%5Cbigworld%5C05_02.png" alt="05_02"></p>
<h4 id="1-4-2-File-xml"><a href="#1-4-2-File-xml" class="headerlink" title="1.4.2. File .xml"></a><strong>1.4.2. File <engine_config>.xml</strong></h4><p>文件<engine_config>. XML列出了几个引擎配置选项。</p>
<p>这个文件的实际名称和位置是由resources.xml的&lt;engineConfigXML&gt;标记定义的。</p>
<p>xml文件的位置始终是相对于资源目录列表(或&lt;res&gt;)中的一个条目定义的，将按照它们列出的顺序对其进行搜索。</p>
<p>例如：</p>
<p><img src="/image%5Cbigworld%5C05_03.png"></p>
<p>在XML文件的主要部分下，必须包含一个个性标签，命名要使用的个性脚本。</p>
<p>这个文件中包含的数据作为init方法的<strong>第二个参数</strong>传递给个性脚本（详情参照init），以DataSection对象的形式。</p>
<h4 id="1-4-3-File-xml"><a href="#1-4-3-File-xml" class="headerlink" title="1.4.3. File .xml"></a><strong>1.4.3. File <scripts_config>.xml</strong></h4><p>XML文件<scripts_config>. XML可以用来配置游戏脚本。它没有固定的语法，它的形式可以由脚本程序员自由定义。</p>
<p>这个文件的实际名称和位置是由resources.xml的scriptsConfigXML标记定义的（参照<engine_config>.xml）。</p>
<p>这个文件中包含的数据作为init方法的<strong>第一个参数</strong>传递给个性脚本。</p>
<h4 id="1-4-4-File-lt-preferences-gt-xml"><a href="#1-4-4-File-lt-preferences-gt-xml" class="headerlink" title="1.4.4. File   &lt;preferences&gt;.xml"></a><strong>1.4.4. File   &lt;preferences&gt;.xml</strong></h4><p>文件&lt;preferences&gt;. XML用于保存视频和图形设置的用户首选项，具有预定义的语法。</p>
<p>该文件还嵌入了一个数据部分(称为scriptsPreference)，脚本可以使用它来保持游戏首选项——这个部分没有固定的语法。</p>
<p>该文件的实际名称和位置在resources.xml的engineConfigXML标记指定的文件中定义，在preferences项标记中。</p>
<p><img src="/image%5Cbigworld%5C05_04.png" alt="05_04"></p>
<p>默认情况下，perferences XML文件是相对于客户端可执行位置的，但这可以通过指定pathBase子标记更改为许多其他基本路劲（例如，它可以被定义为相对于用户的My Documents目录）。基本路径可以为首选项标记的可选子标记。preferences.xml的可用路径基础是：</p>
<ul>
<li>EXE_PAHT——preferences XML文件将相对于客户端可执行文件的位置进行存储。如果没有提供，这是默认位置。</li>
<li>CWD——preferencesXML文件将相对于当前工作目录存储。注意，如果工作目录在运行时发生更改，它将保存在新的工作目录中。</li>
<li>ROAMING_APP_DATA——preferences XML文件将相对于当前用户的漫游AppData目录存储（Roaming）。换句话说，如果用户在域上，当用户登录和退出Windows时，数据将与域控制器同步。</li>
<li>LOCAL_APP_DATA——preferences XML将相对于当前用户的本地AppData目录进行存储。</li>
<li>APP_DATA——这与ROAMING_APP_DATA相同。</li>
<li>MY_DOCS——preferences XML将相对于当前用户的My Documents目录进行存储。</li>
<li>MY_PICTURES——preferences XML将相对于当前用户的My Pictures目录进行存储</li>
<li>RES_TREE——preferences XML将相对于paths.xml中找到的第一个资源路径进行存储。</li>
<li>该文件的scriptsPreference中包含的数据以DataSection对象的形式，作为init方法的<strong>第三个参数</strong>传递给个性脚本。</li>
</ul>
<h3 id="1-5-Coordinate-System"><a href="#1-5-Coordinate-System" class="headerlink" title="1.5. Coordinate System"></a><strong>1.5. Coordinate System</strong></h3><p>左手坐标系，大拇指是y轴正方向，四指方向为x正半轴，手心方向为z正半轴。</p>
<ul>
<li>yaw——y轴的旋转，正是右边，负数是左边。</li>
<li>pitch——x轴的旋转，正是向下，负是向上。</li>
<li>roll——z轴的旋转，正是左边，负数是右边。</li>
</ul>
<h2 id="2-User-Input"><a href="#2-User-Input" class="headerlink" title="2. User Input"></a><strong>2. User Input</strong></h2><p>BigWorld客户端结合使用Windows消息和用于键盘和鼠标输入的Windows原始输入API。它读取键盘上的上键、下键和字符按下事件，以及鼠标上的高分辨率移动事件。它使用DirectInput API从操纵杆读取按钮和轴的移动事件。</p>
<h3 id="2-1-Key-events"><a href="#2-1-Key-events" class="headerlink" title="2.1. Key events"></a><strong>2.1. Key events</strong></h3><p>Key事件，由KeyEvent对象(BigWorld。(Python中的KeyEvent)，由具有键或按钮的设备生成。这包括键盘、鼠标按钮和操纵杆按钮。</p>
<p>键事件的两种基本类型是key-down和key-up。</p>
<h4 id="2-1-1-Character-events"><a href="#2-1-1-Character-events" class="headerlink" title="2.1.1. Character events"></a><strong>2.1.1. Character events</strong></h4><p>如果一个KeyEvent是由键盘生成的，它可能会附加一个字符。由特定键生成的字符由操作系统中当前设置的区域设置和输入语言决定，并由KeyEvent表示。字符成员(Unicode字符串)。</p>
<h4 id="2-1-2-Auto-repeat"><a href="#2-1-2-Auto-repeat" class="headerlink" title="2.1.2. Auto-repeat"></a><strong>2.1.2. Auto-repeat</strong></h4><p>根据用户的操作系统设置(例如重复延迟)，当按键被按下时，键盘将自动生成重复事件。鼠标和操纵杆不会产生自动重复事件。</p>
<p>自动重复事件作为额外的按下键事件发送，但是不希望处理重复事件的脚本可以调用KeyEvent。isRepeatedEvent方法来确定它是否是一个自动重复事件。</p>
<h4 id="2-1-3-Sequence-of-events"><a href="#2-1-3-Sequence-of-events" class="headerlink" title="2.1.3. Sequence of events"></a><strong>2.1.3. Sequence of events</strong></h4><p>当用户按下一个按钮(键盘、鼠标或操纵杆)时，事件序列如下:</p>
<ul>
<li>第一个是key-down事件。</li>
<li>如果保持按下该键，则由于自动重复(仅键盘)而引发多个按下键事件。</li>
<li>当用户释放按钮时，会触发一个key-up事件。</li>
</ul>
<p>用户输入模块的输出由许多其他模块处理，这些模块依次检查事件并使用或忽略它们。如果一个事件没有被任何模块使用，那么它将被丢弃。在事件中轮到的模块的顺序如下:</p>
<ul>
<li>Debug —— 特殊的keys、控制台等</li>
<li>Personality script —— 全局的keys</li>
<li>Application —— 硬编码的键，如QUIT。</li>
<li>Player script —— 剩下的，是处理的主要部分。</li>
</ul>
<p>注意，GUI系统不会自动接收输入，而是由脚本编写来选择何时接收输入。这可以是在个性脚本中，也可以是在玩家脚本中。最明显的地方是在个性脚本回调中，例如在个性脚本的handleKeyEvent中，您应该调用GUI.handleKeyEvent()并检查返回值。</p>
<p>类似地，活动摄像头也不会自动接收输入事件。由Python脚本决定相机何时何地接收用户输入。</p>
<h4 id="2-1-4-Sinking-events"><a href="#2-1-4-Sinking-events" class="headerlink" title="2.1.4. Sinking events"></a><strong>2.1.4. Sinking events</strong></h4><p>BigWorld客户端执行事件匹配以确保模块行为的一致性。如果一个按下键事件被一个模块使用，那么该模块的标识符将被记录为事件键号的接收器。当相应的自动重复和key-up事件到达时，它将直接交付到该模块。例如，如果聊天控制台在玩家运行时弹出(并插入到列表中)，用户随后释放了运行键，那么玩家脚本仍然会获得该键的key-up事件，并能够停止运行操作。</p>
<p>在某些情况下，可能希望暂时阻止将某些关键事件传递到脚本中。GUI脚本可以通过删除当前GUI屏幕并用新的GUI屏幕替换它来处理按下键事件。默认情况下，因为当handleKeyEvent返回时，新的GUI屏幕已经成为活动屏幕，旧的GUI任何相关的自动重复和键上事件将被发布到新的GUI屏幕，创建可能不想要的行为。</p>
<p> BigWorld.sinkKeyEvents函数可以可用于停止给定键代码的所有键事件到达脚本，直到(包括)下一个键上。</p>
<h4 id="2-1-5-Mouse-cursor-position"><a href="#2-1-5-Mouse-cursor-position" class="headerlink" title="2.1.5. Mouse cursor position"></a><strong>2.1.5. Mouse cursor position</strong></h4><p>当一个关键事件发生时，通常需要知道鼠标在哪里(即，而不是处理事件时鼠标在哪里)，特别是在处理鼠标按钮事件时。因此，鼠标光标的位置可以通过KeyEvent.cursorPosition属性获得，应该尽可能用来代替GUI.mcursor().position。</p>
<h3 id="2-2-Mouse"><a href="#2-2-Mouse" class="headerlink" title="2.2. Mouse"></a><strong>2.2. Mouse</strong></h3><h4 id="2-2-1-Movement"><a href="#2-2-1-Movement" class="headerlink" title="2.2.1. Movement"></a><strong>2.2.1. Movement</strong></h4><p>高分辨率的鼠标移动事件作为MouseEvent发送到脚本。该对象提供了三个方向增量。</p>
<ul>
<li>dx和dy成员是有符号整数，表示鼠标在X和Y方向的移动。</li>
<li>dz成员表示鼠标滚轮的移动。</li>
</ul>
<p><strong>如果在一帧内从驱动程序到达多个鼠标增量，它们会累积到一个MouseEvent中。</strong></p>
<p>与KeyEvent对象类似，事件发生时的鼠标光标位置可以作为MouseEvent对象的成员使用。</p>
<h4 id="2-2-2-Buttons"><a href="#2-2-2-Buttons" class="headerlink" title="2.2.2. Buttons"></a><strong>2.2.2. Buttons</strong></h4><p>鼠标按钮作为一个KeyEvent发送，但是它们不生成自动重复事件。</p>
<h3 id="2-3-Joystick"><a href="#2-3-Joystick" class="headerlink" title="2.3. Joystick"></a><strong>2.3. Joystick</strong></h3><p>BigWorld客户端将自动检测连接到系统的第一个操纵杆设备，并被设计用于双操纵杆风格的操纵杆。</p>
<h4 id="2-3-1-Axis-events"><a href="#2-3-1-Axis-events" class="headerlink" title="2.3.1. Axis events"></a><strong>2.3.1. Axis events</strong></h4><p>当轴事件发生时，它们将通过handleAxisEvent角色脚本函数作为AxisEvent对象发送到脚本。</p>
<h4 id="2-3-2-Buttons"><a href="#2-3-2-Buttons" class="headerlink" title="2.3.2. Buttons"></a><strong>2.3.2. Buttons</strong></h4><p>操纵杆按钮作为一个KeyEvent发送，但是它们不生成自动重复事件。</p>
<h4 id="2-3-3-Controlling-player-direction"><a href="#2-3-3-Controlling-player-direction" class="headerlink" title="2.3.3. Controlling player direction"></a><strong>2.3.3. Controlling player direction</strong></h4><p>c++引擎会自动将轴事件传递给活动光标，因此使用BigWorld.setCursor将方向光标设置为活动光标，就可以通过操纵杆控制方向光标。方向光标将处理由右轴生成的任何事件。</p>
<h4 id="2-3-4-Avatar-movement"><a href="#2-3-4-Avatar-movement" class="headerlink" title="2.3.4. Avatar movement"></a><strong>2.3.4. Avatar movement</strong></h4><p>c++引擎也将给予物理子系统处理轴事件的机会。物理将轴输入作为一种特殊情况，并将根据用户向前推动操纵杆的距离来调整移动速度。</p>
<p>为了使操纵杆支持运动物理，设置Physics.joystickEnabled属性为True，并确保将joystickFwdSpeed和joystickBackSpeed属性设置为适合你的游戏的值。</p>
<h2 id="3-Cameras"><a href="#3-Cameras" class="headerlink" title="3. Cameras"></a><strong>3. Cameras</strong></h2><p>在一般的更新过程中，相机更新的位置是一个微妙的问题，因为相机依赖于一些组件已经在它之前更新，而其他组件依赖于相机在它们之前更新。</p>
<p>从概念上讲，相机有四种类型:fixed camera、FlexiCam、cursor camera和free camera。前三个是客户端控制的视图，范围从最小的用户交互到最大的用户交互。最后一个镜头是完全由用户控制的，但并不是真正的游戏玩法的一部分。</p>
<p>然而，只有三个相机类:FlexiCam、CursorCamera和FreeCamera。固定摄像机是用FlexiCam对象实现的。它们都派生自一个公共的BaseCamera类。</p>
<p>每次只有一个活动摄像头。个性脚本通常处理摄像机管理，因为摄像机是全局的，但任何脚本也可以处理摄像机，而玩家脚本通常就是这样做的(虽然通常是间接地，通过个性脚本)。</p>
<p>Python完全可以访问基类和所有派生类。任何摄像机都可以被创建并设置为脚本所希望的任何位置，包括另一个摄像机的位置。这在切换摄像机类型以删除任何不想要的“跳切”时特别有用。</p>
<h3 id="3-1-The-Cursor-Camera"><a href="#3-1-The-Cursor-Camera" class="headerlink" title="3.1. The Cursor Camera"></a><strong>3.1. The Cursor Camera</strong></h3><p>cursor camera是在游戏世界中跟随角色的摄像机。它总是将自己定位在一个以角色头部为中心的球体上。它主要与方向光标一起工作，以便在角色头部的方向上面对摄像机。你可以使用任何MatrixProvider来代替方向光标，也可以使用任何MatrixProvider来代替玩家的头部。</p>
<p>方向光标是一个输入处理程序，它将用户的设备输入转换为在一个看不见的球体上移动的假想光标的操作。这个光标由pitch和yaw来描述。它产生一个指向向量，从玩家角色在世界空间中的头部位置延伸到光标的pithc和yaw。方向光标是一个很有用的工具，它允许在不同的设备上进行瞄准。与其让每个设备影响摄像机和角色网格，不如让每个设备与方向光标对话，从而影响其在世界中的视觉向量。游标摄像机、目标跟踪器和动作匹配器然后读取方向游标，以获取关于需要做什么的信息。</p>
<p>光标摄像机占据了方向光标在球体上的位置，将线延伸回角色的头部，并沿着这条线直到它与另一侧的球体相交。这个交点就是光标相机的位置。摄像机的方向总是方向光标的方向。</p>
<p>游标摄像机是抽象概念InputCursor的一个实例。任何时候只能有一个活动的InputCursor, BigWorld会自动将键盘、操纵杆和鼠标事件转发给它。在启动时，光标摄像头默认是活动的InputCursor。您可以使用BigWorld.setCursor方法在任何时候更改活动的InputCursor。(例如将InputCursor改为鼠标指针)。</p>
<h4 id="3-2-The-Free-Camera"><a href="#3-2-The-Free-Camera" class="headerlink" title="3.2. The Free Camera"></a><strong>3.2. The Free Camera</strong></h4><p>自由相机是一个自由漫游的相机，它既不局限于空间中的一个固定点，也不跟随玩家的角色。它由鼠标(控制方向)和键盘(控制移动)控制，并允许用户在世界各地飞行。自由相机具有惯性，以便在运动中提供平滑、渐进的过渡。它不是一个游戏镜头，但对游戏的调试、开发和演示很有用。</p>
<h4 id="3-3-The-FlexiCam"><a href="#3-3-The-FlexiCam" class="headerlink" title="3.3. The FlexiCam"></a><strong>3.3. The FlexiCam</strong></h4><p>FlexiCam是一个灵活的摄像机，可以跟踪游戏世界中的角色。它总是将自己定位在一个特定的点上，相对于角色的方向，并且总是看着一个特定的方向，相对于角色的脚的方向。</p>
<p>它被称为FlexiCam，因为它的移动有一定的弹性，可以直观地感受到速度。这使得它在追赶车辆时特别有用。</p>
<h2 id="4-Terrain"><a href="#4-Terrain" class="headerlink" title="4. Terrain"></a><strong>4. Terrain</strong></h2><p>BigWorld客户端使用的地形系统与分块系统巧妙地集成在一起。它允许以艺术的方式创建各种各样的地形，并有效地管理。有两种不同的地形渲染器，针对不同的机器规格。它们被称为高级地形和简单地形。</p>
<h3 id="4-1-Advanced-Terrain"><a href="#4-1-Advanced-Terrain" class="headerlink" title="4.1. Advanced Terrain"></a><strong>4.1. Advanced Terrain</strong></h3><h4 id="4-1-1-Overview"><a href="#4-1-1-Overview" class="headerlink" title="4.1.1. Overview"></a><strong>4.1.1. Overview</strong></h4><p>这种先进的地形引擎使用一种高度地图，将高度地图分成100米乘100米的区块。每个块由高度和纹理信息、法线、洞图和LOD信息组成。</p>
<h4 id="4-1-2-Key-Features"><a href="#4-1-2-Key-Features" class="headerlink" title="4.1.2. Key Features"></a><strong>4.1.2. Key Features</strong></h4><ul>
<li><p>可配置的高度映射分辨率</p>
</li>
<li><p>无限数量的纹理级别与可配置的混合分辨率和投影角度</p>
</li>
<li><p>可配置法线映射分辨率</p>
</li>
<li><p>可配置孔图分辨率</p>
</li>
<li><p>每像素照明</p>
</li>
<li><p>LOD系统</p>
<ul>
<li>地形多重贴图和几何图形</li>
<li>法线贴图LOD</li>
<li>纹理LOD</li>
<li>高度图LOD</li>
</ul>
</li>
</ul>
<h4 id="4-1-3-Texturing"><a href="#4-1-3-Texturing" class="headerlink" title="4.1.3. Texturing"></a><strong>4.1.3. Texturing</strong></h4><p>纹理是通过将多个纹理层混合在一起来完成的，每个纹理层都有自己的投影角度和混合值来与其他纹理层混合。混合值的分辨率可按空间进行配置，而层本身则按块存储。纹理被假定为rgba与alpha通道用于高光值。</p>
<h4 id="4-1-4-Lighting"><a href="#4-1-4-Lighting" class="headerlink" title="4.1.4. Lighting"></a><strong>4.1.4. Lighting</strong></h4><p>高级地形的照明是按像素执行的。法线贴图存储在每个块上，用于照明计算，这与混合纹理结合输出最终的颜色。地形允许高达8漫射和6个镜面光每个块。关于如何计算高光照明的细节，请参照<em><strong>Terrain specular lighting</strong></em>。</p>
<h4 id="4-1-5-Shadows"><a href="#4-1-5-Shadows" class="headerlink" title="4.1.5. Shadows"></a><strong>4.1.5. Shadows</strong></h4><p>地形使用了一个地平线阴影地图进行阴影遮盖，这个地图存储了两个角度(东和西)，在这两个角度之间有一个从地形上畅通无阻的天空视图。在地形着色器中，这些角度根据太阳角度进行检查，只有当太阳角度落在地平线角度之间时，太阳光线才会被应用。</p>
<h4 id="4-1-6-LOD"><a href="#4-1-6-LOD" class="headerlink" title="4.1.6. LOD"></a><strong>4.1.6. LOD</strong></h4><p>LOD系统的目的是减少cpu和gpu渲染地形所花费的时间，地形LOD系统通过减少距离中的几何和纹理细节并根据需要加载&#x2F;卸载高分辨率资源来实现这一点。</p>
<p>LODing被资源分割，这样纹理和几何细节就可以分别进行流处理。LOD距离在空间中可配置。配置文件请看 <em><strong>“terrain section in space.settings”</strong></em></p>
<h5 id="4-1-6-1-Geometry"><a href="#4-1-6-1-Geometry" class="headerlink" title="4.1.6.1. Geometry"></a><strong>4.1.6.1. Geometry</strong></h5><p>几何LOD是通过geo-mipmaps和geo-morphing实现的。Geo-mipmaps是由地形块的高分辨率法线图生成的。根据距离摄像机的x&#x2F;z距离，显示较低分辨率的地形块。为了避免在不同分辨率的高度地图之间改变时弹出，我们使用了地理变形，这允许引擎在两个高度地图关卡之间平滑地插入。退化三角形被插入到不同大小的块之间，以避免闪光。</p>
<h5 id="4-1-6-2-Collision-Geometry"><a href="#4-1-6-2-Collision-Geometry" class="headerlink" title="4.1.6.2. Collision Geometry"></a><strong>4.1.6.2. Collision Geometry</strong></h5><p>碰撞几何使用两个不同的分辨率进行流处理(streamed)。低分辨率的碰撞总是存在的，而高分辨率的碰撞则取决于它们与摄像机的x-z距离。</p>
<h5 id="4-1-6-3-Texture"><a href="#4-1-6-3-Texture" class="headerlink" title="4.1.6.3. Texture"></a><strong>4.1.6.3. Texture</strong></h5><p>纹理LOD是通过将多层混合替换为一个自上而下的地形块图像来实现的。基于与相机的x-z距离平滑地融合LOD图像。自顶向下的图像是在World Editor中生成的。</p>
<h5 id="4-1-6-4-Normal-maps"><a href="#4-1-6-4-Normal-maps" class="headerlink" title="4.1.6.4. Normal maps"></a><strong>4.1.6.4. Normal maps</strong></h5><p>法线贴图LOD是通过使用低分辨率和高分辨率贴图来实现的。低分辨率的法线贴图总是可用的，而高分辨率的贴图则是基于与相机的x-z距离进行混合。法线贴图是在World Editor中生成的。LOD法线贴图的大小是法线贴图分辨率的16倍或32x32，取较大的值。</p>
<h4 id="4-1-7-Memory-footprint"><a href="#4-1-7-Memory-footprint" class="headerlink" title="4.1.7. Memory footprint"></a><strong>4.1.7. Memory footprint</strong></h4><p>由于高级地形允许许多配置选项，地形的内存占用取决于所选择的选项。</p>
<p>在Fantasydemo的例子中，地形开销如下(这些信息是通过Fantasydemo客户端中的资源计数器获取的，图像设置为高，远平面设置为1500米):</p>
<p>(这包括纹理层使用的纹理，也可能被其他资产使用)</p>
<table>
<thead>
<tr>
<th align="left">Component</th>
<th>Size</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Conllison data</td>
<td>42453517</td>
</tr>
<tr>
<td align="left">Vertex buffers</td>
<td>6169008</td>
</tr>
<tr>
<td align="left">Index buffers</td>
<td>536352</td>
</tr>
<tr>
<td align="left">Texture layers</td>
<td>57541905</td>
</tr>
<tr>
<td align="left">Shaowmaps</td>
<td>26361856</td>
</tr>
<tr>
<td align="left">LOD textures</td>
<td>35148605</td>
</tr>
<tr>
<td align="left">Hole maps</td>
<td>4096</td>
</tr>
<tr>
<td align="left">Normal maps</td>
<td>6572032</td>
</tr>
<tr>
<td align="left"><strong>Total</strong></td>
<td><strong>174787371</strong></td>
</tr>
</tbody></table>
<p><em>地形的内存使用表</em></p>
<h4 id="4-1-8-terrain2-resources"><a href="#4-1-8-terrain2-resources" class="headerlink" title="4.1.8. terrain2 resources"></a><strong>4.1.8.</strong> <strong>terrain2</strong> <strong>resources</strong></h4><p>一个terrain2部分包含在一个chunk的.cdata文件中。它包含块中地形的所有资源。不同类型的地形数据将在以BNF格式进行描述。</p>
<h5 id="4-1-8-1-heights-sections"><a href="#4-1-8-1-heights-sections" class="headerlink" title="4.1.8.1. heights sections"></a><strong>4.1.8.1.</strong> <strong>heights</strong> <strong>sections</strong></h5><p>高度部分存储地形块的高度地图。在块中存储多个高度部分，每个LOD级别一个，每个高度部分以前一个分辨率的一半存储数据。高度部分被命名为“heights?” ?为具体高度。最高的分辨率高度图存储在名为heights的区域中，第二高的存储在名为heights1的区域中，一直到存储2x2高度的地图。这样，如果高度地图分辨率是128x128, 7个高度地图存储在文件中(heights, heights1，…heights6)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;heightMap&gt; ::= &lt;header&gt;&lt;heightData&gt;</span><br><span class="line">&lt;header&gt; ::= &lt;magic&gt;&lt;width&gt;&lt;height&gt;&lt;compression&gt;&lt;version&gt;&lt;minHeight&gt;&lt;maxHeight&gt;&lt;padding&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>&lt;magic&gt;</strong></p>
<p>uint32 0x00706d68 (string “hmp\0”)</p>
</li>
<li><p><strong>&lt;width&gt;</strong></p>
<p>包含宽度数据的Uint32</p>
</li>
<li><p><strong>&lt;height&gt;</strong></p>
<p>包含高度数据的Uint32</p>
</li>
<li><p><strong>&lt;compression&gt;</strong></p>
<p>(未使用)包含压缩类型的uint32</p>
</li>
<li><p><strong>&lt;version&gt;</strong></p>
<p>包含数据版本的Uint32，当前为4</p>
</li>
<li><p><strong>&lt;minHeight&gt;</strong></p>
<p>浮点数，包含此块的最小高度</p>
</li>
<li><p><strong>&lt;maxHeight&gt;</strong></p>
<p>浮点数，包含此块的最大高度</p>
</li>
<li><p><strong>&lt;padding&gt;</strong></p>
<p>4个字节的填充使头部16字节对齐</p>
</li>
<li><p><strong>&lt;heightData&gt;</strong></p>
<p>PNG压缩块，长度为int32，存储高度，单位为毫米，尺寸&#x3D;宽度*高度</p>
</li>
</ul>
<h5 id="4-1-8-2-layer-sections"><a href="#4-1-8-2-layer-sections" class="headerlink" title="4.1.8.2. layer sections"></a><strong>4.1.8.2.</strong> <strong>layer</strong> <strong>sections</strong></h5><p>层段存储地形块的纹理层。多个层段存储在地形块中。每个部分描述一个纹理层。</p>
<p>图层部分命名为“layer ?”?被一个大于1的数字所代替。例如，如果块有3个层，那么3个层的section将被存储(“layer1”， “layer 2”， “layer 3”)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;textureLayer&gt; ::= &lt;header&gt;&lt;textureName&gt;&lt;blendData&gt;</span><br><span class="line">&lt;header&gt; ::=&lt;magic&gt;&lt;width&gt;&lt;height&gt;&lt;bpp&gt;&lt;uProjection&gt;&lt;vProjection&gt;&lt;version&gt;&lt;padding&gt;</span><br><span class="line">&lt;textureName&gt; ::= &lt;length&gt;&lt;string&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>&lt;magic&gt;</strong></p>
<p>uint32 0x00646c62 (string bld&#x2F;0”)</p>
</li>
<li><p><strong>&lt;width&gt;</strong></p>
<p>包含宽度数据的Uint32</p>
</li>
<li><p><strong>&lt;height&gt;</strong></p>
<p>包含高度数据的Uint32</p>
</li>
<li><p><strong>&lt;bpp&gt;</strong></p>
<p>(未使用)uint32，包含层数据中条目的大小</p>
</li>
<li><p><strong>&lt;uProjection&gt;</strong></p>
<p>Vector4包含纹理层u坐标的投影</p>
</li>
<li><p><strong>&lt;vProjection&gt;</strong></p>
<p>Vector4包含纹理层v坐标的投影</p>
</li>
<li><p><strong>&lt;version&gt;</strong></p>
<p>包含数据版本的Uint32，当前为2</p>
</li>
<li><p><strong>&lt;padding&gt;</strong></p>
<p>12个字节的填充使头部16字节对齐</p>
</li>
<li><p><strong>&lt;length&gt;</strong></p>
<p>texturename字符串的长度</p>
</li>
<li><p><strong>&lt;string&gt;</strong></p>
<p>此层使用的纹理的名称</p>
</li>
<li><p><strong>&lt;blendData&gt;</strong></p>
<p>PNG压缩的uint8块定义了纹理层在每个x&#x2F;z位置的强度</p>
</li>
</ul>
<h5 id="4-1-8-3-normals-amp-lodNormals-sections"><a href="#4-1-8-3-normals-amp-lodNormals-sections" class="headerlink" title="4.1.8.3. normals &amp; lodNormals sections"></a><strong>4.1.8.3.</strong> <strong>normals</strong> <strong>&amp;</strong> <strong>lodNormals</strong> <strong>sections</strong></h5><p>法线部分存储地形块的高分辨率法线贴图。lodNormals部分存储高度块的LOD法线，LOD法线通常是法线大小的1&#x2F;16。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;normals&gt; ::= &lt;header&gt;&lt;data&gt;</span><br><span class="line">&lt;header&gt; ::= &lt;magic&gt;&lt;version&gt;&lt;padding&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>&lt;magic&gt;</strong></p>
<p>uint32 0x006d726e (string “nrm&#x2F;0”)</p>
</li>
<li><p><strong>&lt;version&gt;</strong></p>
<p>包含数据版本的Uint32，当前为1</p>
</li>
<li><p><strong>&lt;padding&gt;</strong></p>
<p>8个字节的填充使头部16字节对齐</p>
</li>
<li><p><strong>&lt;data&gt;</strong></p>
<p>对于法线的x和z分量，PNG压缩块存储2个符号字节，y分量在着色器中计算</p>
</li>
</ul>
<h5 id="4-1-8-4-holes-section"><a href="#4-1-8-4-holes-section" class="headerlink" title="4.1.8.4. holes section"></a><strong>4.1.8.4.</strong> <strong>holes</strong> <strong>section</strong></h5><p>洞部分存储地形块的全息图，只有当地形块中有洞时，这个部分才存储。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;holes&gt; ::= &lt;header&gt;&lt;data&gt;</span><br><span class="line">&lt;header&gt; ::= &lt;magic&gt;&lt;width&gt;&lt;height&gt;&lt;version&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>&lt;magic&gt;</strong></p>
<p>uint32 0x006c6f68 (string “hol&#x2F;0”)</p>
</li>
<li><p><strong>&lt;width&gt;</strong></p>
<p>包含数据宽度的Uint32</p>
</li>
<li><p><strong>&lt;height&gt;</strong></p>
<p>包含数据高度的Uint32</p>
</li>
<li><p><strong>&lt;version&gt;</strong></p>
<p>包含数据版本的Uint32，当前为1</p>
</li>
<li><p><strong>&lt;data&gt;</strong></p>
<p>将洞数据存储在一个宽度*高度的位域中，数据中的每一行被四舍五入到1字节。如果位设置为1，则表示映射中有一个洞。</p>
</li>
</ul>
<h5 id="4-1-8-5-horizonShadows-section"><a href="#4-1-8-5-horizonShadows-section" class="headerlink" title="4.1.8.5. horizonShadows section"></a><strong>4.1.8.5.</strong> <strong>horizonShadows</strong> <strong>section</strong></h5><p>horizonShadows部分存储了地形块的地平线阴影。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;shadows&gt; ::= &lt;header&gt;&lt;data&gt;</span><br><span class="line">&lt;header&gt; ::= &lt;magic&gt;&lt;width&gt;&lt;height&gt;&lt;bpp&gt;&lt;version&gt;&lt;padding</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>&lt;magic&gt;</strong></p>
<p>uint32 0x00646873 (string “shd&#x2F;0”)</p>
</li>
<li><p><strong>&lt;width&gt;</strong></p>
<p>包含数据宽度的Uint32</p>
</li>
<li><p><strong>&lt;height&gt;</strong></p>
<p>包含数据高度的Uint32</p>
</li>
<li><p><strong>&lt;bpp&gt;</strong></p>
<p>(未使用)数据中每个条目的位数</p>
</li>
<li><p><strong>&lt;version&gt;</strong></p>
<p>包含数据版本的Uint32，当前为1</p>
</li>
<li><p><strong>&lt;padding&gt;</strong></p>
<p>12个字节的填充使头部16字节对齐</p>
</li>
<li><p><strong>&lt;data&gt;</strong></p>
<p>阴影数据，(uint16,uint16) 宽度,高度，水平阴影数据存储两个角度,它们之间没有任何地形或物体遮挡。</p>
</li>
</ul>
<h5 id="4-1-8-6-lodTexture-dds-section"><a href="#4-1-8-6-lodTexture-dds-section" class="headerlink" title="4.1.8.6. lodTexture.dds section"></a><strong>4.1.8.6.</strong> <strong>lodTexture.dds</strong> <strong>section</strong></h5><p>lodTexture.dds部分存储地形块的LOD纹理。LOD纹理是所有纹理层混合在一起的低分辨率快照。纹理以DXT5格式存储。关于dds纹理格式的更多信息请参考DirectX文档。</p>
<h5 id="4-1-8-7-dominantTextures-section"><a href="#4-1-8-7-dominantTextures-section" class="headerlink" title="4.1.8.7. dominantTextures section"></a><strong>4.1.8.7.</strong> <strong>dominantTextures</strong> <strong>section</strong></h5><p>dominantTextures部分存储了主要的纹理图。 dominant texture地图存储地形块中每个x&#x2F;z位置的最高混合纹理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;dominant&gt; ::=&lt;header&gt;&lt;texNames&gt;&lt;data&gt;</span><br><span class="line">&lt;header&gt; ::= &lt;magic&gt;&lt;version&gt;&lt;numTextures&gt;&lt;texNameSize&gt;&lt;width&gt;&lt;height&gt;&lt;padding&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>&lt;magic&gt;</strong></p>
<p>uint32 0x0074616d (string “mat&#x2F;0”)</p>
</li>
<li><p><strong>&lt;version&gt;</strong></p>
<p>包含数据版本的Uint32，当前为1</p>
</li>
<li><p><strong>&lt;numTextures&gt;</strong></p>
<p>包含主导纹理映射引用的纹理数量的Uint32</p>
</li>
<li><p><strong>&lt;texNameSize&gt;</strong></p>
<p>包含纹理条目大小的Uint32</p>
</li>
<li><p><strong>&lt;width&gt;</strong></p>
<p>包含数据宽度的Uint32</p>
</li>
<li><p><strong>&lt;height&gt;</strong></p>
<p>包含数据高度的Uint32</p>
</li>
<li><p><strong>&lt;padding&gt;</strong></p>
<p>8个字节的填充使头部16字节对齐</p>
</li>
<li><p><strong>&lt;texNames&gt;</strong></p>
<p>texNameSize大小的numTextures条目包含在这个地图中引用的主要纹理的名称。比texNameSize短的纹理名称用0填充</p>
</li>
<li><p><strong>&lt;data&gt;</strong></p>
<p>存储为一个压缩的bin节。宽度*高度的字节数组，每个条目都是纹理名称的索引，该索引索引了条目x&#x2F;z位置的主要纹理</p>
</li>
</ul>
<h5 id="4-1-9-terrain-section-in-space-settings"><a href="#4-1-9-terrain-section-in-space-settings" class="headerlink" title="4.1.9. terrain section in space.settings"></a><strong>4.1.9.</strong> <strong>terrain</strong> <strong>section in</strong> <strong>space.settings</strong></h5><p>空间中的 space.settings 文件包含地形的配置选项。lodInfo和server部分中的值可以修改，但是根级别的值只能由World Editor修改。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span> 200 (int) <span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heightMapSize</span>&gt;</span> uint <span class="tag">&lt;/<span class="name">heightMapSize</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">normalMapSize</span>&gt;</span> uint <span class="tag">&lt;/<span class="name">normalMapSize</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">holeMapSize</span>&gt;</span> uint <span class="tag">&lt;/<span class="name">holeMapSize</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">shadowMapSize</span>&gt;</span> uint <span class="tag">&lt;/<span class="name">shadowMapSize</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blendMapSize</span>&gt;</span> uint <span class="tag">&lt;/<span class="name">blendMapSize</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">lodInfo</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">startBias</span>&gt;</span> float <span class="tag">&lt;/<span class="name">startBias</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">endBias</span>&gt;</span> float <span class="tag">&lt;/<span class="name">endBias</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lodTextureStart</span>&gt;</span> float <span class="tag">&lt;/<span class="name">lodTextureStart</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lodTextureDistance</span>&gt;</span> float <span class="tag">&lt;/<span class="name">lodTextureDistance</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">blendPreloadDistance</span>&gt;</span> float <span class="tag">&lt;/<span class="name">blendPreloadDistance</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lodNormalStart</span>&gt;</span> float <span class="tag">&lt;/<span class="name">lodNormalStart</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lodNormalDistance</span>&gt;</span> float <span class="tag">&lt;/<span class="name">lodNormalDistance</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">normalPreloadDistance</span>&gt;</span> float <span class="tag">&lt;/<span class="name">normalPreloadDistance</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">defaultHeightMapLod</span>&gt;</span> uint <span class="tag">&lt;/<span class="name">defaultHeightMapLod</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">detailHeightMapDistance</span>&gt;</span> float <span class="tag">&lt;/<span class="name">detailHeightMapDistance</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lodDistances</span>&gt;</span></span><br><span class="line">        +&lt;distance?&gt; float &lt;/distance?&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">lodDistances</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">heightMapLod</span>&gt;</span> uint <span class="tag">&lt;/<span class="name">heightMapLod</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">lodInfo</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>&lt;version&gt;</strong></p>
<p>地形的版本，对于高级地形，这个值是200</p>
</li>
<li><p><strong>&lt;heightMapSize&gt;</strong></p>
<p>每个地形块的高度图的大小，这个值是4到256之间2的幂</p>
</li>
<li><p><strong>&lt;normalMapSize&gt;</strong></p>
<p>每个地形块的法线贴图的大小，这个值是32到256之间2的幂</p>
</li>
<li><p><strong>&lt;holeMapSize&gt;</strong></p>
<p>每个地形块的洞图的大小，可以是256以内的任何值</p>
</li>
<li><p><strong>&lt;shadowMapSize&gt;</strong></p>
<p>每个地形块的阴影贴图的大小，这个值是32到256之间2的幂</p>
</li>
<li><p><strong>&lt;blendMapSize&gt;</strong></p>
<p>每个地形块的混合贴图的大小，该值是32到256之间2的幂</p>
</li>
<li><p><strong>&lt;lodInfo&gt;</strong></p>
<p>本节包含地形LOD系统的配置</p>
</li>
<li><p><strong>&lt;startBias&gt;</strong></p>
<p>这个值是geo-morphing开始的偏差值，这个值定义一个LOD级别从哪里开始淡出到下一个级别。这个值是两个lodDistance之间差异的一个因素。</p>
</li>
<li><p><strong>&lt;endBias&gt;</strong></p>
<p>这个值是geo-morphing结束时的偏差值，这个值定义一个LOD级别在哪里完全淡出到下一个级别。这个值是两个lodDistance之间差异的一个因素。</p>
</li>
<li><p><strong>&lt;lodTextureStart&gt;</strong></p>
<p>这是混合LOD纹理的起始距离，在此距离之前，混合层用于渲染地形。</p>
</li>
<li><p><strong>&lt;lodTextureDistance&gt;</strong></p>
</li>
</ul>
<p>  这是lodtexture混合的距离，这个值是相对于lodTextureStart。</p>
<ul>
<li><p><strong>&lt;blendPreloadDistance&gt;</strong></p>
<p>这是预加载混合的距离，这个值相对于lodTextureDistance和lodTextureStart</p>
</li>
<li><p><strong>&lt;lodNormalStart&gt;</strong></p>
<p>这是混合LOD法线的起始距离</p>
</li>
<li><p><strong>&lt;lodNormalDistance&gt;</strong></p>
<p>这是完整法线贴图混合的距离，这个值相对于lodNormalStart。</p>
</li>
<li><p><strong>&lt;normalPreloadDistance&gt;</strong></p>
<p>这是预加载完整法线贴图的距离。该值是相对于lodNormalStart和lodNormalDistance的</p>
</li>
<li><p><strong>&lt;defaultHeightMapLod&gt;</strong></p>
<p>这是要加载的高度贴图的默认LOD级别，0 &#x3D;完整的高度贴图，1 &#x3D;半分辨率，2 &#x3D;四分之一分辨率等等。</p>
</li>
<li><p><strong>&lt;detailHeightMapDistance&gt;</strong></p>
<p>这是加载全高度地图的距离</p>
</li>
<li><p><strong>&lt;lodDistances&gt;</strong></p>
<p>本部分包含几何LOD距离。</p>
</li>
<li><p><strong>&lt;distance&gt;</strong></p>
<p>距离部分定义了每个几何LOD级别调和出来的距离。distance0表示第一个LOD等级，distance1表示第二个LOD等级，以此类推。LOD级别之间的距离必须至少是地形块对角线距离的一半(~71)，这是因为我们只支持相邻块之间1 LOD级别的差异。</p>
</li>
<li><p><strong>&lt;server&gt;</strong></p>
<p>这部分包含服务器所使用的信息</p>
</li>
<li><p><strong>&lt;heightMapLod&gt;</strong></p>
<p>这定义了在服务器上加载哪个LOD级别，这个值用于加速服务器上的加载。</p>
</li>
</ul>
<h3 id="4-2-Simple-Terrain"><a href="#4-2-Simple-Terrain" class="headerlink" title="4.2. Simple Terrain"></a><strong>4.2. Simple Terrain</strong></h3><h4 id="4-2-1-Key-features"><a href="#4-2-1-Key-features" class="headerlink" title="4.2.1. Key features"></a><strong>4.2.1. Key features</strong></h4><ul>
<li>与 chunking system一起工作。</li>
<li>单个网格可从磁盘和内存寻址。</li>
<li>基于4x4米的网格(tiles)，匹配门户(portal)的尺寸。</li>
<li>低内存占用。</li>
<li>低磁盘占用。</li>
<li>快速绘制。</li>
<li>自动混合。</li>
<li>简单的工具集成。</li>
<li>分层地形与平铺纹理为了简单的条带创建。</li>
<li>使用纹理投影来应用纹理坐标以节省顶点内存。</li>
</ul>
<h4 id="4-2-2-Overview"><a href="#4-2-2-Overview" class="headerlink" title="4.2.2. Overview"></a><strong>4.2.2. Overview</strong></h4><p>地形是一个巨大的高度地图，由规则的高度杆网格定义，每4 × 4米。地形被组织成100x100米的地形块。每个这些块可以有多达4个纹理，它们是在每个顶点(即每个极点)的基础上混合的。地形也是自遮蔽的，允许在上面挖洞，比如洞穴开口。地形还包含详细信息，以便详细对象可以匹配地形类型。</p>
<h4 id="4-2-3-Chunking"><a href="#4-2-3-Chunking" class="headerlink" title="4.2.3. Chunking"></a><strong>4.2.3. Chunking</strong></h4><p>地形与块体恰当地结合在一起:每个地形块是100x100米，这是外部块体的大小。地形块存储在单独的文件中，这样就可以根据需要打开它们。</p>
<h4 id="4-2-4-Disk-footprint"><a href="#4-2-4-Disk-footprint" class="headerlink" title="4.2.4. Disk footprint"></a><strong>4.2.4. Disk footprint</strong></h4><p>每个地形块包含一个块，每个块的尺寸为100x100米。它包含28x28的高度、混合、阴影和细节值(有两个额外的行和一个列允许边界插值)。每个地形块也存储25x25洞的值，每个4x4m瓷砖一个洞。</p>
<p>下表显示了每个区块的地形成本：</p>
<table>
<thead>
<tr>
<th><strong>Component</strong></th>
<th><strong>Size calculation</strong></th>
<th><strong>Size</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Headers</td>
<td>256 (header) + 128 x 4 (texture names)</td>
<td>768</td>
</tr>
<tr>
<td>Height</td>
<td>28 x 28 x sizeof( float )</td>
<td>3136</td>
</tr>
<tr>
<td>Blend</td>
<td>28 x 28 x sizeof( dword )</td>
<td>3136</td>
</tr>
<tr>
<td>Shadow</td>
<td>28 x 28 x sizeof( word )</td>
<td>1568</td>
</tr>
<tr>
<td>Detail</td>
<td>28 x 28 x sizeof( byte )</td>
<td>784</td>
</tr>
<tr>
<td>Hole</td>
<td>25 x 25 x sizeof( bool )</td>
<td>625</td>
</tr>
<tr>
<td>Total</td>
<td></td>
<td>10017</td>
</tr>
</tbody></table>
<p><em>每个区块的地形成本</em></p>
<p>例如，对于一个15 × 15千米的世界，地形的总磁盘大小为:10017 × 150 × 150(Bytes)  约215MB。</p>
<h4 id="4-2-5-Memory-footprint"><a href="#4-2-5-Memory-footprint" class="headerlink" title="4.2.5. Memory footprint"></a><strong>4.2.5. Memory footprint</strong></h4><p>在视野为500m的情况下，每个地形块覆盖100x100米，一个典型的场景在任何时候都需要内存中大约160个地形块。</p>
<p>这么多地形的内存使用大约是2MB，加上数据管理开销。</p>
<h4 id="4-2-6-Texture-spacing"><a href="#4-2-6-Texture-spacing" class="headerlink" title="4.2.6. Texture spacing"></a><strong>4.2.6. Texture spacing</strong></h4><p>terraintexturespace标签包含在文件&lt;res&gt;&#x2F;resources.xml的环境部分(具体查看1.4.1 resources.xml副本中条目的优先级)决定了纹理地图在应用于地形时将被拉伸&#x2F;收缩的大小(以米为单位)。</p>
<p>这个值决定了纹理贴图的长度和高度。</p>
<h3 id="4-3-Terrain-specular-lighting"><a href="#4-3-Terrain-specular-lighting" class="headerlink" title="4.3. Terrain specular lighting"></a><strong>4.3. Terrain specular lighting</strong></h3><p>镜面照明方程为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SpeClr = TerSpeAmt * ( (SpeDfsAmt * TerDfsClr) + SunClr) * SpeRfl</span><br></pre></td></tr></table></figure>

<p>下面的列表描述了每个变量:</p>
<ul>
<li><p><strong>SpeClr</strong> <strong>(高光颜色)</strong></p>
<p>最终的颜色反射。</p>
</li>
<li><p><strong>TerSpeAmt</strong> <strong>(镜面)</strong></p>
<p>数值由4个地形纹理的alpha通道的加权混合给出。</p>
</li>
<li><p><strong>SpeDfsAmt</strong> <strong>(镜面散射量)</strong></p>
<p>初始值存储在效果文件bigworld&#x2F;res&#x2F;shaders&#x2F;terrain&#x2F;terrain.fx中的变量specularDiffuseAmount中。</p>
<p>它的值可以在运行时通过render&#x2F;terrain&#x2F;specularDiffuseAmount进行调整。</p>
<p>一旦获得了所需的结果，就可以将新值存储在效果文件中。</p>
</li>
<li><p><strong>TerDfsClr</strong> <strong>(地形的漫反射r)</strong></p>
<p>数值由4个地形纹理的RGB通道的加权混合给出。</p>
</li>
<li><p><strong>SunClr</strong> <strong>(阳光颜色)</strong></p>
<p>阳光照射下的颜色。</p>
</li>
<li><p><strong>SpeFlr (镜面反射)</strong></p>
<p>镜面反射值在给定像素，由镜面功率系数调整。</p>
</li>
</ul>
<p>作为公式的结果，少量的地形漫反射颜色(TerDfsClr)被添加到阳光颜色(SunClr)，以提供高光颜色(SpeClr)。</p>
<p>高光照明功率的初始值存储在效果文件bigworld&#x2F;res&#x2F;shaders&#x2F;terrain&#x2F;terrain.fx中的变量specularPower中。它的值可以在运行时通过render&#x2F;terrain&#x2F;specularPower进行调整。一旦获得了所需的结果，就可以将新值存储在效果文件中。</p>
<p>请注意，镜面功率只能在着色器硬件版本2.0及以后进行调整。着色器硬件的早期版本被限制在4的高光功率值(这是着色器硬件版本2.0和更高版本的默认值)。</p>
<p><em><strong>最终应用于地形的高光照明的数量受文件bigworld&#x2F;res&#x2F;shaders&#x2F;terrain&#x2F;terrain.fx中的可变specMultiplier的影响。设置为1以外的任何东西来重新缩放高光照明，或0来完全禁用它。</strong></em></p>
<p><em><strong>地形高光照明可以通过TERRAIN_SPECULAR图形设置来关闭。</strong></em></p>
<h2 id="5-Cloud-shadows"><a href="#5-Cloud-shadows" class="headerlink" title="5. Cloud shadows"></a><strong>5. Cloud shadows</strong></h2><p>在BigWorld客户端引擎中绘制的所有对象都受到云阴影的影响。这个效果是按每个像素应用的，并使用作为投影在世界上的引擎中的纹理源来执行。</p>
<p>这个光照贴图通过在文件bigworld&#x2F;res&#x2F;shaders&#x2F; std_effects&#x2F;stdinclude.fxh中定义的宏公开给效果系统。</p>
<p>默认情况下，纹理源被命名为skyLightMap，因此可以通过以下命令被Python访问：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BigWorld.getTextureFeed( <span class="string">&quot;skyLightMap&quot;</span> )</span><br></pre></td></tr></table></figure>

<h3 id="5-1-Requirements"><a href="#5-1-Requirements" class="headerlink" title="5.1. Requirements"></a><strong>5.1. Requirements</strong></h3><p>云阴影需要每个材质有一个额外的纹理层。虽然固定函数管道对大多数材质支持这一点，但在凹凸映射和镜面对象上的云阴影需要四组以上的纹理坐标，这意味着对于凹凸映射对象，它将只在像素着色器2和更高版本上工作。</p>
<h3 id="5-2-Implementation"><a href="#5-2-Implementation" class="headerlink" title="5.2. Implementation"></a><strong>5.2. Implementation</strong></h3><p>天空灯光图由C++文件src&#x2F;lib&#x2F;romp&#x2F;sky_light_map.cpp中的代码计算，并在绘制过程中由天空模块更新。</p>
<p>它通过自动效果常数暴露于效果引擎中。只有当创建新云或当前云集下风向移动超过25%时，光照图才会更新。</p>
<p>在更新之间，投影纹理坐标会随着风速滑动，这样云的阴影看起来就会随着云移动。所有的效果文件都包含了云的阴影效果，包括地形和植物。</p>
<h3 id="5-3-Effect-File-Implementation"><a href="#5-3-Effect-File-Implementation" class="headerlink" title="5.3. Effect File Implementation"></a><strong>5.3. Effect File Implementation</strong></h3><p>有两个效果常量公开在效果文件中，以帮助天空光映射:</p>
<ul>
<li><strong>SkyLightMapTransform</strong></li>
</ul>
<p>  设置“World to SkyLightMap”纹理投影。使用这个常量将x,z世界顶点位置转换为u,v纹理坐标。</p>
<ul>
<li><p><strong>SkyLightMap</strong></p>
<p>显示天空光贴图纹理以创建效果文件。</p>
</li>
</ul>
<p>文件bigworld&#x2F;res&#x2F;shaders&#x2F;std_effects&#x2F;stdinclude.fxh中有几个宏可以帮助将云阴影集成到效果文件中。</p>
<p>在下面的列表中描述了这些宏：</p>
<ul>
<li><strong>BW_SKY_LIGHT_MAP_OBJECT_SPACE , BW_SKY_LIGHT_MAP_WORLD_SPACE</strong></li>
</ul>
<p>  这些宏声明了纹理投影所需的变量和常量，包括：</p>
<ul>
<li>世界空间摄影机位置</li>
<li>天空光贴图变换。</li>
<li>天空之光映射本身。</li>
</ul>
<p>  当使用在对象空间中执行照明的效果文件时(例如，如果您也在使用宏DIFFUSE_LIGHTING_OBJECT_SPACE)，请使用变体BW_SKY_LIGHT_MAP_OBJECT_SPACE，那么它将声明世界矩阵。</p>
<ul>
<li><p><strong>BW_SKY_LIGHT_MAP_SAMPLER</strong></p>
<p>此宏声明了在像素着色器中实现云阴影时使用的采样器对象。</p>
</li>
<li><p><strong>BW_SKY_MAP_COORDS_OBJECT_SPACE,BW_SKY_MAP_COORDS_WORLD_SPACE</strong></p>
<p>这些宏在给定的顶点位置上执行纹理投影，并将纹理坐标设置到给定的寄存器中。</p>
<p>请确保根据您所使用的宏集，在适当的参照系中传递这些位置。</p>
</li>
<li><p><strong>BW_TEXTURESTAGE_CLOUDMAP</strong></p>
<p>此宏定义了一个纹理阶段，它将前一个阶段的结果乘以适当的云阴影值。</p>
<p>它应在任何漫射照明计算之后使用，以及在任何反射或镜面照明之前使用。</p>
</li>
<li><p><strong>SAMPLE_SKY_MAP</strong></p>
</li>
</ul>
<p>  此宏对像素着色器中的天空光贴图进行采样，并返回一个一维浮点值，该值表示应该乘以漫反射照明值的量。</p>
<h3 id="5-4-Tweaking"><a href="#5-4-Tweaking" class="headerlink" title="5.4. Tweaking"></a><strong>5.4. Tweaking</strong></h3><p>在根据当前云计算光照图之后，它被固定到一个最大值。这意味着云地图永远不会太暗，也不会对世界产生太大的影响。</p>
<p>例如，即使太阳在白天完全被云遮住，仍然会有足够的环境照明和来自云层本身的照明，这样太阳光仍然会起作用。</p>
<p>BigWorld观察客户端  Settings&#x2F;Clouds&#x2F;max  灯光贴图黑暗设置天空灯光贴图的最大值。值为1意味着天空光贴图能够完全模糊太阳（完全阴影）。默认值0.65表示BigWorld艺术家对云阴影的最佳值的最佳猜测。值为0将意味着云影对世界没有任何影响。</p>
<p>此值也将从灯光映射设置中的文件sky.xml中读取。它由最大的黑暗标签表示。有关天空光地图设置文件的详细信息，请参见<strong>22.1.4.1.2. Sky light map</strong>。</p>
<h2 id="6-Chunks"><a href="#6-Chunks" class="headerlink" title="6. Chunks"></a><strong>6. Chunks</strong></h2><p>由BigWorld客户端绘制的场景图是由空间的小凸块构建的。这样做有很多好处，包括易于流媒体、减少加载时间、并发世界编辑以及简化服务器场景更新和物理检查。</p>
<p>下面几节将描述分块系统的概念和实现。</p>
<h4 id="6-1-Definitions"><a href="#6-1-Definitions" class="headerlink" title="6.1. Definitions"></a><strong>6.1. Definitions</strong></h4><p>以下术语与BigWorld的分块系统有关：</p>
<p>空间是一个连续的三维笛卡尔介质。每个空间被分段分割成块，这些块占据整个空间，但不重叠。空间中的每个点都恰好在一个块中。空间按水平尺寸分为100x100米的柱，总垂直范围。独立空间的例子包括行星、平行空间、空间站和“独立的”公寓&#x2F;地牢级别。</p>
<p>块是一种凸三维体。它包含了位于其中的场景对象的描述。场景对象包括模型、灯光、实体、地形块等，称为块项目。它还定义了构成其边界的一组平面。</p>
<p><em>列的外部块不受此限制，它只需要定义相邻列的四个平面。其他块的边界平面与网格方形重叠，用来构建内部空间划分的完整图像。</em></p>
<p>有些平面在它们上定义了protal，这表明通过它们可以看到相邻的块。</p>
<p>protal是一个多边形加上对通过该多边形可见的块的引用。它包含一个标志，用于指示是否允许对象通过它。有些protal的命名方式可能是脚本可以对它们进行地址定位，并更改它们的权限。</p>
<h4 id="6-2-Implementation-files"><a href="#6-2-Implementation-files" class="headerlink" title="6.2. Implementation files"></a><strong>6.2. Implementation files</strong></h4><p>分块系统使用以下文件：</p>
<ul>
<li><strong>对于宇宙中的每个空间的一个 space.setting 文件(XML格式)</strong></li>
</ul>
<p>  有关此文件语法的详细信息，请参见文档文件语法指南的<em>space.settings</em>。</p>
<ul>
<li><p><strong>&lt;res&gt;&#x2F;spaces&#x2F;&lt;space&gt;&#x2F;space.settings</strong><br>* 环境设置<br>* 网格正方形的边界矩形</p>
</li>
<li><p><strong>每个空间的多个.chunk文件(XML格式)</strong></p>
<p>有关此文件语法的详细信息，请参见文档文件语法指南的 <em>.chunk</em>。</p>
<ul>
<li><strong>&lt;res&gt;&#x2F;spaces&#x2F;&lt;space&gt;&#x2F;XXXXZZZZo.chunk</strong> <strong>(o &#x3D; outside)</strong></li>
<li><strong>&lt;res&gt;&#x2F;spaces&#x2F;&lt;space&gt;&#x2F;CCCCCCCCi.chunk</strong> <strong>(i &#x3D; inside)</strong><ul>
<li>场景对象列表</li>
<li>使用的纹理集</li>
<li>边界平面和入口（包括对可见数据块的引用）</li>
<li>碰撞场景</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>每个空间的多个.cdata文件（二进制格式）</strong></p>
<ul>
<li><p><strong>&lt;res&gt;&#x2F;spaces&#x2F;&lt;space&gt;&#x2F;XXXXZZZZ.cdata</strong></p>
<ul>
<li><p>地形数据，如：</p>
<ul>
<li>高度图数据</li>
<li>覆盖数据</li>
<li>使用的纹理</li>
</ul>
<p> – or–</p>
</li>
<li><p>块中每个对象的照明数据的多个实例</p>
<ul>
<li>静态照明数据</li>
<li>模型中每个顶点的颜色值</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="6-3-Details-and-notes"><a href="#6-3-Details-and-notes" class="headerlink" title="6.3. Details and notes"></a><strong>6.3. Details and notes</strong></h3><h4 id="6-3-1-Includes"><a href="#6-3-1-Includes" class="headerlink" title="6.3.1. Includes"></a><strong>6.3.1. Includes</strong></h4><p>Includes在加载后是透明的(对客户端、服务器和脚本)。标签冲突可以通过向标签添加’_n’来处理，其中n是已经具有该标签的对象的数量。</p>
<p>Includes在遇到的地方内联展开，不需要有客户端或服务器的边界框。</p>
<p>世界编辑器不生成Includes。</p>
<h4 id="6-3-2-Models"><a href="#6-3-2-Models" class="headerlink" title="6.3.2. Models"></a><strong>6.3.2. Models</strong></h4><p>材质覆盖和动画声明仍然是模型文件的域。</p>
<h4 id="6-3-3-Entities"><a href="#6-3-3-Entities" class="headerlink" title="6.3.3. Entities"></a><strong>6.3.3. Entities</strong></h4><p>只有已隐式实例化的实体才需要填写其ID字段。如果它为零或缺失，则从客户端池（如果是客户端实例化的实体）或创建单元格池（如果是服务器实例化的实体）为该实体分配唯一ID。</p>
<p>如果一个实体需要一个标签，则它必须在其正式类型定义中包含该标签作为一个属性。</p>
<h4 id="6-3-4-Boundaries-and-portals"><a href="#6-3-4-Boundaries-and-portals" class="headerlink" title="6.3.4. Boundaries and portals"></a><strong>6.3.4. Boundaries and portals</strong></h4><p>如果只有天空(渐变、云、太阳、月亮、星星等)要绘制在那里，就可以使用特殊块标识符heaven。如果要画地形的话，地球也一样。因此，外块有六面，上面是天块，下面是地块。</p>
<p>门户中没有块引用意味着它没有连接，并且不会在那里绘制任何东西。</p>
<p>如果一个块包含在另一个块中，那么它的边界平面将被忽略——只使用像它所包含的、模型、灯光和声音这样的东西。</p>
<p>内部门户意味着指定的边界不是实际的边界，而是它连接到的块（以及该块连接到的所有块）所占据的空间应该从逻辑上从该块拥有的空间中减去，由该块的非内部边界定义。这最初只用于“外部”块连接到“内部”块，但它可能很容易适用于“内部入口”，即“边界门户”的补充。</p>
<p>在门户定义中，二维多边形点的虚轴是由法线与u轴的交叉乘积找到的。</p>
<p>在边界定义中，法线应指向内。</p>
<h4 id="6-3-5-Transforms"><a href="#6-3-5-Transforms" class="headerlink" title="6.3.5. Transforms"></a><strong>6.3.5. Transforms</strong></h4><p>除边界框外，块中的所有内容都将在块的局部空间中进行解释（如在顶级变换部分中所指定的）。</p>
<h4 id="6-3-6-Other-items"><a href="#6-3-6-Other-items" class="headerlink" title="6.3.6. Other items"></a><strong>6.3.6. Other items</strong></h4><p>以下项目也可以以块存在：</p>
<ul>
<li><p>聚光灯</p>
</li>
<li><p>环境光</p>
</li>
<li><p>平行光</p>
</li>
<li><p>水(水体)</p>
</li>
<li><p>光晕(镜头光晕)</p>
</li>
<li><p>粒子系统</p>
</li>
</ul>
<h4 id="6-4-Loading-and-ejecting"><a href="#6-4-Loading-and-ejecting" class="headerlink" title="6.4. Loading and ejecting"></a><strong>6.4. Loading and ejecting</strong></h4><p>在每一帧中，块管理器都会对它已经加载的所有块执行一个简单的图形遍历，以寻找要加载的新块。它沿着块之间的入口，跟踪它在扫描中“移动”的距离。它的扫描被限制在最大的可见距离内，即比较远的平面距离稍远一点。</p>
<p>它在这个遍历中找到的最近的卸载块是下一个加载的块。加载是在一个单独的线程中完成的，因此它不会干扰游戏的运行。类似地，任何超出扫描范围的数据块都可以被驱逐（卸载）。</p>
<h3 id="6-5-Focus-grid"><a href="#6-5-Focus-grid" class="headerlink" title="6.5. Focus grid"></a><strong>6.5. Focus grid</strong></h3><p>焦点网格是围绕相机位置的一组柱子。每根柱子长100x100米，并与地形方格和外部块体对齐。焦点网格的大小刚好超过远平面。</p>
<p>例如，对于500米的远平面，焦点网格沿每个方向移动700米，使总共有14x14&#x3D;196列。</p>
<p>聚焦网格中的列集取决于相机的位置。随着相机的移动，焦点网格处理不再在网格下的列，并“聚焦”于那些刚刚足够接近的列。</p>
<p>每一列包含一个船体树（hull tree）和一个四轴树(quad tree)。</p>
<h4 id="6-5-1-Hull-tree"><a href="#6-5-1-Hull-tree" class="headerlink" title="6.5.1. Hull tree"></a><strong>6.5.1. Hull tree</strong></h4><p>船体树(hull tree)是针对凸船体(convex hunns)的一种二元空间(binary-space)划分树。它可以处理重叠的船体。它可以进行点测试和适当的线遍历。</p>
<p>船体树是由重叠于列的所有块的边界形成的。从这棵树中，可以快速地确定任何给定点所在的块。（例如，照相机的位置）</p>
<h4 id="6-5-2-Quad-tree"><a href="#6-5-2-Quad-tree" class="headerlink" title="6.5.2. Quad tree"></a><strong>6.5.2. Quad tree</strong></h4><p>四叉树(quad tree)由重叠列的所有障碍的边界框（或者，可能是任何其他边界凸包）组成。此树用于碰撞场景测试。大块项目负责添加和实施障碍。目前只有模型和地形块项目添加了任何障碍。</p>
<p>如果一个块或障碍在多个列中，则将其添加到两个列的树中。</p>
<h3 id="6-6-Collisions"><a href="#6-6-Collisions" class="headerlink" title="6.6. Collisions"></a><strong>6.6. Collisions</strong></h3><p>使用障碍四叉树(quad tree)的焦点网格(focus grid)，块空间类可以在其空间中扫描任何三维形状，并向回调对象报告所有的三角形碰撞。目前支持的3D形状是点和三角形，但任何其他形状都可以轻松添加。</p>
<p>最底层的碰撞检查由一个通用的障碍物界面处理，所以任何可能的障碍都可以添加到这个碰撞场景中，只要它可以快速确定另一个形状何时与它碰撞（在它自己的局部坐标中）。</p>
<p>有关更多详细信息，请参见文件bigworld&#x2F;src&#x2F;client&#x2F;physics.cpp。</p>
<h3 id="6-7-Sway-items"><a href="#6-7-Sway-items" class="headerlink" title="6.7. Sway items"></a><strong>6.7. Sway items</strong></h3><p>摇摆项(sway item)是指受其他块项目的通过而影响的块项目。每当一个动态块项移动时，该块中的任何摇摆项都会得到调用它们的摇摆方法，从而指定移动的来源和命运。</p>
<p>目前唯一的用户是ChunkWater。它利用流过它表面的运动在水中产生涟漪。这就是为什么涟漪适用于任何类型的动态道具——从动态障碍&#x2F;移动平台到玩家模型再到小子弹。</p>
<ul>
<li><p>在mf&#x2F;src&#x2F;lib&#x2F;chunk&#x2F;chunk_water.cpp中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ChunkWater::<span class="built_in">ChunkWater</span>() :</span><br><span class="line"><span class="built_in">ChunkItem</span>( <span class="number">5</span> ), </span><br><span class="line">    <span class="built_in">pWater_</span>( <span class="literal">NULL</span> )</span><br><span class="line">&#123;&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Apply a disturbance to this body of water</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChunkWater::sway</span><span class="params">( <span class="type">const</span> Vector3 &amp; src, <span class="type">const</span> Vector3 &amp; dst )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pWater_ != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pWater_-&gt;<span class="built_in">addMovement</span>( src, dst );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在mf&#x2F;src&#x2F;lib&#x2F;chunk&#x2F;chunk_item.hpp中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChunkItem</span> : <span class="keyword">public</span> SpecialChunkItem</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">ChunkItem</span>( <span class="type">int</span> wantFlags = <span class="number">0</span> ) : <span class="built_in">SpecialChunkItem</span>( wantFlags ) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">typedef</span> ClientChunkItem SpecialChunkItem;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClientChunkItem</span> : <span class="keyword">public</span> ChunkItemBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">ClientChunkItem</span>( <span class="type">int</span> wantFlags = <span class="number">0</span> ) : <span class="built_in">ChunkItemBase</span>( wantFlags ) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">ChunkItemBase</span>( <span class="type">int</span> wantFlags = <span class="number">0</span> );</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wantsDraw</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> !!(wantFlags_ &amp; <span class="number">1</span>); &#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wantsTick</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> !!(wantFlags_ &amp; <span class="number">2</span>); &#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wantsSway</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> !!(wantFlags_ &amp; <span class="number">4</span>); &#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wantsNest</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> !!(wantFlags_ &amp; <span class="number">8</span>); &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="7-Entities"><a href="#7-Entities" class="headerlink" title="7. Entities"></a><strong>7. Entities</strong></h2><p>实体是BigWorld关键的概念，它本身就涉及到一个大型系统。它们是客户端和服务器之间的链接，也是客户端和服务器之间的链接，也是BigWorld Technology最特别的功能。</p>
<p>本节仅处理客户端上的实体的管理方面。</p>
<p>根据实体类型，它可以存在于BigWorld的不同部分，如下所示：</p>
<ul>
<li><p><strong>Client-only</strong></p>
<p>例如，一个安全摄像头道具，或一个信息图标。通过将“世界编辑器的属性”面板“仅客户端”属性设置为true来创建仅客户端实体。</p>
</li>
<li><p><strong>Client and server</strong></p>
<p>实体将在两个部分中处于同一位置。例如：player Avatar, NPCs，自动售货机。</p>
</li>
<li><p><strong>Server-only</strong></p>
<p>该实体将只在服务器上进行实例化。例如，一个NPC衍生点或远程传送目的地点。仅限服务器的实体在客户端上没有任何脚本。</p>
</li>
</ul>
<h3 id="7-1-Entity-Manager"><a href="#7-1-Entity-Manager" class="headerlink" title="7.1. Entity Manager"></a><strong>7.1. Entity Manager</strong></h3><p>实体管理器存储两个实体列表：</p>
<ul>
<li><p>Active List</p>
<p>包含当前世界中的实体，由服务器中转或由块文件指示。</p>
</li>
<li><p>Cached List</p>
<p>包含最近在世界上，但现在只是在客户的500米半径区域(AoI)之外的实体。</p>
</li>
</ul>
<p>实体被缓存，以便如果它们在离开后不久返回客户端的AoI，服务器不必重新发送与该实体相关的所有数据；只需要更改的字段。</p>
<p>由于可能从服务器无序地收到消息，因此实体管理器对其订单不敏感。例如，如果一个实体进入了玩家的AOI，然后迅速离开它，BigWorld客户端的行为也会正确，即使它在其“输入AOI”消息之前收到了该实体的“离开AoI”消息。</p>
<p>实体管理器总是可以确定它应该从包的序列号接收到消息的相对时间，因为包是定期发送的。</p>
<h3 id="7-2-Entity-scripts"><a href="#7-2-Entity-scripts" class="headerlink" title="7.2. Entity scripts"></a><strong>7.2. Entity scripts</strong></h3><p>客户端上的实体脚本是来自BigWorld的Python类。实体类。这个基类公开了许多方法和属性，允许脚本控制实体的行为(例如，位置、方向和实体模型都通过BigWorld.Entity接口）。</p>
<p>除了公开方法和属性之外，当某些事件通过命名的事件处理程序发生时，客户端引擎还将通知实体脚本。</p>
<h3 id="7-3-Entity-resources"><a href="#7-3-Entity-resources" class="headerlink" title="7.3. Entity resources"></a><strong>7.3. Entity resources</strong></h3><p>通常，每个实体类型都需要一些资源来操作，例如模型、纹理、着色器、声音或粒子系统。BigWorld客户端提供了几种方法来确保这些资源在实体进入世界时可用，从而避免使主线程停止。</p>
<h4 id="7-3-1-Preloads"><a href="#7-3-1-Preloads" class="headerlink" title="7.3.1. Preloads"></a><strong>7.3.1. Preloads</strong></h4><p>当客户端启动时，它将为每个实体Python模块查询一个名为perload的函数。此函数返回的资源名称将在客户端启动时加载，并在客户端的整个生命周期中保存在内存中（即它可以随时使用）。这对于常用的资产很有用，以避免以后可能出现的加载和重新加载。然而，这样做的代价是，客户端将需要更长的时间来启动，并使用更多的内存（如果资源在某个时候实际上没有被使用）。</p>
<p>若要使用预加载机制，请在相关的实体模块中创建一个名为preload的全局函数。它必须使用一个参数，该参数是一个包含要预加载的资源的Python列表。就地修改此列表（例如，使用list.append或列表连接），插入由客户端要预加载的每个资源的字符串名称。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Door.py</span></span><br><span class="line"><span class="keyword">import</span> BigWorld</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Door</span>( BigWorld.Entity ):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"> self </span>):</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">preload</span>(<span class="params"> <span class="built_in">list</span> </span>):</span><br><span class="line">            <span class="built_in">list</span>.append( <span class="string">&quot;doors/models/generic_door.model&quot;</span> )</span><br><span class="line">            <span class="built_in">list</span>.append( <span class="string">&quot;doors/maps/door_highlight.tga&quot;</span> )</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure>

<p>可以预加载的资源的类型是：</p>
<ul>
<li>Fonts</li>
<li>Textures</li>
<li>Shaders</li>
<li>Models</li>
</ul>
<h4 id="7-3-2-Prerequisites"><a href="#7-3-2-Prerequisites" class="headerlink" title="7.3.2. Prerequisites"></a><strong>7.3.2. Prerequisites</strong></h4><p>当一个实体即将出现在客户端上的世界中时，引擎将对名为prerequisites的实体脚本执行一个回调。这允许实体脚本返回在实体进入世界之前必须加载的资源列表。这些资源由加载线程加载，以便不会中断渲染管道。</p>
<p>建议一个实体将其所需的资源作为先决条件进行公开，并在onEnterWorld的方法中加载它们。与使用预加载不同，先决条件不会泄漏引用，因此当实体离开该世界时，它将释放其资源。</p>
<p>实体管理器在允许实体进入世界之前调用Entity::checkPrerequisites 。此方法检查是否满足此实体进入世界的先决条件。如果他们满足，那么它就会开始满足他们的过程（如果还没有开始）。</p>
<p>请注意，当在实体上调用先决条件方法时，其脚本已经被初始化，并且已经设置了其属性。因此，该实体可以根据该实体的具体实例来专门化其先决条件列表。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Door</span>(<span class="params"> BigWorld.Entity </span>):</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">prerequisites</span>(<span class="params"> self </span>):</span><br><span class="line">        <span class="keyword">return</span> [ DoorResources[ self.modelType ].modelName ]</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>



<h2 id="8-User-Data-Objects"><a href="#8-User-Data-Objects" class="headerlink" title="8. User Data Objects"></a><strong>8. User Data Objects</strong></h2><p>用户数据对象(User Data Objects)是将用户定义的数据嵌入到块文件中的一种方法。每个用户数据对象类型都被实现为Python脚本的集合，以及一个基于xml的定义文件，它将这些脚本绑定在一起。这些脚本位于文件夹脚本下的资源树中。</p>
<p>用户数据对象与实体的不同之处在于它们是不可变的（即它们的属性不会改变），并且它们不会传播到其他单元格或客户端。这使得它们比实体要轻得多。</p>
<p>用户数据对象的一个关键特性是它们的可链接性。实体能够链接到用户数据对象，而用户数据对象能够链接到其他用户数据对象。这是通过在希望链接到另一个用户数据对象的用户数据对象或实体的定义文件中包含一个UDO_REF属性来实现的。</p>
<h3 id="8-1-User-Data-Objects-are-Python-script-objects"><a href="#8-1-User-Data-Objects-are-Python-script-objects" class="headerlink" title="8.1. User Data Objects are Python script objects"></a><strong>8.1. User Data Objects are Python script objects</strong></h3><p>每个用户数据对象都是一个Python脚本对象(PyObject)。根据用户数据对象的类型，它可以存在于BigWorld的不同部分，如下所示：</p>
<ul>
<li><p><strong>Client only</strong></p>
<p>仅限客户端的用户数据对象是通过使用其定义文件中的域标记中的客户端域来创建的。仅限客户端的用户数据对象不应该有cell或base脚本。</p>
<p>对于一个仅客户端用户数据对象的例子，请参考CameraNode用户数据对象，实现在&lt;res&gt;&#x2F;scripts&#x2F;client&#x2F;CameraNode.py和&lt;res&gt;&#x2F;scripts&#x2F;user_data_object_defs&#x2F;CameraNode.def文件中。</p>
</li>
<li><p><strong>Server only</strong> </p>
<p>仅在服务器上的用户数据对象仅在服务器上实例化，如果其域标记为CELL，则将在cell中实例化，如果域标记设置为BASE，则将在base实例化。</p>
<p>服务器用户数据对象的例子，请参考PatrolNode用户数据对象，实现在&lt;res&gt;&#x2F;scripts&#x2F;cell&#x2F;PatrolNode.py和&lt;res&gt;&#x2F;scripts&#x2F;user_data_object_defs&#x2F;PatrolNode.def文件中。</p>
</li>
</ul>
<h3 id="8-1-Accessing-from-the-Client"><a href="#8-1-Accessing-from-the-Client" class="headerlink" title="8.1. Accessing from the Client"></a><strong>8.1. Accessing from the Client</strong></h3><p>客户端可以使用以下命令访问所有仅限客户端使用的用户数据对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; BigWorld.userDataObjects </span><br><span class="line">&lt;WeakValueDictionary at 3075900908&gt;</span><br></pre></td></tr></table></figure>

<p>返回一个Python字典，使用用户数据对象的唯一标识符作为键，并将其PyObject表示作为其值。用户数据对象的属性和脚本方法可以使用标准的点语法来访问：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; patrolNode.patrolLinks</span><br><span class="line">[UserDataObject at 2358353012, UserDataObject at 2358383771]</span><br></pre></td></tr></table></figure>



<h2 id="9-Scripting"><a href="#9-Scripting" class="headerlink" title="9. Scripting"></a><strong>9. Scripting</strong></h2><p>提供给脚本的工具极其重要，因为它们决定了客户端的通用性和可扩展性。对于脚本程序员来说，这个环境是客户端；就像对普通用户一样，窗口系统就是计算机。</p>
<p>脚本环境提供了尝试编写整个程序的很大的诱惑。这可能会很快导致程序缓慢而难以理解(特别是如果相同的编程规则不像C++一样应用于脚本语言时)。因此，我们建议只有在不需要在每帧调用时才能用脚本编写功能。此外，如果它是全局的，那么它应该在人格脚本中实现。因此，例如，一个全局聊天控制台将在人格脚本中实现，而一个目标系统，它需要检查每一帧的碰撞场景，最好在C++中实现。</p>
<p>重要的是，整个BigWorld技术的广泛集成允许游戏代码的快速开发和巨大的灵活性。</p>
<p><em>在BigWorld的Python集成中，垃圾收集被禁用了，因为垃圾收集是一种昂贵的操作，可以在任何时候发生，例如阻塞主线程并导致帧率峰值。</em></p>
<h3 id="9-1-Functional-components"><a href="#9-1-Functional-components" class="headerlink" title="9.1. Functional components"></a><strong>9.1. Functional components</strong></h3><p>本节从使用这些工具的脚本的角度，描述了（一般）C++实体的内容和服务。以下章节中描述的实体的功能组件如下：</p>
<ul>
<li><p>Entity Skeleton（实体框架）</p>
</li>
<li><p>Python Script Object（python脚本对象）</p>
</li>
<li><p>Model Management（模型管理）</p>
</li>
<li><p>Filters（过滤器）</p>
</li>
<li><p>Action Queue（操作队列）</p>
</li>
<li><p>Action Matcher（行动匹配器）</p>
</li>
<li><p>Trackers (IK)（跟踪器-反向）</p>
</li>
<li><p>Timers and Traps（计时器和陷阱）</p>
</li>
</ul>
<h4 id="9-1-1-Entity-Skeleton（实体框架）"><a href="#9-1-1-Entity-Skeleton（实体框架）" class="headerlink" title="9.1.1 Entity Skeleton（实体框架）"></a><strong>9.1.1 Entity Skeleton（实体框架）</strong></h4><p>实体类(entity.cpp)是C++容器，它将为特定实体使用的任何组件集合在一起。它从Python对象派生出来，并拦截某些访问，并将其不理解的访问传递给用户脚本。这允许脚本使用“自我”引用，透明地在它们自己（和其他实体）上调用C++函数。在服务器的单元格和基本组件中也使用了相同的集成技术。</p>
<p>这个类处理组件类所需的任何内务管理或粘合——就其他c++模块而言，它是实体的公共面。</p>
<p>该类的数据成员包括id、类型和位置。</p>
<h4 id="9-1-2-Python-script-object"><a href="#9-1-2-Python-script-object" class="headerlink" title="9.1.2. Python script object"></a><strong>9.1.2. Python script object</strong></h4><p>这是用户提供的脚本类的实例。该实体的类型将选择该类。它存储在实体类型的XML描述中定义的特定于类型的数据，以及脚本希望存储的任何其他内部使用的数据。</p>
<p>当从服务器发送字段数据时，此类将自动更新其字段（并通知其更改）。当从服务器（或客户端上的其他脚本）接收到消息时，将自动调用消息处理程序。实体类执行这种自动化——从脚本的角度来看，它似乎是自动的。</p>
<h4 id="9-1-3-Model-management"><a href="#9-1-3-Model-management" class="headerlink" title="9.1.3. Model management"></a><strong>9.1.3. Model management</strong></h4><p>模型是BigWorld对网格的术语，再加上它上面使用的动画和动作。</p>
<p>模型管理组件允许实体管理在其位置绘制和动画的模型。模型可以在定义良好的连接点（硬点）上相互连接，或者它们可以独立存在。模型在加载时不会自动添加到场景中——它必须显式地放在场景中。</p>
<p>实体可以使用任意数量的独立（断开的）模型，但大多数将使用0或1。那些使用更多的，需要特殊的过滤器来合理地表现。</p>
<p>理解模型的最佳方法是熟悉它们的Python接口，<strong>Main</strong> → <strong>Client</strong> → <strong>BigWorld</strong> → <strong>Classes</strong> → <strong>PyModel</strong></p>
<h4 id="9-1-4-Filters"><a href="#9-1-4-Filters" class="headerlink" title="9.1.4. Filters"></a><strong>9.1.4. Filters</strong></h4><p>过滤器采用带有时间戳的位置更新，并对它们进行插值，以在任意时间生成实体的位置。</p>
<p>BigWorld只提供过滤器基类。游戏开发者将从中获得特定于游戏的过滤器。然后，每个实体可以从可用的变量中为自己选择一种过滤器。如果它需要，它可以动态地更改其过滤器。</p>
<p>每当一个移动更新来自服务器时，它就会被移交给选定的过滤器，以及为该事件计算的（现有的）游戏时间重建逻辑的时间。</p>
<p>过滤器还可以提供时间间隔和转换，例如，“在游戏时间x，向前移动y米，旋转z弧度，持续t秒”。这个过滤器(如果它足够聪明的话)可以将此整合到它的插值中。</p>
<p>过滤器还可以在流中的给定时间执行脚本回调。</p>
<p>过滤器完全可以从Python中访问。</p>
<h4 id="9-1-5-Navigation"><a href="#9-1-5-Navigation" class="headerlink" title="9.1.5. Navigation"></a><strong>9.1.5. Navigation</strong></h4><p>BigWorld通过客户端脚本提供了对一些导航方法的访问。BigWorld.navigatePathPoints()将返回给定源点和目标点之间路径的点列表，BigWorld.findRandomNeighbourPoint()和相关BigWorld.findRandomNeighbourPointWithRange()将返回连接的导航网格中返回一个随机点，该点将从给定点导航。</p>
<p>为客户端提供这些方法是为了允许使一些处理远离服务器，并允许移动更有响应性，从而消除了等待服务器提供路径的需要。</p>
<h5 id="9-1-5-1-Configuring-a-Space-to-Use-Navigation"><a href="#9-1-5-1-Configuring-a-Space-to-Use-Navigation" class="headerlink" title="9.1.5.1. Configuring a Space to Use Navigation"></a><strong>9.1.5.1. Configuring a Space to Use Navigation</strong></h5><p>如果没有使用客户端导航方法，加载导航网格将会导致不必要的额外内存使用(通常是10-50mb)。因此，默认情况下将不会加载导航网格。每个将使用导航的空间都必须配置为这样做。将以下部分添加到将使用客户端导航的任何space.settings文件中：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">clientNavigation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">enable</span>&gt;</span> true <span class="tag">&lt;/<span class="name">enable</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">clientNavigation</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这将确保客户端将加载与块数据一起存储的任何导航网格。</p>
<h5 id="9-1-5-2-Distributing-Navigation-Meshes-with-the-Client"><a href="#9-1-5-2-Distributing-Navigation-Meshes-with-the-Client" class="headerlink" title="9.1.5.2. Distributing Navigation Meshes with the Client"></a><strong>9.1.5.2. Distributing Navigation Meshes with the Client</strong></h5><p>如果没有为一个空间启用客户端导航，那么ResPacker将从客户端包的cdata文件中剥离导航网格。这是为了保持块资源文件尽可能小，以便于分发。</p>
<h5 id="9-1-5-3-BigWorld-navigatePathPoints"><a href="#9-1-5-3-BigWorld-navigatePathPoints" class="headerlink" title="9.1.5.3. BigWorld.navigatePathPoints()"></a><strong>9.1.5.3.</strong> <strong>BigWorld.navigatePathPoints()</strong></h5><p>BigWorld.navigatePathPoints()将获取源点和目的地点，并返回它们之间的点的路径，这样，依次移动到每个点将导致一个实体成功地导航到目的地。</p>
<p>该方法具有以下语法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">navigatePathPoints( src, dst, maxSearchDistance, girth )</span><br></pre></td></tr></table></figure>

<p>这些参数如下：</p>
<ul>
<li><p>src</p>
<p>Vertor3,其中包含当前空间中的源点。</p>
</li>
<li><p>dest</p>
<p>Vertor3,在当前空间中包含目标点。</p>
</li>
<li><p>maxSearchDistance</p>
<p>浮点数，包含从源点开始搜索路径的最大距离。(This deafaults to 500.)</p>
</li>
<li><p>girth</p>
<p>包含要使用的导航周网格的浮动。如果没有提供，则默认为0.5,并用于确保大型实体无法通过对它们来说太窄的区域。这个值必须对应girths文件中的一个girth条目，默认位于bigworld&#x2F;res&#x2F;helpers&#x2F;girths.xml。</p>
</li>
</ul>
<p>BigWorld.navigatePathPoints()返回一个包含该路径的向量3个点的列表。如果找不到一条路径，则它将引发一个异常。</p>
<p>例如，如果存在，以下调用将返回（100,10,200）和（150,20,50）之间路径上的点列表。所有点的路径宽度必须至少为4米，且总计必须小于300米：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BigWorld.navigatePathPoints( (<span class="number">100</span>, <span class="number">10</span>, <span class="number">200</span>), (<span class="number">150</span>, <span class="number">20</span>, <span class="number">50</span>), <span class="number">300</span>, <span class="number">4</span> )</span><br></pre></td></tr></table></figure>

<p>该路径将作为一个列表返回：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[(100,10,200), (121,3,148), (133,9,87), (144,8,61), (150,20,50)]</span><br></pre></td></tr></table></figure>

<h5 id="9-1-5-4-BigWorld-findRandomNeighbourPoint"><a href="#9-1-5-4-BigWorld-findRandomNeighbourPoint" class="headerlink" title="9.1.5.4. BigWorld.findRandomNeighbourPoint()"></a><strong>9.1.5.4.</strong> <strong>BigWorld.findRandomNeighbourPoint()</strong></h5><p>BigWorld.findRandomNeighbourPoint()将获取一个源点，并在一个已连接的导航网格中返回一个随机点。保证得到的点与源相连:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">findRandomNeighbourPoint( position, radius, girth )</span><br></pre></td></tr></table></figure>

<p>这些参数如下：</p>
<ul>
<li><p>position</p>
<p>Vector3,其中包含当前空间中的源点。</p>
</li>
<li><p>radius</p>
<p>浮点数，包含从源点开始搜索路径的最大距离。</p>
</li>
<li><p>girth</p>
<p>包含要使用的导航周网格的浮动。如果没有提供，则默认为0.5。</p>
</li>
</ul>
<p>BigWorld.findRandomNeighbourPoint()返回一个包含该随机点的向量3。如果找不到适当的点，它将引发一个异常。</p>
<p>例如，下面的调用将在点（100,10,200）的300m范围内返回一个随机点。到此点的路径在所有点至少0.5米宽。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BigWorld.findRandomNeighbourPoint( (<span class="number">100</span>, <span class="number">10</span>, <span class="number">200</span>), <span class="number">300</span>, <span class="number">0.5</span> )</span><br></pre></td></tr></table></figure>

<h5 id="9-1-5-5-BigWorld-findRandomNeighbourPointWithRange"><a href="#9-1-5-5-BigWorld-findRandomNeighbourPointWithRange" class="headerlink" title="9.1.5.5. BigWorld.findRandomNeighbourPointWithRange()"></a><strong>9.1.5.5.</strong> <strong>BigWorld.findRandomNeighbourPointWithRange()</strong></h5><p>此方法执行与BigWorld.findRandomNeighbourPoint()相同的功能，但使用一个指定最小半径的附加参数。这允许调用者指定到随机点的距离指定特定范围:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">findRandomNeighbourPointWithRange( position, minRadius, maxRadius, girth )</span><br></pre></td></tr></table></figure>

<ul>
<li><p>positon</p>
<p>源点</p>
</li>
<li><p>minRadius</p>
<p>浮点数，包含从源点搜索路径的最小距离。</p>
</li>
<li><p>maxRadius</p>
<p>浮点数，包含从源点搜索路径的最大距离。</p>
</li>
<li><p>girth</p>
<p>包含要使用的导航周网格的浮动。如果没有提供，则默认为0.5。</p>
</li>
</ul>
<p>BigWorld.findRandomNeighbourPoint()返回一个包含该随机点的向量3。如果找不到适当的点，它将引发一个异常。</p>
<p>例如，下面的调用将返回一个超过200米的随机点，但在点（150,20,50）的400米以内。到这一点的路径必须在所有点上至少有4米宽。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BigWorld.findRandomNeighbourPointWithRange( (<span class="number">150</span>, <span class="number">20</span>, <span class="number">50</span>), <span class="number">200</span>, <span class="number">400</span>, <span class="number">4</span> )</span><br></pre></td></tr></table></figure>

<h4 id="9-1-6-Action-Queue"><a href="#9-1-6-Action-Queue" class="headerlink" title="9.1.6. Action Queue"></a><strong>9.1.6. Action Queue</strong></h4><p>操作队列是BigWorld技术框架中的结构，它控制在模型上有效的动作队列（动作由操作队列中包含的动作队列对象包裹）。</p>
<p>动作队列处理层的组合，也应用适当的混合和混合时间。</p>
<p>ActionQueue还处理与动作播放相关的任何脚本回调函数，例如在动作的特定帧中调用声音播放回调。</p>
<p>操作在XML中描述，如下所示 example .model 文件（位于资源树下各种子文件夹中）：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">action</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span> ACTION_NAME <span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    ?<span class="tag">&lt;<span class="name">animation</span>&gt;</span> ANIMATION_NAME <span class="tag">&lt;/<span class="name">animation</span>&gt;</span></span><br><span class="line">    ?<span class="tag">&lt;<span class="name">blendInTime</span>&gt;</span> float <span class="tag">&lt;/<span class="name">blendInTime</span>&gt;</span></span><br><span class="line">    ?<span class="tag">&lt;<span class="name">blendOutTime</span>&gt;</span> float <span class="tag">&lt;/<span class="name">blendOutTime</span>&gt;</span></span><br><span class="line">    ?<span class="tag">&lt;<span class="name">filler</span>&gt;</span> [true|false] <span class="tag">&lt;/<span class="name">filler</span>&gt;</span></span><br><span class="line">    ?<span class="tag">&lt;<span class="name">track</span>&gt;</span> int <span class="tag">&lt;/<span class="name">track</span>&gt;</span></span><br><span class="line">    ?<span class="tag">&lt;<span class="name">isMovement</span>&gt;</span> [true|false] <span class="tag">&lt;/<span class="name">isMovement</span>&gt;</span></span><br><span class="line">    ?<span class="tag">&lt;<span class="name">isCoordinated</span>&gt;</span> [true|false] <span class="tag">&lt;/<span class="name">isCoordinated</span>&gt;</span></span><br><span class="line">    ?<span class="tag">&lt;<span class="name">isImpacting</span>&gt;</span> [true|false] <span class="tag">&lt;/<span class="name">isImpacting</span>&gt;</span></span><br><span class="line">    ?<span class="tag">&lt;<span class="name">match</span>&gt;</span></span><br><span class="line">        ?<span class="tag">&lt;<span class="name">trigger</span>&gt;</span></span><br><span class="line">            ?<span class="tag">&lt;<span class="name">minEntitySpeed</span>&gt;</span> float <span class="tag">&lt;/<span class="name">minEntitySpeed</span>&gt;</span></span><br><span class="line">            ?<span class="tag">&lt;<span class="name">maxEntitySpeed</span>&gt;</span> float <span class="tag">&lt;/<span class="name">maxEntitySpeed</span>&gt;</span></span><br><span class="line">            ?<span class="tag">&lt;<span class="name">minEntityAux1</span>&gt;</span> float <span class="tag">&lt;/<span class="name">minEntityAux1</span>&gt;</span></span><br><span class="line">            ?<span class="tag">&lt;<span class="name">maxEntityAux1</span>&gt;</span> float <span class="tag">&lt;/<span class="name">maxEntityAux1</span>&gt;</span></span><br><span class="line">            ?<span class="tag">&lt;<span class="name">minModelYaw</span>&gt;</span> float <span class="tag">&lt;/<span class="name">minModelYaw</span>&gt;</span></span><br><span class="line">            ?<span class="tag">&lt;<span class="name">maxModelYaw</span>&gt;</span> float <span class="tag">&lt;/<span class="name">maxModelYaw</span>&gt;</span>Coor</span><br><span class="line">            ?<span class="tag">&lt;<span class="name">capsOn</span>&gt;</span> capabilities <span class="tag">&lt;/<span class="name">capsOn</span>&gt;</span></span><br><span class="line">            ?<span class="tag">&lt;<span class="name">capsOff</span>&gt;</span> capabilities <span class="tag">&lt;/<span class="name">capsOff</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">trigger</span>&gt;</span></span><br><span class="line">        ?<span class="tag">&lt;<span class="name">cancel</span>&gt;</span></span><br><span class="line">            ?<span class="tag">&lt;<span class="name">minEntitySpeed</span>&gt;</span> float <span class="tag">&lt;/<span class="name">minEntitySpeed</span>&gt;</span></span><br><span class="line">            ?<span class="tag">&lt;<span class="name">maxEntitySpeed</span>&gt;</span> float <span class="tag">&lt;/<span class="name">maxEntitySpeed</span>&gt;</span></span><br><span class="line">            ?<span class="tag">&lt;<span class="name">minEntityAux1</span>&gt;</span> float <span class="tag">&lt;/<span class="name">minEntityAux1</span>&gt;</span></span><br><span class="line">            ?<span class="tag">&lt;<span class="name">maxEntityAux1</span>&gt;</span> float <span class="tag">&lt;/<span class="name">maxEntityAux1</span>&gt;</span></span><br><span class="line">            ?<span class="tag">&lt;<span class="name">minModelYaw</span>&gt;</span> float <span class="tag">&lt;/<span class="name">minModelYaw</span>&gt;</span></span><br><span class="line">            ?<span class="tag">&lt;<span class="name">maxModelYaw</span>&gt;</span> float <span class="tag">&lt;/<span class="name">maxModelYaw</span>&gt;</span>Coor</span><br><span class="line">            ?<span class="tag">&lt;<span class="name">capsOn</span>&gt;</span> capabilities <span class="tag">&lt;/<span class="name">capsOn</span>&gt;</span></span><br><span class="line">            ?<span class="tag">&lt;<span class="name">capsOff</span>&gt;</span> capabilities <span class="tag">&lt;/<span class="name">capsOff</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">cancel</span>&gt;</span></span><br><span class="line">        ?<span class="tag">&lt;<span class="name">scalePlaybackSpeed</span>&gt;</span> [true|false] <span class="tag">&lt;/<span class="name">scalePlaybackSpeed</span>&gt;</span></span><br><span class="line">        ?<span class="tag">&lt;<span class="name">feetFollowDirection</span>&gt;</span> [true|false] <span class="tag">&lt;/<span class="name">feetFollowDirection</span>&gt;</span></span><br><span class="line">        ?<span class="tag">&lt;<span class="name">oneShot</span>&gt;</span> [true|false] <span class="tag">&lt;/<span class="name">oneShot</span>&gt;</span>En</span><br><span class="line">        ?<span class="tag">&lt;<span class="name">promoteMotion</span>&gt;</span> [true|false] <span class="tag">&lt;/<span class="name">promoteMotion</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">match</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>name</strong></p>
<p>由脚本所使用的该操作的名称。这些都可以作为模型管理器返回的模型对象中的命名“常量”使用</p>
</li>
<li><p><strong>animation</strong></p>
<p>从中生成帧数据的基本动画。</p>
</li>
<li><p><strong>blendInTime</strong></p>
<p>动作完全融入的时间以秒为单位。</p>
</li>
<li><p><strong>blendOutTime</strong></p>
<p>以秒为单位的时间，动作需要完全混合。</p>
</li>
<li><p><strong>filler</strong></p>
<p>指定操作是否只是填充，如果队列中出现其他内容，则可以中断。</p>
</li>
<li><p><strong>track</strong></p>
<p>应该播放动作的曲目号。如果动作有一个轨迹，那么动画将被混合在任何其他动画之上——也就是说，它将绕过队列。</p>
</li>
<li><p><strong>isMovement</strong></p>
<p>指定动作使用简单的移动动画，如走、跑、侧走等。平移必须是线性的，并且在播放时从动作中减去(所以从原点移动的运行动画现在会显示在现场运行)。此设置需要设置PromoteMotion标志，这样做意味着此转换然后相应地移动模型。如果模型属于客户控制的实体，那么服务器端实体的位置将相应地更新。这个设置允许使用scalePlaybackSpeed。此设置不能与isCoordinated一起使用。</p>
</li>
<li><p><strong>isCoordinated</strong></p>
<p>指定动作的动画从偏移位置开始。用于需要与非玩家角色(NPC)协调的行动，为了匹配接触点(例如握手)，非玩家角色需要相对于玩家角色的位置。这个设置不能和isMovement和isimpacting一起使用。</p>
</li>
<li><p><strong>isImpacting</strong></p>
<p>指定动作是一个复杂(非线性)的运动动画。如果实体是客户端控制的，那么它在服务器上的位置也会被更新。使用isimpact的动画包括跳跃、战斗和击倒、与实体互动等。此设置需要promotemmotion，不能与isMovement和isCoordinated一起使用。</p>
</li>
<li><p><strong>match</strong></p>
<p>如果这个部分存在，这意味着Action Matcher可以自动选择动作(参见下面)。</p>
</li>
<li><p><strong>trigger (section match)</strong></p>
<p>定义了用于确定何时启动操作的标准。</p>
</li>
<li><p><strong>minEntitySpeed</strong> <strong>(section</strong> <strong>trigger)</strong></p>
<p>确定要启动操作的实体的最小速度。</p>
</li>
<li><p><strong>maxEntitySpeed</strong> <strong>(section</strong> <strong>trigger)</strong></p>
<p>确定要启动操作的实体的最大速度。</p>
</li>
<li><p><strong>minEntityAux1</strong> <strong>(section</strong> <strong>trigger)</strong></p>
<p>确定要开始操作的实体的最小俯仰（pitch）。</p>
</li>
<li><p><strong>maxEntityAux1</strong> <strong>(section</strong> <strong>trigger)</strong></p>
</li>
<li><p>确定要开始操作的实体的最大俯仰(pithc)。</p>
</li>
<li><p><strong>minModelYaw</strong> <strong>(section</strong> <strong>trigger)</strong></p>
<p>确定开始动作时模型的最小偏航(yaw)。</p>
</li>
<li><p><strong>maxEntityYaw</strong> <strong>(section</strong> <strong>trigger)</strong></p>
<p>确定开始动作时模型的最大偏航(yaw)。</p>
</li>
<li><p><strong>capsOn</strong> <strong>(section</strong> <strong>trigger)</strong></p>
<p>确定启动操作需要打开哪些特殊情况字符状态。</p>
</li>
<li><p><strong>capsOff</strong> <strong>(section</strong> <strong>trigger)</strong></p>
<p>确定启动操作需要关闭哪些特殊情况字符状态。</p>
</li>
<li><p><strong>cancel</strong> <strong>(section</strong> <strong>match)</strong></p>
<p>本节定义了用于确定何时停止操作的标准。</p>
</li>
<li><p><strong>minEntitySpeed</strong> <strong>(section</strong> <strong>cancel)</strong></p>
<p>确定动作停止的实体的最小速度。</p>
</li>
<li><p><strong>maxEntitySpeed</strong> <strong>(section</strong> <strong>cancel)</strong></p>
<p>确定动作停止的实体的最大速度。</p>
</li>
<li><p><strong>minEntityAux1</strong> <strong>(section</strong> <strong>cancel)</strong></p>
<p>确定要停止动作的实体的最小俯仰（pitch）</p>
</li>
<li><p><strong>maxEntityAux1</strong> <strong>(section</strong> <strong>cancel)</strong></p>
<p>确定要停止动作的实体的最大俯仰（pitch）</p>
</li>
<li><p><strong>minModelYaw</strong> <strong>(section</strong> <strong>cancel)</strong></p>
<p>确定使动作停止的模型的最小偏航。</p>
</li>
<li><p><strong>maxEntityYaw</strong> <strong>(section</strong> <strong>cancel)</strong></p>
<p>确定使动作停止的模型的最大偏航。</p>
</li>
<li><p><strong>capsOn</strong> <strong>(section</strong> <strong>cancel)</strong></p>
<p>确定需要打开哪些特殊情况字符状态才能停止操作。</p>
</li>
<li><p><strong>capsOff</strong> <strong>(section</strong> <strong>cancel)</strong></p>
<p>确定需要关闭哪些特殊情况字符状态才能停止操作。</p>
</li>
<li><p><strong>scalePlaybackSpeed</strong> <strong>(section</strong> <strong>match)</strong></p>
<p>指定动画播放速度应按实体速度的函数缩放。这个设置需要isMovement。</p>
</li>
<li><p><strong>feetFollowDirection</strong> <strong>(section</strong> <strong>match)</strong></p>
<p>指定模型应该转向跟踪实体。在实践中，这意味着当这个动作匹配时，模型在现场旋转，而不是执行旋转动作。</p>
</li>
<li><p><strong>oneShot</strong> <strong>(section</strong> <strong>match)</strong></p>
<p>指定动作匹配器只会在一行中选择播放一次。注意this和filler之间的区别，其中filler与动作匹配器无关。</p>
</li>
<li><p><strong>promoteMotion</strong> <strong>(section</strong> <strong>match)</strong></p>
<p>指定动画中根节点的运动应该影响模型的位置(以及所有者实体的位置，如果实体是客户端控制的)。isImpacting或isMovement动作必须启用该设置才能正常工作。此设置不能与filler一起使用。</p>
</li>
</ul>
<p>模型操作队列的Python接口允许在该模型上直接播放操作，或者将一组操作排队并按顺序播放。回调函数可以在操作完成时定义和播放。</p>
<p>在Python中，可以很容易地创建一个模型，并在其上播放一个动作，如下面的例子所示:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Jogger</span>( BigWorld.Entity ):</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"> self </span>):</span><br><span class="line">        self.model = BigWorld.Model( <span class="string">&quot;jogger.model&quot;</span> )</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">warmUp</span>(<span class="params"> self </span>):</span><br><span class="line">            self.model.action( <span class="string">&quot;StretchLegs&quot;</span> )()</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure>



<h5 id="9-1-6-1-Debugging-animations"><a href="#9-1-6-1-Debugging-animations" class="headerlink" title="9.1.6.1. Debugging animations"></a><strong>9.1.6.1. Debugging animations</strong></h5><p>如果模型没有按照预期的那样设置动画，那么在Python控制台中显示动作队列图就会很有用。</p>
<p>这可以通过调用BigWorld.debugAQ()方法来完成，它可以接收两种参数:</p>
<ul>
<li><p><strong>PyModel</strong></p>
<p>显示指定模型的图形，以及每个操作的混合权重。每个动作都以任意选择的不同颜色表示。</p>
</li>
<li><p><strong>None</strong></p>
</li>
</ul>
<p>  关闭图形显示器。</p>
<p><img src="/image%5Cbigworld%5C05_05.png" alt="05_05"></p>
<p><em>Python控制台显示动作队列的调试图</em></p>
<p>上图中的图表显示了转左动画（绿色）和空闲动画（红色）上的执行情况。我们可以确定在图中的每个标记点中播放的动画：</p>
<ul>
<li><p><strong>A</strong> — Idle动画100%被播放</p>
</li>
<li><p><strong>Between A and B</strong> — Idle 动画正在与TurnLeft动画混合。</p>
</li>
<li><p><strong>B</strong> — Idle动画的50%正在播放，TurnLeft动画的50%正在播放。</p>
</li>
<li><p><strong>C</strong> — 100%的TurnLeft动画正在播放。</p>
</li>
</ul>
<p>有关更多细节，请参见Client Python API。</p>
<h4 id="9-1-7-Action-Matcher"><a href="#9-1-7-Action-Matcher" class="headerlink" title="9.1.7. Action Matcher"></a><strong>9.1.7. Action Matcher</strong></h4><p>给定一个模型、一个动作队列和一组动作，一个游戏对象&#x2F;角色的所有行为都可以通过在动作队列上的事件驱动调用来指定。这最终会带来沉重的开销，因为许多对象状态的改变需要直接调用对象并解决应该播放哪个动画。</p>
<p>这个问题的解决方案是将角色的大部分行为内部化到一个称为Action Matcher的系统中，它会根据对象的状态自动更新对象的运动。它是一个简单的模式匹配器，根据模型的属性(如速度、方向等)来选择动画。</p>
<p>诸如速度、旋转或功率等状态参数被公开给Action Matcher，然后它选择最适合映射到这些参数的动作。这将使游戏从处理动画的许多方面中解放出来，允许它只需要更新状态参数，如位置</p>
<p>当模型(在玩家的AoI中)的动作队列中没有(未混合的)动作时，动作匹配器将接管并执行一个“空闲”动作。它触发这些“空闲”的动画，赋予游戏世界更多生命，因为真实的有生命的东西不是静止的。它也可以用来自动化低级的动画任务。</p>
<p>脚本约束是针对capsOn和capsOff能力位字段进行测试的。模型的Action Matcher有一组能力位，它的值是由脚本控制的。只有在动作匹切集合中所有的capsOn位都是开启的，而所有的capsOff位都是关闭的，动作才会被匹配。</p>
<p>然后它会查看姿态的变化(位置和方向-由过滤器设置)，并选择与变化发生时间相匹配的第一个动作。触发器约束用于测试大多数操作。如果遇到与上一帧匹配的动作，则使用取消约束。这个特性主要是为了减少动作滞后。</p>
<p>动作匹配对象的更新函数取该对象之前更新的位置，从其匹配的动作列表中选择最佳匹配的动作，然后以正确的速度播放动画，使动作与速度平滑连接。当游戏角色开始快速移动时，动作匹配器可能会选择更快的运行周期来回放，并提高播放速度以精确匹配速度，因此不会看到脚滑动。</p>
<p>这种方法允许AI系统根据一些变量(如方向、速度和瞄准方向)定义行为，Action Matcher将把这些更新的参数转换成一个平滑移动的角色。</p>
<p>在客户端&#x2F;服务器架构中，位置和方向是通过网络更新的，Action Matcher</p>
<p>(结合过滤器)可以通过让角色更快地跑到最新更新的位置来自动补偿由网络延迟引起的位置跳跃。</p>
<p>当加载一个操作时，它的数据会随着执行该操作将对根节点产生的姿态影响而增强。此信息用于上面描述的匹配。</p>
<p>现在已经选择了一个操作，它将被传递到操作队列。如果提供的动作与前一个动作相同，它将继续以正常方式播放(例如，frame +&#x3D; fps*deltaTime)。否则，它将被混合在几帧中，而另一帧则被混合出去。</p>
<h5 id="9-1-7-1-Using-the-Action-Matcher"><a href="#9-1-7-1-Using-the-Action-Matcher" class="headerlink" title="9.1.7.1. Using the Action Matcher"></a><strong>9.1.7.1. Using the Action Matcher</strong></h5><p>设计用于匹配的每个动作都必须定义一个&lt;match&gt;节。这些是使用Actions窗口通过Model Editor添加的。匹配参数分为两部分:</p>
<ul>
<li><p><strong>Trigger parameters</strong> </p>
<p>定义何时可以启动一个操作</p>
</li>
<li><p><strong>Cancel section</strong></p>
<p>定义何时应停止一个操作</p>
</li>
</ul>
<p>每个部分中的minEntitySpeed和minEntitySpeed标签定义了动作可以或不可以被触发或取消的速度。</p>
<p>辅助参数可用于定义用于匹配动作的俯仰范围。minModelYaw和maxModelYaw标签定义了一个偏航范围。主要匹配参数定义了动作应用的速度和方向范围，以及一组用户定义的匹配标志，用于特殊情况字符状态。这些标志可以用来设置游戏角色是否没有使用基本动作集，如受伤或生气。</p>
<p>BigWorld引擎使用matchCaps参数来存储操作的按位标志集。在任何给定的时间，模型本身都会有一个开&#x2F;关标志设置来表示这些状态的状态，这将在每帧的每个动作的matchCaps中进行测试。</p>
<p>应该定义一组用户定义的操作状态(作为文本文件或模型文件中的注释部分创建)。下面是一个简单的例子:</p>
<ul>
<li><strong>Capability flag: 1</strong> — State: Angry</li>
<li><strong>Capability flag: 2</strong> — State: Happy</li>
<li><strong>Capability flag: 3</strong> — State: Sad</li>
</ul>
<p>现在，只要在当前的matchCaps中添加愤怒标志，就可以使用动作匹配器访问愤怒动画的集合。在Python代码中，一个字符现在应该以愤怒的方式移动和行为的简单示例如下所示:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AngryMan</span>( BigWorld.Entity ):</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">onEnterWorld</span>(<span class="params"> self, prereqs </span>):</span><br><span class="line">        self.am = BigWorld.ActionMatcher( self )</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">enterAngryMode</span>(<span class="params"> self </span>):</span><br><span class="line">            self.am.matchCaps = self.am.matchCaps + [<span class="number">1</span>]</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure>

<p><em>愤怒模式下字符的Python实现</em></p>
<p>通过以这种方式使用Action Matcher，角色的自然运动可以被充实，而不需要显式地调用任何函数来播放动画。特定的基于事件的操作仍然可以通过Action Queue结构直接调用，但角色的背景行为可以使用Model Editor工具完全定义，并在代码库中适当地设置匹配标志。</p>
<h4 id="9-1-8-Trackers"><a href="#9-1-8-Trackers" class="headerlink" title="9.1.8. Trackers"></a><strong>9.1.8. Trackers</strong></h4><p>跟踪器对实体模型中的节点应用逆运动学，使它们看起来指向给定的“目标”实体定义的位置。一个实体可以有任意数量的跟踪器。</p>
<p>要将跟踪器添加到实体，请使用这样的脚本调用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">tracker = BigWorld.Tracker()</span><br><span class="line">tracker.dirProvider = DiffDirProvider( </span><br><span class="line">    self.focalMatrix, target.focalMatrix )</span><br><span class="line">tracker.nodeInfo = BigWorld.TrackerNodeInfo(</span><br><span class="line">    model,</span><br><span class="line">    primaryNode, </span><br><span class="line">    secondaryNodeList, </span><br><span class="line">    pointingNodeName,</span><br><span class="line">    minPitch, maxPitch,</span><br><span class="line">    minYaw, maxYaw,</span><br><span class="line">    angularVelocity )</span><br><span class="line">self.model.tracker = tracker</span><br></pre></td></tr></table></figure>

<p><em>在Python中添加tracker</em></p>
<p>这个BigWorld.TrackerNodeInfo方法描述如下：</p>
<ul>
<li><p><strong>model</strong></p>
<p>拥有跟踪器将影响的节点的PyModel</p>
</li>
<li><p><strong>primaryNode</strong></p>
<p>主节点引用。</p>
<p>节点引用从实体的独立模型(如果有多个，则为第一个模型)构建，遵循附加点路径，以节点名称结束。这允许跟踪器透明地通过附加的模型工作(即，他们被当作是焊接在模型的骨架上)。</p>
</li>
<li><p><strong>secondaryNodeList</strong></p>
<p>次要节点列表，包含形式为(节点，权重)的元组。</p>
<p>它们与主节点上执行的转换相同，与权重大小成比例。实际上，所有权值(包括主节点，其权值为1.0)都是求和的，每个节点都将得到应用于它们的权值占总权值的比例。</p>
</li>
<li><p><strong>pointingNodeName</strong></p>
<p>提供用于跟踪器操作的参考框架的节点名称。</p>
<p>如果指定的节点不存在，则使用模型的场景根节点。</p>
</li>
<li><p><strong>minPitch,maxPitch,minYaw,maxYaw</strong></p>
<p>追踪器允许使用的转弯限制，以度为单位。</p>
</li>
<li><p><strong>angularVelocity</strong></p>
<p>跟踪器将其影响的PyModelNode实例旋转的速度，以每秒度为单位。</p>
</li>
</ul>
<h4 id="9-1-9-Timers-and-Traps"><a href="#9-1-9-Timers-and-Traps" class="headerlink" title="9.1.9. Timers and Traps"></a><strong>9.1.9. Timers and Traps</strong></h4><p>这些都是提供给实体脚本的通用助手服务。</p>
<p>脚本可以设置计时器，使其在特定时间被回调，如下面的例子所示:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BigWorld.callback( afterTime, fn )</span><br></pre></td></tr></table></figure>

<p>陷阱（Traps）使用一个稍微不同的接口:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trapRef = self.addTrap( radius, function )</span><br></pre></td></tr></table></figure>

<p>如果任何实体在创建它的实体的给定半径内徘徊，则会触发陷阱，并且可以使用self.delTrap方法取消该陷阱。</p>
<p>还有另外两种类型的陷阱，根据它们的特定需要进行了优化，如下所述。</p>
<h5 id="9-1-9-1-Pot"><a href="#9-1-9-1-Pot" class="headerlink" title="9.1.9.1. Pot"></a><strong>9.1.9.1. Pot</strong></h5><p>Pot是一个“只针对玩家的陷阱”，并且只会被玩家实体所触发。因此，它比一般的陷阱要便宜得多。</p>
<p>给定矩阵提供程序、半径和用于触发的脚本回调，就会添加一个Pot</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">potHandle = BigWorld.addPot( trapMatrix, radius, callback )</span><br></pre></td></tr></table></figure>

<h5 id="9-1-9-2-Mat"><a href="#9-1-9-2-Mat" class="headerlink" title="9.1.9.2. Mat"></a><strong>9.1.9.2. Mat</strong></h5><p>Mat是一个“矩阵陷阱”，当一个区域被另一个区域触发时就会被触发。这之所以有意义，是因为矩阵提供程序是动态的。这些区域被定义为:</p>
<ul>
<li>源矩阵转换和由矩阵中x、y和z轴的比例给出的边界区域。</li>
<li>目标矩阵的目标矩阵转换(作为一个点处理)。</li>
</ul>
<p>Mat在Python中定义如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matHandle = BigWorld.addMat( sourceMatrix, callback, destMatrix )</span><br></pre></td></tr></table></figure>

<h3 id="9-2-Personality-script"><a href="#9-2-Personality-script" class="headerlink" title="9.2. Personality script"></a><strong>9.2. Personality script</strong></h3><p>个性脚本是一个Python脚本，用于处理来自BigWorld引擎的几个回调，用于初始化、清理、输入处理和环境更改。它还可以实现不属于游戏中任何特定实体的客户端功能，如游戏开始屏幕。</p>
<p>它的名称在resources.xml的engineConfigXML标记指定的文件中定义。</p>
<p>个性脚本通常声明一个类来包含脚本中函数共享的所有数据，并使用该类的构造函数声明一个全局变量。例如，个性脚本可能包括以下代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SharedData</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"> self </span>):</span><br><span class="line">        self.settings = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="comment"># initialise the shared data object for this personality script</span></span><br><span class="line">        sd = SharedData()</span><br><span class="line">        <span class="comment"># This callback is called by BigWorld when initialising</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">init</span>(<span class="params"> configSect </span>):</span><br><span class="line">            <span class="comment"># save the configSect object for later use</span></span><br><span class="line">            sd.configSect = configSect</span><br></pre></td></tr></table></figure>

<p>下面的部分描述了可用的个性回调。</p>
<h4 id="9-2-1-init"><a href="#9-2-1-init" class="headerlink" title="9.2.1. init"></a><strong>9.2.1.</strong> <strong>init</strong></h4><p>回调函数的语法如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init(scriptsConfig, engineConfig, preferences, loadingScreenGUI = <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<p>当引擎初始化时，脚本被调用一次，并接收以下参数:</p>
<ul>
<li><p><strong>scriptsConfig</strong>,<strong>engineConfig</strong>,<strong>preferences</strong></p>
<p>PyDataSection对象，包含来自resources.xml的scriptsConfigXML标签中定义的XML文件的数据</p>
</li>
<li><p><strong>loadingScreenGUI</strong></p>
<p>可选参数表示加载屏幕GUI，如果在resources.xml中定义了一个GUI(有关详细信息，请参阅“File &lt;preferences&gt;.xml .xml”)</p>
</li>
</ul>
<p>下面列出了可用的读取函数:</p>
<ul>
<li><p><strong>readBool</strong></p>
</li>
<li><p><strong>readFloat</strong></p>
</li>
<li><p><strong>readFloats</strong></p>
</li>
<li><p><strong>readInt</strong></p>
</li>
<li><p><strong>readInts</strong></p>
</li>
<li><p><strong>readMatrix34</strong></p>
</li>
<li><p><strong>readString</strong></p>
</li>
<li><p><strong>readStrings</strong></p>
</li>
<li><p><strong>readVector2</strong></p>
</li>
<li><p><strong>readVector2s</strong></p>
</li>
<li><p><strong>readVector3</strong></p>
</li>
<li><p><strong>readVector3s</strong></p>
</li>
<li><p><strong>readVector4</strong></p>
</li>
<li><p><strong>readVector4s</strong></p>
</li>
<li><p><strong>readWideString</strong></p>
</li>
<li><p><strong>readWideStrings</strong></p>
</li>
</ul>
<p>要从PyDataSection读取数据，调用与数据类型相关的read函数，将节名作为第一个参数传入，将默认值作为第二个参数传入。复数read函数(以’s’结尾)读取指定节中所有匹配子节的内容，并将结果作为值的元组返回。您可以使用正斜杠来引用子部分。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username = userPreferences.readString(<span class="string">&quot;login/username&quot;</span>, <span class="string">&quot;guest&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>还可以通过调用带下划线前缀的节名来引用PyDataSection的子节:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username = userPreferences._login._username.asString</span><br></pre></td></tr></table></figure>

<h4 id="9-2-2-fini"><a href="#9-2-2-fini" class="headerlink" title="9.2.2. fini"></a><strong>9.2.2.</strong> <strong>fini</strong></h4><p>回调函数的语法如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fini()</span><br></pre></td></tr></table></figure>

<p>这个脚本在客户机引擎关闭时被调用。它用于在客户端退出之前执行任何必需的清理。这是对玩家执行注销过程的好地方。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># note: you must set up a logOff method as a base method in the</span></span><br><span class="line"><span class="comment"># def file of the class that the player is using.</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fini</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        BigWorld.player().base.logOff()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h4 id="9-2-3-handleKeyEvent"><a href="#9-2-3-handleKeyEvent" class="headerlink" title="9.2.3. handleKeyEvent"></a><strong>9.2.3.</strong> <strong>handleKeyEvent</strong></h4><p>回调函数的语法如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handleKeyEvent( event )</span><br></pre></td></tr></table></figure>

<p>event参数是一个PyKeyEvent，它包含关于键事件的信息。</p>
<p>通常，几个系统都可以处理键盘输入，因此参数依次传递给每个系统上的handleKeyEvent方法，直到有一个返回布尔值True，表明它已经处理了键事件。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">handleKeyEvent</span>(<span class="params"> event </span>):</span><br><span class="line">    <span class="keyword">global</span> rds</span><br><span class="line">    <span class="comment"># give the chat console a go first</span></span><br><span class="line">    <span class="keyword">if</span> rds.chat.editing:</span><br><span class="line">        <span class="keyword">if</span> rds.chat.handleKeyEvent( event ):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># try the gui</span></span><br><span class="line">        <span class="keyword">if</span> GUI.handleKeyEvent( event ):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="comment"># now do our custom keys</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> event.isKeyDown(): <span class="keyword">return</span> <span class="literal">False</span> <span class="comment"># we are not interested in key releases</span></span><br><span class="line">        <span class="keyword">if</span> event.key == KEY_RETURN <span class="keyword">and</span> event.modifiers == <span class="number">0</span>:</span><br><span class="line">            rds.chat.edit( <span class="literal">True</span> ) <span class="comment"># bring up the chat console</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># return False because the key event has not been handled</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>注意，引擎也会在玩家控制的实体上调用handleKeyEvent方法。所有与玩家控制相关的键都在那里处理。</p>
<h4 id="9-2-4-handleMouseEvent"><a href="#9-2-4-handleMouseEvent" class="headerlink" title="9.2.4. handleMouseEvent"></a><strong>9.2.4.</strong> <strong>handleMouseEvent</strong></h4><p>该回调函的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handleMouseEvent( event )</span><br></pre></td></tr></table></figure>

<p>每当鼠标移动时，将调用此脚本，并给出一个PyMouseEvent的实例。它的操作方式类似于处理按键事件。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">handleMouseEvent</span>(<span class="params"> event </span>):</span><br><span class="line">    <span class="comment"># try the gui</span></span><br><span class="line">    <span class="keyword">if</span> GUI.handleMouseEvent( event ):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="comment"># return False because the mouse event has not been handled</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h4 id="9-2-5-handleAxisEvent"><a href="#9-2-5-handleAxisEvent" class="headerlink" title="9.2.5. handleAxisEvent"></a><strong>9.2.5.</strong> <strong>handleAxisEvent</strong></h4><p>该回调函的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handleAxisEvent( event )</span><br></pre></td></tr></table></figure>

<p>这个脚本在操纵杆轴事件发生时被调用，并被给出PyAxisEvent的一个实例。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">handleAxisEvent</span>(<span class="params"> event </span>):</span><br><span class="line">    <span class="comment"># try the GUI</span></span><br><span class="line">    <span class="keyword">if</span> GUI.handleAxisEvent( event ):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="comment"># return False because the axis event has not been handled</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h4 id="9-2-6-handleIMEEvent"><a href="#9-2-6-handleIMEEvent" class="headerlink" title="9.2.6. handleIMEEvent"></a><strong>9.2.6.</strong> <strong>handleIMEEvent</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handleIMEEvent( event )</span><br></pre></td></tr></table></figure>

<p>当Input Method Editor (IME)相关事件发生时调用它，并分别用于更新GUI，并给出一个PyIMEEvent对象作为它的第一个参数。</p>
<h4 id="9-2-7-handleLangChangeEvent"><a href="#9-2-7-handleLangChangeEvent" class="headerlink" title="9.2.7. handleLangChangeEvent"></a><strong>9.2.7.</strong> <strong>handleLangChangeEvent</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handleLangChangeEvent()</span><br></pre></td></tr></table></figure>

<p>每当用户更改当前输入语言时，就会发生此事件。它对于在GUI编辑字段上更新语言指示器之类的任务非常有用。</p>
<h4 id="9-2-8-onChangeEnvironments"><a href="#9-2-8-onChangeEnvironments" class="headerlink" title="9.2.8. onChangeEnvironments"></a><strong>9.2.8.</strong> <strong>onChangeEnvironments</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onChangeEnvironments( inside )</span><br></pre></td></tr></table></figure>

<p>这个脚本是一个回调，确认玩家当前所处的环境类型。</p>
<p>目前只有内部和外部环境类型。参数是一个布尔值，指示玩家是否在内部。这对于修改第三人称模式下的摄像机行为可能是有用的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">onChangeEnvironments</span>(<span class="params"> inside </span>):</span><br><span class="line">    <span class="keyword">global</span> sd</span><br><span class="line">    sd.inside = inside</span><br><span class="line">    sd.updatePivotDist()</span><br></pre></td></tr></table></figure>

<h4 id="9-2-9-onGeometryMapped"><a href="#9-2-9-onGeometryMapped" class="headerlink" title="9.2.9. onGeometryMapped"></a><strong>9.2.9.</strong> <strong>onGeometryMapped</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onGeometryMapped(spaceID, spacePath)</span><br></pre></td></tr></table></figure>

<p>这个回调方法告诉玩家实体关于空间几何的变化。当几何图形映射到客户机上任何当前存在的空间时，调用它。空间ID和空间几何图形的名称作为参数传递。</p>
<p>第一个参数是几何图形要映射到的空间的ID。第二个参数是描述空间几何形状的名称。</p>
<h4 id="9-2-10-onRecreateDevice"><a href="#9-2-10-onRecreateDevice" class="headerlink" title="9.2.10. onRecreateDevice"></a><strong>9.2.10.</strong> <strong>onRecreateDevice</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onRecreateDevice ()</span><br></pre></td></tr></table></figure>

<p>这个脚本是一个回调，提醒脚本Direct3D设备已经重新创建。当屏幕分辨率改变时，经常会发生这种情况。</p>
<p>引入这个回调主要是为了让脚本可以重新布局它们的GUI组件脚本，但它对于重新创建任何静态PyModelRenderer纹理也很有用(因为这些纹理不会自动更新，除非它们是动态的)。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">onRecreateDevice</span>():</span><br><span class="line">    (width,height) = GUI.screenResolution()</span><br><span class="line">    myGuiController.doLayout( width, height )</span><br><span class="line">    myRenderers.recreateTextures()</span><br></pre></td></tr></table></figure>

<h4 id="9-2-11-onTimeOfDayLocalChange"><a href="#9-2-11-onTimeOfDayLocalChange" class="headerlink" title="9.2.11. onTimeOfDayLocalChange"></a><strong>9.2.11.</strong> <strong>onTimeOfDayLocalChange</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onTimeOfDayLocalChange( gameTime, secondsPerGameHour )</span><br></pre></td></tr></table></figure>

<p>这个脚本是一个回调，允许脚本被通知游戏时间的变化。</p>
<p>它传递两个浮点数作为参数:第一个是以秒为单位的游戏时间，第二个是每个游戏小时的实时秒数。</p>
<h4 id="9-2-12-start"><a href="#9-2-12-start" class="headerlink" title="9.2.12. start"></a><strong>9.2.12.</strong> <strong>start</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start()</span><br></pre></td></tr></table></figure>

<p>这个脚本在引擎初始化后被调用，并用于启动游戏。它可以用来打开开始菜单或登录屏幕。</p>
<h2 id="10-Models"><a href="#10-Models" class="headerlink" title="10. Models"></a><strong>10. Models</strong></h2><p>对于BigWorld客户端来说，模型是一个独立的几何单元，可以在世界空间变换矩阵的位置将自己绘制到3D场景中。此外，所有模型都可能具有随时间改变其外观的动画——一些模型显式支持其节点的动画(蒙皮)，而其他模型则通过显示替代几何图形进行动画。</p>
<p>Moo是BigWorld 3D引擎，目前可以导出三种对象作为模型:</p>
<ul>
<li>Meshes with skeletons（网格骨架）</li>
<li>Meshes without skeletons（没有骨骼的网格）</li>
<li>Billboards (广告牌，一种特殊的简单几何形式)</li>
</ul>
<p>然而，BigWorld客户机中的模型概念封装了符合上述定义的任何东西，并且很容易扩展实现以合并新类型的对象。</p>
<p>Moo命名其网格视觉效果(视觉效果实际上包含的不仅仅是一个简单的多边形网格。它们还可以有一组网格、骨骼、信封、材料和层次骨架)，并且可以使用BigWorld输出器从3dsMax模型轻松地创建。</p>
<p>模型文件还可以指定在远处绘制时使用的更简单的父文件。由此形成的父模型文件链被称为详细级别(LOD)链。</p>
<h3 id="10-1-Performance"><a href="#10-1-Performance" class="headerlink" title="10.1. Performance"></a><strong>10.1. Performance</strong></h3><p>为了提高呈现性能，可以在model Editor中将模型标记为批处理呈现，这将导致在生成的模型文件中创建批处理标记。</p>
<p>批处理渲染通过在遍历时缓存每个实例的数据(主要是光照条件和转换)来工作，一旦场景遍历，同时渲染所有实例，只更新每次渲染所需的数据。这节省了引擎设置顶点，索引和纹理多次批处理模型。它确实使用了更多的内存，但提供了相当大的性能提升。</p>
<p>在场景中有很多实例的模型上使用批处理标志是明智的。在FantasyDemo中，批处理标记被用于树、守卫、战斗、鸡和守卫的枪上。请注意，该标志不会影响使用着色的模型。</p>
<h3 id="10-2-Hard-Points"><a href="#10-2-Hard-Points" class="headerlink" title="10.2. Hard Points"></a><strong>10.2. Hard Points</strong></h3><p>硬点，或附加点，可以被认为是符合逻辑的魔术贴补丁，让我们可以把枪放在手里，把背包挂在肩膀上，或在炮塔上放置安全摄像头。美术人员必须使用虚拟节点将硬点嵌入到their.visual文件中。</p>
<p>硬点使用定义良好的名称，前面加上’HP_’前缀，以便实体可以扫描硬点节点。重要信息为:</p>
<ul>
<li>Name</li>
<li>Position</li>
<li>Orientaiton</li>
</ul>
<p>这一信息允许开发者在游戏逻辑的约束下将任何对象附加到其他对象上。</p>
<p>例如：</p>
<ul>
<li>HP_LeftHand</li>
<li>HP_RightHand</li>
<li>HP_Shoulder</li>
<li>HP_Belt1</li>
</ul>
<p><strong>10.2.1. Naming scheme</strong></p>
<p>为了避免中间步骤的需要，角色硬点和道具硬点之间需要明确的配对。每件物品都需要一个硬点来固定它。</p>
<p>以下便是关于人类角色和枪支的hard points。</p>
<ul>
<li><p><strong>In</strong> <strong>human.model:</strong></p>
<p>• HP_Left_Hand</p>
<p>• HP_Right_Hand</p>
<p>• HP_Belt_1</p>
<p>• HP_Belt_2</p>
<p>• HP_Belt_3</p>
<p>• HP_Belt_4</p>
<p>• HP_Shoulder</p>
<p>• HP_Blade_Lower</p>
<p>• HP_Blade_Upper</p>
</li>
<li><p><strong>In</strong> <strong>gun.model:</strong></p>
<p>• HP_Left_Hand</p>
<p>• HP_Right_Hand</p>
<p>• HP_Belt_2</p>
<p>• HP_Shoulder</p>
</li>
</ul>
<h4 id="10-2-2-How-it-works"><a href="#10-2-2-How-it-works" class="headerlink" title="10.2.2. How it works"></a><strong>10.2.2. How it works</strong></h4><p>(客户端)Entity类提供了硬点列表，但只有专门化类询问时才会这样做。例如，当加载一个模型时，它将找到所有以(例如)为前缀的节点。“HP_”。然后将它们存储在模型拥有的hardPoint列表中。</p>
<p>当装备物品时，实体&#x2F;游戏仲裁者将被要求为物品匹配正确的硬点。例如，如果玩家按下了“下一个武器”按钮，那么库存中的下一个武器就可以附着在右手的硬点上。</p>
<h4 id="10-2-3-Syntax"><a href="#10-2-3-Syntax" class="headerlink" title="10.2.3. Syntax"></a><strong>10.2.3. Syntax</strong></h4><p>使用来自Python的硬点的语法是优雅而强大的。要将模型枪连接到硬点手上的模型头像，请使用以下语法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">avatar.hand = gun</span><br></pre></td></tr></table></figure>

<p>当模型被附加时，要检查它，以确保它没有附加到其他地方。要检索连接到角色手上的模型，只需使用:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model = avatar.hand</span><br></pre></td></tr></table></figure>

<p>如果没有附加模型，则返回None</p>
<p>模型是通过引用附加的，而不是通过复制，因此可以对原始模型引用执行的任何操作都可以对从硬点检索到的引用执行。</p>
<p>例如，gun.Shoot()和avatar.hand.Shoot()具有相同的效果。</p>
<h4 id="10-2-4-Data"><a href="#10-2-4-Data" class="headerlink" title="10.2.4. Data"></a><strong>10.2.4. Data</strong></h4><p>模型定义是一个XML文件，指定:</p>
<ul>
<li><p>基本模型定义引用(可选)</p>
</li>
<li><p>网格的可视化定义</p>
</li>
<li><p>网格可以使用的动画</p>
</li>
<li><p>模型可以执行的操作</p>
</li>
</ul>
<p>模型编辑器(Model Editor)工具用于创建一个.model文件，该文件将对象的几何图形链接到它的动画，并定义了可能在该对象上播放的动画&#x2F;动作集。</p>
<p>与BigWorld框架中的所有资源文件一样，.model文件是XML格式的。它们是分层的，并从它们的父亲继承数据，这样，应用于大量字符的基本动画就可以从更多特定字符的动画中分离出来，而无需重复。</p>
<p>下面的例子定义了一个非常简单的模型:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">jogger.model</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">nodefullVisual</span>&gt;</span> jogger <span class="tag">&lt;/<span class="name">nodefullVisual</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span> biped <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">animation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span> jog <span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">frameRate</span>&gt;</span> 30.0 <span class="tag">&lt;/<span class="name">frameRate</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">nodes</span>&gt;</span> jogAnim <span class="tag">&lt;/<span class="name">nodes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">alpha</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Torso</span>&gt;</span> 0.0 <span class="tag">&lt;/<span class="name">Torso</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Pelvis</span>&gt;</span> 1.0 <span class="tag">&lt;/<span class="name">Pelvis</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">alpha</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">animation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span> BIPED_JOG <span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">animation</span>&gt;</span> jog <span class="tag">&lt;/<span class="name">animation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">blendInTime</span>&gt;</span> 0.300000 <span class="tag">&lt;/<span class="name">blendInTime</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">blendOutTime</span>&gt;</span> 0.300000 <span class="tag">&lt;/<span class="name">blendOutTime</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filler</span>&gt;</span> false <span class="tag">&lt;/<span class="name">filler</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">blended</span>&gt;</span> false <span class="tag">&lt;/<span class="name">blended</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">isMovement</span>&gt;</span> true <span class="tag">&lt;/<span class="name">isMovement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">isCoordinated</span>&gt;</span> false <span class="tag">&lt;/<span class="name">isCoordinated</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">isImpacting</span>&gt;</span> true <span class="tag">&lt;/<span class="name">isImpacting</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">match</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">trigger</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">minEntitySpeed</span>&gt;</span> 1.0 <span class="tag">&lt;/<span class="name">minEntitySpeed</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">maxEntitySpeed</span>&gt;</span> 3.0 <span class="tag">&lt;/<span class="name">maxEntitySpeed</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">capsOn</span>&gt;</span> 16 <span class="tag">&lt;/<span class="name">capsOn</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">trigger</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">match</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jogger.model</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个文件描述了一个角色(慢跑者)，它具有由视觉文件慢跑者定义的几何形状，并通过&lt;parent&gt;标记拥有一组标准的两足动作，其中可能包括行走、奔跑和跳跃动画，但也指定慢跑动画。</p>
<p>动画部分包括:</p>
<ul>
<li><p>动画名称</p>
</li>
<li><p>动画正常播放时的帧率.</p>
</li>
<li><p>标记&lt;nodes&gt;，它引用包含原始关键帧数据的动画文件的名称.</p>
</li>
</ul>
<p>&lt;action&gt;部分描述了用于从Python代码中播放此操作的操作名称。</p>
<h3 id="10-3-SuperModel"><a href="#10-3-SuperModel" class="headerlink" title="10.3. SuperModel"></a><strong>10.3. SuperModel</strong></h3><p>SuperModel是需要作为一个功能的模型的集合。SuperModel类是一个实用程序类，它为希望使用模型的模块形成了一个灵活的基础。它用于在块中指定的静态模型，以及实体可以操作的动态模型。</p>
<p>SuperModel提供了概念模型的有效表示(在内存和CPU中)。超模由可选择的部分组成，这些部分有一个继承树，用于指定动画、动作、材质覆盖，最重要的是，较低层次的细节(LOD)部分可以在适当的距离替换。</p>
<p>SuperModel将所有这些部件和它们的装饰组合到一个概念模型中，自动处理多部件和LODing特性产生的复杂性。</p>
<p>最基本的SuperModel的一个例子是一个单一的网格，它是使用BigWorld导出器从3ds Max导出的;变成3D引擎Moo理解的格式。</p>
<p>SuperModels并不存在于场景图或块中，也不提供给脚本系统接口。这些问题留给更高级的类去解决，他们被鼓励使用SuperModel来满足他们所有的模特需求。</p>
<h4 id="10-3-1-Design"><a href="#10-3-1-Design" class="headerlink" title="10.3.1. Design"></a><strong>10.3.1. Design</strong></h4><p>有模型文件，扩展名为.model，但没有显式的SuperModel文件。</p>
<p>有一个SuperModel类，它连接在一起并控制许多模型的动画和渲染。SuperModel是基于块和模型文件中的信息创建的(这些是类实例——没有任何东西可以与PyModelInfo类似)。</p>
<p>使用LOD比率，SuperModel类可以管理角色之间的转换，例如，使用三个独立的模型在高LOD渲染的化身，到仅使用一个模型在低LOD渲染之间的转换。</p>
<p>动画将在同一继承层次结构上累积，并使用最适合当前LOD级别的动画。所有LOD级别的所有动画都是从一个平面名称空间中解释和选择的。尝试播放不存在(或在当前LOD级别上不存在)的动画时，会选择模型初始姿态的无限长动画。必须注意确保多模型SuperModels不会浪费时间制作不必要的动画（例如，当所有的小部分都有一个动画覆盖了整个部分的动画时，应用整个部分的动画将是浪费时间）。</p>
<p>网格文件本身指定了一个部件如何连接到多部件supermodels的其他部件。</p>
<h4 id="10-3-2-SuperModel-classes"><a href="#10-3-2-SuperModel-classes" class="headerlink" title="10.3.2. SuperModel classes"></a><strong>10.3.2. SuperModel classes</strong></h4><p>SuperModel类使用Moo提供的对象实现了BigWorld模型定义的基本功能。它将许多由模型编辑器(但通常只有一个)创建的. Model文件组合成一个概念模型，管理任何动画和细节级别链。</p>
<p>目前有两个类在BigWorld客户端中为两个不同的对象使用SuperModels:</p>
<ul>
<li>ChunkModel</li>
<li>PyModel</li>
</ul>
<p>下面的小节将对两者进行描述。</p>
<h5 id="10-3-2-1-ChunkModel"><a href="#10-3-2-1-ChunkModel" class="headerlink" title="10.3.2.1. ChunkModel"></a><strong>10.3.2.1. ChunkModel</strong></h5><p>ChunkModel是一个位于静态场景基础上的模型(例如，岩石，树木)。它与地形一起构成了客户端的世界，形成了大部分有趣的风景。</p>
<p>所有ChunkModels都会被添加到碰撞场景中，除非被标记。他们可以选择播放一个动画，在指定的速度倍增器-否则他们是静态的。</p>
<p>它们严重依赖SuperModel的服务，只提供在区块中生存所需的接口，以及播放单一动画的简单指令。</p>
<h5 id="10-3-2-2-PyModel"><a href="#10-3-2-2-PyModel" class="headerlink" title="10.3.2.2. PyModel"></a><strong>10.3.2.2. PyModel</strong></h5><p>这个类实现了在脚本环境中显示的模型。</p>
<p>它允许脚本执行以下操作:</p>
<ul>
<li>获取来自模型定义的绑定操作。</li>
<li>参考硬点（详见Hard Point）。</li>
<li>指定位置、旋转和缩放。</li>
<li>添加电机在场景中移动（如动作匹配器）。</li>
<li>添加了用于反向运动学的跟踪器。</li>
<li>添加绑定到任何节点的粒子系统。</li>
<li>控制脚步和灰尘颗粒的产生。</li>
<li>控制能见度和阴影。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/06/bigworld_04/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Avatar.png">
      <meta itemprop="name" content="华">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keep Running">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Keep Running">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/11/06/bigworld_04/" class="post-title-link" itemprop="url">BIGWORLD 服务端概述</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-11-06 11:20:31" itemprop="dateCreated datePublished" datetime="2024-11-06T11:20:31+08:00">2024-11-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-11-07 09:20:50" itemprop="dateModified" datetime="2022-11-07T09:20:50+08:00">2022-11-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/BigWorld/" itemprop="url" rel="index"><span itemprop="name">BigWorld</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="BIGWORLD-04-Server-Overview"><a href="#BIGWORLD-04-Server-Overview" class="headerlink" title="BIGWORLD_04_Server Overview"></a>BIGWORLD_04_Server Overview</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a><strong>1. 概述</strong></h2><p>BigWorld Technology是BigWorld实现大型多人在线游戏的中间件。本文概述了BigWorld技术的当前实现。</p>
<h2 id="2-Rules-of-Thumb（经验法则）"><a href="#2-Rules-of-Thumb（经验法则）" class="headerlink" title="2. Rules of Thumb（经验法则）"></a><strong>2. Rules of Thumb（经验法则）</strong></h2><p>这是设计中使用的规则&#x2F;理念&#x2F;哲学的列表。</p>
<ul>
<li>可延展性，可靠性，效率高</li>
<li>简单化</li>
<li>改善最坏的体验</li>
<li>合理分配利用客户端&#x2F;服务端带宽</li>
<li>保持信息，避免双向调用</li>
<li>避免瓶颈;使系统分布式</li>
<li>在可行的情况下，分批发送消息</li>
</ul>
<h2 id="3-Concepts（概念）"><a href="#3-Concepts（概念）" class="headerlink" title="3. Concepts（概念）"></a><strong>3. Concepts（概念）</strong></h2><p>本节解释与设计相关的一般概念和问题</p>
<h3 id="Location-of-an-Object’s-Data"><a href="#Location-of-an-Object’s-Data" class="headerlink" title="Location of an Object’s Data"></a><strong>Location of an Object’s Data</strong></h3><p>对象数据的位置，一个对象的活动数据有四个主要位置:</p>
<ol>
<li>与实体的单元部分相关联。</li>
<li>与实体的基本部分关联。</li>
<li>在持久世界数据库中。</li>
<li>客户端<br>与单元上的实体相关联的数据可以分为:</li>
</ol>
<ul>
<li>内部数据,  仅在其所在的cell中使用和储存。</li>
<li>服务器（或者 ghosted）数据， 对服务器上的其他实体可用。</li>
<li>客户端数据，对(至少部分)客户机可用。</li>
</ul>
<h3 id="3-1-Actions"><a href="#3-1-Actions" class="headerlink" title="3.1 Actions"></a><strong>3.1 Actions</strong></h3><p>从客户端的角度来看，在概念上有四种类型的行为:</p>
<h4 id="1-Server-action"><a href="#1-Server-action" class="headerlink" title="1. Server action"></a><strong>1. Server action</strong></h4><p>这是一个来自服务器的未经请求的操作，不是由此客户机生成的。</p>
<p>例如，另一个角色跳跃。</p>
<h4 id="2-Local-action"><a href="#2-Local-action" class="headerlink" title="2. Local action"></a><strong>2. Local action</strong></h4><p>这是一个只在客户端本地发生的操作，不需要与服务器或其他客户端通信。</p>
<p>例如，粒子弹跳或火焰轻微燃烧的特效。</p>
<h4 id="3-Undoable-action"><a href="#3-Undoable-action" class="headerlink" title="3. Undoable action"></a><strong>3. Undoable action</strong></h4><p>这是客户端在假定正确的情况下立即采取的操作，然后与服务器通信。服务器可以禁止该操作，并让客户机回滚该操作。</p>
<p>例如，向前迈进的客户端。</p>
<h4 id="4-Server-confirmed-action"><a href="#4-Server-confirmed-action" class="headerlink" title="4. Server-confirmed action"></a><strong>4. Server-confirmed action</strong></h4><p>这是一个需要从服务器接收确认的操作，然后在客户端上执行。</p>
<p>例如，玩家想要与另一个玩家握手。另一个例子可能是击中一个玩家(并认为他已经死了)，但直到服务器确认后才显示出来(这与服务器动作有一些相似之处，只是动作的来源是这个客户端)。</p>
<h3 id="3-3-Latency"><a href="#3-3-Latency" class="headerlink" title="3.3 Latency"></a><strong>3.3 Latency</strong></h3><p>延迟，游戏设计师需要使用尽可能多的延迟隐藏技巧来隐藏玩家的延迟。延迟有两个主要来源:</p>
<h4 id="1-网络延迟"><a href="#1-网络延迟" class="headerlink" title="1. 网络延迟"></a><strong>1. 网络延迟</strong></h4><p>所有在客户端之间传输的信息都要通过服务器，因此必须在Internet上进行两次传输。</p>
<h4 id="2-服务器延迟"><a href="#2-服务器延迟" class="headerlink" title="2. 服务器延迟"></a><strong>2. 服务器延迟</strong></h4><p>这是服务器接收到信息、对其进行处理以及响应回客户机之间的时间间隔。在拥有大量玩家的MMOG环境中，带宽是一种宝贵的资源，所以并不是所有的新信息都能立即发送出去。在BigWorld中，优先队列管理这个。</p>
<p>可以对优先队列进行调优，以减少服务器对关键信息造成的延迟。不过，这不会影响互联网延迟。</p>
<h3 id="3-4-Spaces-and-Cells"><a href="#3-4-Spaces-and-Cells" class="headerlink" title="3.4 Spaces and Cells"></a><strong>3.4 Spaces and Cells</strong></h3><p>游戏世界是由多个空间组成的。每个空间都是一个连续的欧几里得区域，由一个单一的坐标系横跨。</p>
<p>cell存在于更物理的层面。它们以几何形式划分大型游戏空间，以便在多个cellapp之间实现负载平衡。</p>
<p>对于很小的空间，一个单元格就足以覆盖。</p>
<h3 id="3-5-Coordinate-System"><a href="#3-5-Coordinate-System" class="headerlink" title="3.5 Coordinate System"></a><strong>3.5 Coordinate System</strong></h3><p>坐标系系统。BigWorld使用左手坐标系。x轴指向“左”，y轴指向“上”，z轴指向“前”。</p>
<ul>
<li>yaw,绕y轴的旋转。正的是右边，负的是左边.</li>
<li>pitch，绕x轴的旋转。正的是向下，负的是向上.</li>
<li>roll 绕z轴的旋转。正的是左边，负的是右边.</li>
</ul>
<h2 id="4-Design-Introduction"><a href="#4-Design-Introduction" class="headerlink" title="4. Design Introduction"></a><strong>4. Design Introduction</strong></h2><p>本节讨论BigWorld Server环境的设计，简要概述其组件和一系列用例。</p>
<h3 id="4-1-Hardware-Components"><a href="#4-1-Hardware-Components" class="headerlink" title="4.1 Hardware Components"></a><strong>4.1 Hardware Components</strong></h3><p>硬件部分：</p>
<p>BaseApps和LoginApps是唯一需要连接到互联网的服务器组件。</p>
<p>下图显示了服务器硬件的不同组件之间的连接。</p>
<p><img src="/image/bigworld/04_01.png" alt="图片"></p>
<h3 id="4-2-Software-Components"><a href="#4-2-Software-Components" class="headerlink" title="4.2 Software Components"></a><strong>4.2 Software Components</strong></h3><p>软件部分，服务器的主要软件组件有:</p>
<ul>
<li><strong>CellApp</strong></li>
<li><strong>CellAppMgr</strong></li>
<li><strong>BaseApp</strong></li>
<li><strong>BaseAppMgr</strong></li>
<li><strong>ServiceApp</strong></li>
<li><strong>LoginApp</strong></li>
<li><strong>DBMgr</strong></li>
<li><strong>Reviver</strong></li>
</ul>
<p>还有一个名为BWMachined的特殊程序进程，它运行在每台机器上。</p>
<p>在生产环境中，每个CellApp运行在自己的CPU上，每个BaseApp和ServiceApp也是如此。<br>所有其他进程(除了BWMachined)可以根据系统负载在一个或多个服务器上以不同的组合运行。</p>
<p>只要求BaseApps和LoginApps连接到互联网。</p>
<p>ServiceApps和Revivers是可选的。所有其他过程都是必需的。</p>
<p>下图展示了多个软件组件之间的通信路径:</p>
<p><img src="/image/bigworld/04_02.png" alt="图片"></p>
<h4 id="4-2-1-CellApp"><a href="#4-2-1-CellApp" class="headerlink" title="4.2.1 CellApp"></a><strong>4.2.1 CellApp</strong></h4><p>每个CellApp负责运行在其上的所有cell。</p>
<p>CellApps可能是架构中最重要的部分。每个cell负责一个大空间的一部分或整个空间。在游戏世界中，单元格并不重叠，它们共同覆盖所有游戏空间。</p>
<p>每个cell负责维护位于其边界内的实体。一个细胞也可以维护在该实体附近的ghosts(副本)，但在自己的边界之外。</p>
<h4 id="4-2-2-CellAppMgr"><a href="#4-2-2-CellAppMgr" class="headerlink" title="4.2.2 CellAppMgr"></a><strong>4.2.2 CellAppMgr</strong></h4><p>CellAppMgr的主要职责是指导cell和Cellapp。</p>
<p>它协调哪些cell运行在哪些CellApps上，并通过改变cell的大小来平衡每个cell上的负载。</p>
<h4 id="4-2-3-BaseApp"><a href="#4-2-3-BaseApp" class="headerlink" title="4.2.3 BaseApp"></a><strong>4.2.3 BaseApp</strong></h4><p>在某些方面，BaseApps可以被视为服务器的防火墙。</p>
<p>对于客户端来说，它们的主要目的是将其与CellApps之间的实体转换隔离开来。</p>
<p>每个BaseApp都包含许多base。</p>
<p>连接的客户机由称为代理的增强基础服务。每个代理最多负责一个客户端。每个客户机与一个代理通信。此代理负责将消息从客户机重定向到正确的cell。</p>
<p>一般来说，BaseApp维护base。基表示不需要在世界上有位置的对象或函数。例如，用于群聊的对象是一个没有相应单元实体的base。</p>
<h4 id="4-2-4-BaseAppMgr"><a href="#4-2-4-BaseAppMgr" class="headerlink" title="4.2.4 BaseAppMgr"></a><strong>4.2.4 BaseAppMgr</strong></h4><p>游戏世界有一个单独的BaseAppMgr在运行，它负责管理BaseApps和ServiceApps。</p>
<p>它的主要工作是将新的客户端连接分配给最合适的BaseApp，并跟踪它们。</p>
<h4 id="4-2-5-ServiceApp"><a href="#4-2-5-ServiceApp" class="headerlink" title="4.2.5 ServiceApp"></a><strong>4.2.5 ServiceApp</strong></h4><p>ServiceApps是支持运行服务的进程。</p>
<p>一个Service可以被认为是一个Base-only实体，除了它不是代表一个对象，它提供了一个游戏服务器和一些外部服务之间的接口。</p>
<p>一个ServiceApp是一个专门的BaseApp，它包含Service片段，而不是Base实体。一个Service可以在多个ServiceApps上有多个片段，允许该服务的功能在多台机器上可用。</p>
<p>ServiceApp可执行文件实际上是一个到BaseApp二进制文件的符号链接。它会导致BaseApp以不同的模式运行。默认情况下，基本实体不会在ServiceApps上创建。与BaseApps不同,ServiceApps不需要直接连接到互联网。</p>
<h4 id="4-2-6-LoginApp"><a href="#4-2-6-LoginApp" class="headerlink" title="4.2.6 LoginApp"></a><strong>4.2.6 LoginApp</strong></h4><p>客户端与该组件通信以发起与服务器的会话。LoginApp然后添加player作为BaseApp的代理，BaseApp可以继续在CellApp上创建一个实体。</p>
<p>此组件的多个实例可以同时运行。</p>
<h4 id="4-2-7-DBMgr"><a href="#4-2-7-DBMgr" class="headerlink" title="4.2.7 DBMgr"></a><strong>4.2.7 DBMgr</strong></h4><p>DBMgr是数据库的接口，其中存储了世界的持久状态。</p>
<p>当玩家登录时，登录过程从数据库请求该玩家实体的全部属性集。这个数据用于在BaseApp上实例化这个玩家的代理。</p>
<p>当玩家登出时，BaseApp向数据库发送一个登出消息。这条消息包含玩家实体的属性，可能已经被base(或cell)实体修改。</p>
<h4 id="4-2-8-Reviver"><a href="#4-2-8-Reviver" class="headerlink" title="4.2.8 Reviver"></a><strong>4.2.8 Reviver</strong></h4><p>Reviver是一个监视进程，用于重新启动其他失败的进程，这些失败的进程可能是因为它们运行的机器发生了故障，也可能是因为进程本身崩溃或无响应。</p>
<h4 id="4-2-9-BWMachimed"><a href="#4-2-9-BWMachimed" class="headerlink" title="4.2.9 BWMachimed"></a><strong>4.2.9 BWMachimed</strong></h4><p>BWMachined是一个运行在服务器集群中的每台机器上的守护进程。它可以用于远程启动、停止和定位服务器组件。它还监视CPU、内存和网络使用情况，并向网络用户提供这些信息。</p>
<p>这是服务器组件在启动期间通过广播消息相互定位的方式。</p>
<h3 id="4-3-Use-Cases"><a href="#4-3-Use-Cases" class="headerlink" title="4.3 Use Cases"></a><strong>4.3 Use Cases</strong></h3><p>本节描述服务器的一些功能是如何工作的。本文的目的是对服务器中的组件以及它们之间的相互关系提供一个介绍性的视图。</p>
<h4 id="4-3-1-Server-Startup"><a href="#4-3-1-Server-Startup" class="headerlink" title="4.3.1 Server Startup"></a><strong>4.3.1 Server Startup</strong></h4><p>关于启动的重要问题是进程之间的依赖关系，以及不同进程如何找到彼此。</p>
<p>当一个进程启动时，它将自己注册到本地机器上运行的守护进程。注册包含接口名称。</p>
<p>例如，CellApp需要知道CellAppMgr的位置，以便它可以注册到CellAppMgr。所以,当CellApp启动时，它通过在BWMachined的端口上发送广播消息来询问CellAppMgr的位置，所有BWMachined进程都监听该消息。如果一个BWMachined有一个CellAppMgr(与正确的用户关联)，它将发送CellAppMgr的联系详细信息作为响应。</p>
<h4 id="4-3-2-Logging-In"><a href="#4-3-2-Logging-In" class="headerlink" title="4.3.2 Logging In"></a><strong>4.3.2 Logging In</strong></h4><p>当客户端启动时，它会与LoginApp通信。</p>
<p>登录流程如下:</p>
<ol>
<li>客户端发送一个登录请求(需要知道LoginApp的IP地址)。</li>
<li>当监听它的固定(用户指定)端口时，LoginApp接收请求。</li>
<li>LoginApp将请求转发给DBMgr，这样它就可以检查登录详细信息是否有效。</li>
<li>DBMgr查询数据库关于登录的详细信息。</li>
<li>如果详细信息有效，DBMgr指示BaseAppMgr创建一个新的实体。</li>
<li>BaseAppMgr将实体创建请求转发给负载最少的BaseApp。</li>
<li>BaseApp创建了一个新的代理，它是一个派生自Base类的对象。</li>
<li>新创建的代理现在可以在CellApp上创建单元格实体(例如，这一步可能会被代理延迟，直到客户端选择一个字符)。当创建单元实体时，代理可以通过CellAppMgr或直接向CellApp发送消息。</li>
<li>代理的UDP端口返回给客户端(通过BaseAppMgr, DBMgr，然后LoginApp)。<br>具体流程：<br><img src="/image/bigworld/04_03.png" alt="图片"></li>
</ol>
<h4 id="4-3-3-Data-From-Clients"><a href="#4-3-3-Data-From-Clients" class="headerlink" title="4.3.3. Data From Clients"></a><strong>4.3.3. Data From Clients</strong></h4><p>从客户机到服务器的所有通信都发送到登录期间发送给它的客户机代理的地址。</p>
<p>该通信在UDP之上使用Mercury (BigWorld通信机制)。一旦proxy接收到数据包，它就会将消息(如果不是全部，也是大部分)转发给相应的CellApp。然后，这将更新适当实体的数据。如果实体有任何ghosts，这些也会被更新。</p>
<h4 id="4-3-4-Data-To-Clients"><a href="#4-3-4-Data-To-Clients" class="headerlink" title="4.3.4. Data To Clients"></a><strong>4.3.4. Data To Clients</strong></h4><p>客户端的单元实体以10赫兹(可配置)的频率周期性地构造一个包，其中充满了关于客户端的AOI中实体的消息。然后这个包通过代理发送到客户端。</p>
<h4 id="4-3-5-Ghosting"><a href="#4-3-5-Ghosting" class="headerlink" title="4.3.5. Ghosting"></a><strong>4.3.5. Ghosting</strong></h4><p>每个客户端的实体在其AoI中保持一个其他实体的优先队列。一个问题是，并非所有这些实体都可能在同一个单元上。解决这个问题的方法就是“ghosting”。</p>
<p>ghost是相邻单元的实体的副本。当其他实体通过它们的优先队列构造它们的更新包时，ghost拷贝包含可能需要的所有数据。如果存在一个实体位于另一个实体的AoI中的可能性，那么它必须在那个cell中有ghost。为了实现这一点，如果一个实体在cell格边界的AoI距离(或虚距离)内，BigWorld会在该cell格上创建实体的ghost。</p>
<p>当一个真正的实体(即主实体，非ghost实体)被更新时，它也会更新它的ghost。</p>
<h4 id="4-3-6-Changing-Cells"><a href="#4-3-6-Changing-Cells" class="headerlink" title="4.3.6. Changing Cells"></a><strong>4.3.6. Changing Cells</strong></h4><p>当实体移动时，它可能会离开当前所在单元格的边界。当发生这种情况时，实体被移动到相关的新单元格。然后它通知基地它的新地址，以便基地在未来可以找到它(在代理的情况下，以便代理可以继续正确地转发消息)。</p>
<h4 id="4-3-7-Load-Balancing"><a href="#4-3-7-Load-Balancing" class="headerlink" title="4.3.7. Load Balancing"></a><strong>4.3.7. Load Balancing</strong></h4><p>和其他机器一样，CellApp的机器能够处理的负载也有限制。为了避免一些CellApps超载，有一种机制来平衡负载。一般来说，如果单元格超载，它就会减小其大小，从而卸载一些实体。如果它的负载充足，它就会增加它的大小以控制更多的实体。</p>
<h2 id="5-Server-Conponents"><a href="#5-Server-Conponents" class="headerlink" title="5. Server Conponents"></a><strong>5. Server Conponents</strong></h2><p>本节描述BigWorld Technology服务器端的各种组件，以及它们如何协同工作以支持游戏环境。</p>
<h2 id="5-1-CellApp"><a href="#5-1-CellApp" class="headerlink" title="5.1 CellApp"></a><strong>5.1 CellApp</strong></h2><h3 id="5-1-1-Cell-Application-and-Cells"><a href="#5-1-1-Cell-Application-and-Cells" class="headerlink" title="5.1.1 Cell Application and Cells"></a><strong>5.1.1 Cell Application and Cells</strong></h3><p>Cell Application (CellApp)是运行在CellApp机器上的实际进程或可执行文件。</p>
<p>BigWorld将大空间划分为多个cell，以便平均分担负载。它通常会为每个CellApp分配一个大的cell。在处理较小的空间时，比如动态创建的任务空间，BigWorld通常会为每个CellApp分配几个cell。</p>
<p>在BigWorld中，CellApp机器只运行BWMachined和每个CPU一个CellApp，其他什么都不运行。</p>
<h3 id="5-1-2-Entities"><a href="#5-1-2-Entities" class="headerlink" title="5.1.2 Entities"></a><strong>5.1.2 Entities</strong></h3><p>每个实体都了解与其类型相关联的消息。CellApp将实体消息传递给适当的实体，并由它来解释它们。实现方法是让每个实体包含一个指向实体类型对象的指针。该对象具有与实体类型相关的信息，例如该类型可以处理的消息以及与之关联的脚本。</p>
<p>每种实体类型都有自己的脚本文件。脚本在特定实体的上下文中执行(例如：this或self)，并且能够访问其他实体选择提供的数据(服务器和客户端数据)，以及每个实体的基本成员(id、位置等等)。</p>
<p>当任何服务器或客户端数据发生更改时，更改将自动转发到相关实体。</p>
<h3 id="5-1-3-Real-and-Ghost-Entities"><a href="#5-1-3-Real-and-Ghost-Entities" class="headerlink" title="5.1.3 Real and Ghost Entities"></a><strong>5.1.3 Real and Ghost Entities</strong></h3><p>为了有效地更新它的客户端，每个角色在它的AoI中保持一个实体列表，这通常是一个围绕着玩家500米的轴对齐的正方形。由此产生的一个问题是，并非所有实体都可以由同一个cell控制。</p>
<p>一般让cell管理ghost实体。如果一个实体在cell格边界的ghost距离内，cell就会在附近的cell上创建一个实体的虚影。</p>
<p>引入实体这个术语来区分主表示和(导入的)ghosts。下图显示了cell1维护的所有实体<br><img src="/image/bigworld/04_04.png" alt="图片"></p>
<p>每隔一秒，一个cell就会检查它的真实实体，检查它是否应该在邻近单元格上为它们添加或删除ghost。它向邻居发送消息来添加和删除ghost。<br><img src="/image/bigworld/04_05.png" alt="图片"></p>
<h3 id="5-1-4-Transitioning-Between-Spaces"><a href="#5-1-4-Transitioning-Between-Spaces" class="headerlink" title="5.1.4. Transitioning Between Spaces"></a><strong>5.1.4. Transitioning Between Spaces</strong></h3><p>在不同空间之间进行转换的最简单方法就是“pop”，即从旧空间中移除实体并在新空间中重新创建它。</p>
<p>一个稍微复杂一些的技术是有一个封闭的过渡区域，如电梯，这是精确地复制在两个空间。当玩家进入过渡区域时，它便会变得封闭起来，开发者便能够将玩家从旧空间中“弹出”到新空间中区域的副本中。</p>
<h3 id="5-1-5-Witness-Priority-List"><a href="#5-1-5-Witness-Priority-List" class="headerlink" title="5.1.5. Witness Priority List"></a><strong>5.1.5. Witness Priority List</strong></h3><p>每当一个实体有一个客户端连接到它时，一个称为witness的子对象就会与该实体相关联，以便在其AoI中维护实体列表。</p>
<p>witness构建更新包发送给它的客户端，它必须优先发送最重要的信息。客户端要求最接近它的其他实体的位置和其他信息是最准确和最新的。</p>
<h4 id="5-1-5-1-Event-History"><a href="#5-1-5-1-Event-History" class="headerlink" title="5.1.5.1. Event History"></a><strong>5.1.5.1. Event History</strong></h4><p>每个实体都保存其最近事件的历史。历史既包括改变其状态的事件(如武器的改变)，也包括不改变状态的动作(如跳跃和射击)。历史列表中不保留影响易变数据的频繁操作(如移动)。</p>
<p>这些类型的事件的历史相当短(大约60秒)，因为我们预计在最坏的情况下，优先队列中的每个实体将(大约)每30秒被考虑一次。</p>
<h4 id="5-1-5-2-Level-of-Detail"><a href="#5-1-5-2-Level-of-Detail" class="headerlink" title="5.1.5.2 Level of Detail"></a><strong>5.1.5.2 Level of Detail</strong></h4><p>当一个实体的AoI中有许多实体时，关于每个实体的信息发送的频率会降低，但事件的总数保持不变。</p>
<p>为了解决这个问题，BigWorld使用详细级别(LOD)系统来处理基于事件的更改。它的原则是，一个实体离角色越近，它就应该向它的客户端发送越多的细节。例如，当玩家最初进入角色的AoI时，角色不需要知道其他玩家的所有细节。可见的细节可能只在100米以内才需要。更精致的细节，比如衣服上的徽章，可能只需要在20米以内。</p>
<h4 id="•-Non-state-changing-events"><a href="#•-Non-state-changing-events" class="headerlink" title="• Non-state-changing events"></a>• <strong>Non-state-changing events</strong></h4><p>在每个实体类型的描述中，都有它可以生成的所有消息(非状态改变事件)的描述，以及与每个消息相关联的优先级。<br>当角色添加关于实体的信息时，它只添加优先级大于角色当前对该实体的兴趣的消息。因此，根据化身和实体之间的距离，消息将被忽略。</p>
<p>例如，可能有一种聊天只能在50米内听到，或者有一种跳跃只能在100米内看到。</p>
<h4 id="•-State-changing-events"><a href="#•-State-changing-events" class="headerlink" title="• State-changing events"></a>• <strong>State-changing events</strong></h4><p>BigWorld不能忽略发生在范围之外的状态更改事件，因为如果实体随后足够接近，客户端将拥有一个错误的实体状态副本。</p>
<p>例如，客户端可能对一个实体携带的武器类型感兴趣，但只有当它在100米以内时才会感兴趣。如果实体在这个范围之外改变了它的武器，那么这个信息还没有发送给客户端。BigWorld只会在实体进入范围时发送它。</p>
<p>当一个具有关联见证的实体出现在另一个实体的LOD环内时，与该环相关联的任何状态(自上次如此接近以来发生了变化)都会被发送给客户端。BigWorld使用时间戳来实现这一点。时间戳与每个实体的每个属性一起存储。此时间戳表示该属性最后一次更改的时间。</p>
<h3 id="5-1-6-Scripting-and-Entities"><a href="#5-1-6-Scripting-and-Entities" class="headerlink" title="5.1.6. Scripting and Entities"></a><strong>5.1.6. Scripting and Entities</strong></h3><p>下面的小节描述了如何为实体使用脚本</p>
<h4 id="5-1-6-1-Entity-Classes"><a href="#5-1-6-1-Entity-Classes" class="headerlink" title="5.1.6.1 Entity Classes"></a><strong>5.1.6.1 Entity Classes</strong></h4><p>实体类描述了一种实体类型。下面的列表描述了它的组成部分:</p>
<h5 id="•-An-XML-definition-file-定义文件"><a href="#•-An-XML-definition-file-定义文件" class="headerlink" title="• An XML definition file(定义文件)"></a><strong>• An XML definition file(定义文件)</strong></h5><p>&lt;res&gt;&#x2F;scripts&#x2F;entity_defs&#x2F;&lt;entity&gt;.def</p>
<h5 id="•-A-Python-cell-script（cell脚本）"><a href="#•-A-Python-cell-script（cell脚本）" class="headerlink" title="• A Python cell script（cell脚本）"></a><strong>• A Python cell script（cell脚本）</strong></h5><p>&lt;res&gt;&#x2F;scripts&#x2F;cell&#x2F;&lt;entity&gt;.py</p>
<h5 id="•-A-Python-base-script（base脚本）"><a href="#•-A-Python-base-script（base脚本）" class="headerlink" title="• A Python base script（base脚本）"></a><strong>• A Python base script（base脚本）</strong></h5><p>&lt;res&gt;&#x2F;scripts&#x2F;base&#x2F;&lt;entity&gt;.py</p>
<h5 id="•-A-Python-client-script（客户端脚本）"><a href="#•-A-Python-client-script（客户端脚本）" class="headerlink" title="• A Python client script（客户端脚本）"></a><strong>• A Python client script（客户端脚本）</strong></h5><p><res>&#x2F;scripts&#x2F;client&#x2F;&lt;entity&gt;.py<br>XML定义文件可以被视为Cell、Base和Client脚本之间的接口。它定义了所有可用的公共方法和实体的所有属性。此外，它还定义了类的全局特征，例如:</p>
<ul>
<li>实体是否需要不稳定的位置更新。</li>
<li>实体如何在客户端实例化。</li>
<li>该实体的基类。</li>
<li>实体实现的接口，如果有的话。</li>
</ul>
<h4 id="5-1-6-2-Example-Entity-Definition-File"><a href="#5-1-6-2-Example-Entity-Definition-File" class="headerlink" title="5.1.6.2. Example Entity Definition File"></a><strong>5.1.6.2. Example Entity Definition File</strong></h4><pre><code>示例参考：实体定义文件&lt;res&gt;/scripts/entity_defs/Seat.def
</code></pre>
<h4 id="5-1-6-3-Properties"><a href="#5-1-6-3-Properties" class="headerlink" title="5.1.6.3. Properties"></a><strong>5.1.6.3. Properties</strong></h4><pre><code>需要定义所有单元实体属性，即使它们是类的私有属性。这是因为CellApps需要将实体卸载给其他CellApps，并且定义所有属性的数据类型允许数据尽可能有效地传输。

在XML定义中使用以下标志来确定应该如何复制每个属性:
</code></pre>
<h5 id="•-ALL-CLIENTS"><a href="#•-ALL-CLIENTS" class="headerlink" title="• ALL_CLIENTS"></a><strong>• ALL_CLIENTS</strong></h5><pre><code>表示CELL_PUBLIC标志
只与有关联客户端的实体相关，例如玩家实体
对附近的所有客户(包括所有者)可见的属性。对应于设置
OWN_CLIENT和OTHER_CLIENT标志。
</code></pre>
<h5 id="•-BASE"><a href="#•-BASE" class="headerlink" title="• BASE"></a><strong>• BASE</strong></h5><pre><code>在Base上使用的属性
</code></pre>
<h5 id="•-BASE-AND-CLIENT"><a href="#•-BASE-AND-CLIENT" class="headerlink" title="• BASE_AND_CLIENT"></a><strong>• BASE_AND_CLIENT</strong></h5><pre><code>在Base和clients上都使用的属性。客户机在登录时接收该属性
</code></pre>
<h5 id="•-CELL-PRIVATE"><a href="#•-CELL-PRIVATE" class="headerlink" title="• CELL_PRIVATE"></a><strong>• CELL_PRIVATE</strong></h5><pre><code>包含实体内部状态信息的属性。它们对所有者是可用的，而且只在cell上可用。它们不会被ghost，因此，其他cell上的实体将无法看到它们。
</code></pre>
<h5 id="•-CELL-PUBLIC"><a href="#•-CELL-PUBLIC" class="headerlink" title="• CELL_PUBLIC"></a><strong>• CELL_PUBLIC</strong></h5><pre><code>对服务器上的其他实体可见的属性。它们将被“ghost”，而附近的任何其他实体将能够读取它们，无论它们是否在同一个cell中(只要它们在AoI距离内)。
</code></pre>
<h5 id="•-CELL-PUBLIC-AND-OWN"><a href="#•-CELL-PUBLIC-AND-OWN" class="headerlink" title="• CELL_PUBLIC_AND_OWN"></a><strong>• CELL_PUBLIC_AND_OWN</strong></h5><pre><code>cell上的其他实体以及cell和client上的这个实体可用的属性。
</code></pre>
<h5 id="•-OTHER-CLIENTS"><a href="#•-OTHER-CLIENTS" class="headerlink" title="• OTHER_CLIENTS"></a><strong>• OTHER_CLIENTS</strong></h5><pre><code>表示CELL_PUBLIC标志。

对附近的客户端可见，但对所有者不可见的属性。
</code></pre>
<h5 id="•-OWN-CLIENT"><a href="#•-OWN-CLIENT" class="headerlink" title="• OWN_CLIENT"></a><strong>• OWN_CLIENT</strong></h5><pre><code>只与有关联客户端的实体相关，例如玩家实体。

仅对拥有该实体的客户端可见的属性。
</code></pre>
<p>当属性发生变化时，服务器使用标志OWN_CLIENT和ALL_CLIENTS来确定是否应该将更新发送到实体自己的客户端，并使用标志OTHER_CLIENTS和ALL_CLIENTS来确定是否应该将更新发送到其他客户端。</p>
<h4 id="5-1-6-4-Built-in-Properties"><a href="#5-1-6-4-Built-in-Properties" class="headerlink" title="5.1.6.4 Built-in Properties"></a><strong>5.1.6.4 Built-in Properties</strong></h4><p>除了XML文件中定义的属性之外，单元实体脚本还可以访问单元脚本环境提供的几个内置属性。这些包括:</p>
<h5 id="•-id-Read-only"><a href="#•-id-Read-only" class="headerlink" title="• id (Read-only)"></a><strong>• id (Read-only)</strong></h5><p>整数实体ID。</p>
<h5 id="•-spaceID-Read-only"><a href="#•-spaceID-Read-only" class="headerlink" title="• spaceID (Read-only)"></a><strong>• spaceID (Read-only)</strong></h5><p>实体所在空间ID。</p>
<h5 id="•-vehicle-Read-only"><a href="#•-vehicle-Read-only" class="headerlink" title="• vehicle (Read-only)"></a><strong>• vehicle (Read-only)</strong></h5><p>该实体所依赖的其他实体(或None)。</p>
<h5 id="•-position-Read-x2F-write"><a href="#•-position-Read-x2F-write" class="headerlink" title="• position (Read&#x2F;write)"></a><strong>• position (Read&#x2F;write)</strong></h5><p>实体的位置，作为3个浮点数的元组。</p>
<h5 id="•-direction-Read-x2F-write"><a href="#•-direction-Read-x2F-write" class="headerlink" title="• direction (Read&#x2F;write)"></a><strong>• direction (Read&#x2F;write)</strong></h5><p>实体的方向，作为x、y和z的元组</p>
<h5 id="•-isOnGround-Read-x2F-write"><a href="#•-isOnGround-Read-x2F-write" class="headerlink" title="• isOnGround (Read&#x2F;write)"></a><strong>• isOnGround (Read&#x2F;write)</strong></h5><p>整型标志，如果实体在地上，值为True，否则为False。</p>
<p>可以通过改变位置属性来移动实体。但是，对于连续移动，建议使用movetoppoint方法。spaceID和vehicle分别受到teleport和boardVehicle方法的影响。</p>
<h4 id="5-1-6-5-Methods"><a href="#5-1-6-5-Methods" class="headerlink" title="5.1.6.5 Methods"></a><strong>5.1.6.5 Methods</strong></h4><p>与属性一样，方法也在实体类型的XML定义文件中定义(命名为&lt;res&gt;&#x2F;scripts&#x2F; entity_defs&#x2F;&lt;entity&gt;.def)。客户端方法、cell方法和base方法有不同的部分，每个方法都包含它的名称和参数列表。</p>
<p>单元格和基本方法也可以有一个可选的<Exposed/>标记。这表明客户端是否可以调用此方法。单元上的公开方法有一个隐式参数source，它是与调用该方法的客户机关联的实体的ID。</p>
<p>方法定义还可以具有一个<DetailDistance>属性，该属性用于与详细级别筛选相关。</p>
<h4 id="5-1-6-6-Calling-Clinet-methods"><a href="#5-1-6-6-Calling-Clinet-methods" class="headerlink" title="5.1.6.6 Calling Clinet methods"></a><strong>5.1.6.6 Calling Clinet methods</strong></h4><p>客户端引用其AoI中的所有实体。实体的cell组件可以调用存在于此AoI中的其他客户端实体(包括它自己的)的方法。<br>cell脚本有四个属性可用，以方便调用客户端方法。这些都是:</p>
<ul>
<li><strong>ownClient</strong></li>
<li><strong>otherClients</strong></li>
<li><strong>allClients</strong></li>
<li><strong>clientEntity</strong></li>
</ul>
<p>对这些对象之一调用的方法将被交付给指定的客户端。</p>
<p>例如，为这个对象在客户端脚本中调用chat方法，针对所有附近的客户端:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.allClients.chat( <span class="string">&quot;hi!&quot;</span> )</span><br></pre></td></tr></table></figure>

<h4 id="5-1-6-7-Built-Methods"><a href="#5-1-6-7-Built-Methods" class="headerlink" title="5.1.6.7 Built Methods"></a><strong>5.1.6.7 Built Methods</strong></h4><p>cell脚本可以访问许多内置的脚本方法，其中一些在下面的列表中描述:</p>
<ul>
<li><strong>destroy</strong> — 删除实体。</li>
<li><strong>addTimer</strong> — 添加异步计时器回调。</li>
<li><strong>moveToPoint</strong> — 将实体沿直线移动到一个点。</li>
<li><strong>moveToEntity</strong> — 将实体移向另一个实体。</li>
<li><strong>navigate</strong> — 将实体移向一个点，避开障碍。</li>
<li><strong>cancel</strong> — 取消控制器(计时器，移动等)。</li>
<li><strong>entitiesInRange</strong> — 查找与实体给定距离内的实体。</li>
</ul>
<h4 id="5-1-6-8-Controllers"><a href="#5-1-6-8-Controllers" class="headerlink" title="5.1.6.8 Controllers"></a><strong>5.1.6.8 Controllers</strong></h4><p>控制器是一个与单元实体相关联的c++对象。它通常执行的任务是低效的或难以通过脚本完成的。它通常也有状态信息，如果实体被卸载到另一个cell，这些信息必须通过网络发送。</p>
<p>目前实现的控制器的例子有:</p>
<ul>
<li>TimerController — 提供异步定时回调。</li>
<li>MoveToPointController — 以给定的速度将实体移动到一个位置。</li>
</ul>
<p>由于控制器通常异步执行操作，它们通过调用一个命名的脚本回调来通知脚本对象完成操作。例如，TimerController总是调用onTimer事件处理程序，而MoveToPointController总是调用onMove事件处理程序。</p>
<h4 id="5-1-6-9-Inheritance"><a href="#5-1-6-9-Inheritance" class="headerlink" title="5.1.6.9. Inheritance"></a><strong>5.1.6.9. Inheritance</strong></h4><p>一个实体类可以从另一个实体类派生。它接收基类的所有属性和方法，并添加自己的接口。.def文件中的&lt;Implements&gt;节可用于描述多个接口。</p>
<h4 id="5-1-6-10-Example-Script-File"><a href="#5-1-6-10-Example-Script-File" class="headerlink" title="5.1.6.10. Example Script File"></a><strong>5.1.6.10. Example Script File</strong></h4><p>下面是Seat对象的示例单元实体脚本文件:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;This module implements the Seat entity.&quot;</span></span><br><span class="line"><span class="keyword">import</span> BigWorld</span><br><span class="line"><span class="keyword">import</span> Avatar</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Seat</span>( BigWorld.Entity ):</span><br><span class="line">    <span class="string">&quot;A Seat entity.&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"> self </span>):</span><br><span class="line">        BigWorld.Entity.__init__( self )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sitDownRequest</span>(<span class="params"> self, source, entityID </span>):</span><br><span class="line">        <span class="keyword">if</span> self.ownerID == <span class="number">0</span> <span class="keyword">and</span> source == entityID:</span><br><span class="line">            self.ownerID = entityID</span><br><span class="line">            BigWorld.entities[ self.ownerID ].enterMode(Avatar.Avatar.MODE_SEATED, self.<span class="built_in">id</span>, <span class="number">0</span> )</span><br><span class="line">            <span class="keyword">if</span> self.channel:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    channel = BigWorld.entities[ self.channel ]</span><br><span class="line">                    channel.register( self.ownerID )</span><br><span class="line">                <span class="keyword">except</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getUpRequest</span>(<span class="params"> self, source, entityID </span>):</span><br><span class="line">        <span class="keyword">if</span> self.ownerID == entityID <span class="keyword">and</span> source == entityID:</span><br><span class="line">            <span class="keyword">if</span> self.channel:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                channel = BigWorld.entities[ self.channel ]</span><br><span class="line">                channel.deregister( entityID )</span><br><span class="line">                <span class="keyword">except</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            BigWorld.entities[ self.ownerID ].cancelMode()</span><br><span class="line">            <span class="comment"># The Avatar&#x27;s cancelMode() method will in-turn call this</span></span><br><span class="line">            <span class="comment"># Seat&#x27;s ownerNotSeated() method to release itself.</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">ownerNotSeated</span>(<span class="params"> self </span>):</span><br><span class="line">        self.ownerID = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">tableChat</span>(<span class="params"> self, msg </span>):</span><br><span class="line">        <span class="keyword">if</span> self.channel:</span><br><span class="line">            channel = BigWorld.entities[ self.channel ]</span><br><span class="line">            <span class="keyword">assert</span>( channel )</span><br><span class="line">            <span class="keyword">assert</span>( self.ownerID )</span><br><span class="line">            channel.tellOthers( self.ownerID, <span class="string">&quot;[local] &quot;</span> + msg )</span><br></pre></td></tr></table></figure>

<h3 id="5-1-7-Directed-Messages"><a href="#5-1-7-Directed-Messages" class="headerlink" title="5.1.7 Directed Messages"></a><strong>5.1.7 Directed Messages</strong></h3><p>并非所有事件都通过事件历史记录进行传播。如果某一事件是针对特定玩家或少数玩家，那么它便能够立即通过下一个包传达给玩家。</p>
<h3 id="5-1-8-Forwarding-From-Ghosts"><a href="#5-1-8-Forwarding-From-Ghosts" class="headerlink" title="5.1.8 Forwarding From Ghosts"></a><strong>5.1.8 Forwarding From Ghosts</strong></h3><p>每个“ghost”都知道它真正的cell，所以它可以把信息转发给它真正的cell进行处理。</p>
<p>消息分为两种形式：</p>
<ul>
<li>拉取式，大多数消息都是拉取式，比如当另一名玩家跳跃时——这是由角色(通过优先队列)决定是否以及何时发送给它的客户端。</li>
<li>推送式，少数信息是推送类型，如当玩家A想要与玩家握手时。</li>
</ul>
<h3 id="5-1-9-Offloading-Entities"><a href="#5-1-9-Offloading-Entities" class="headerlink" title="5.1.9. Offloading Entities"></a><strong>5.1.9. Offloading Entities</strong></h3><p>每个单元大约每秒钟检查一次是否将任何实体卸载给其他单元。根据当前单元格的边界来考虑每个实体。边界被人为地增加(约10米)，以避免滞后。如果发现一个实体在当前单元格的边界之外，它将被卸载到最合适的单元格。</p>
<h3 id="5-1-10-Adding-and-Removing-Cells"><a href="#5-1-10-Adding-and-Removing-Cells" class="headerlink" title="5.1.10. Adding and Removing Cells"></a><strong>5.1.10. Adding and Removing Cells</strong></h3><p>当一个cell在运行时被添加到一个大的多cell空间时，它是通过逐渐增加其面积来完成的，以避免试图改变单元的实体出现大的峰值。同样地，移除一个cell时，它的面积会慢慢减少，直到所有实体都消失。</p>
<h3 id="5-1-11-Load-Balancing"><a href="#5-1-11-Load-Balancing" class="headerlink" title="5.1.11. Load Balancing"></a><strong>5.1.11. Load Balancing</strong></h3><p>移动计算单元边界以调整单个计算单元负责的服务器负载比例。</p>
<p>基本的(简化的)想法是，如果一个cell与其他cell相比超载，那么它的面积就会减少。相反，如果它负载充足，那么它的面积就会增加。</p>
<h3 id="5-1-12-Physics"><a href="#5-1-12-Physics" class="headerlink" title="5.1.12. Physics"></a><strong>5.1.12. Physics</strong></h3><p>BigWorld只在客户端实现了实体到实体的碰撞检测系统，当客户端试图占用相同的空间时，它们会被撞到一边。当碰撞严重时，可以将此扩展到向服务器发送消息，例如，服务器可以检查情况并可能改变每个角色的位置&#x2F;速度。</p>
<h3 id="5-1-13-Navigation-System"><a href="#5-1-13-Navigation-System" class="headerlink" title="5.1.13. Navigation System"></a><strong>5.1.13. Navigation System</strong></h3><p>导航系统的主要特点是：</p>
<ul>
<li>分为室内和室外chunks</li>
<li>室内外无缝切换。</li>
<li>navpoly图的动态加载。</li>
<li>路径缓存，提高效率。</li>
</ul>
<h3 id="5-1-14-Range-Triggers-and-Range-Queries"><a href="#5-1-14-Range-Triggers-and-Range-Queries" class="headerlink" title="5.1.14. Range Triggers and Range Queries"></a><strong>5.1.14. Range Triggers and Range Queries</strong></h3><p>当(特定类型的)实体与另一个足够接近时，通常需要触发事件。<br>这些被称为范围触发器(Range Triggers)。</p>
<p>我们还需要找到特定区域中的所有实体。这被称为范围查询(Range Queries)。</p>
<p>为了支持这些功能，每个cell维护其所有实体的两个列表，按X和Z排序。</p>
<p>要执行范围查询，软件只搜索这些列表中的一个，直到查询范围的距离，然后几何地选择范围内的实体。</p>
<p>要执行范围触发器，对特定范围感兴趣的实体将在X和Z列表中插入高触发器和低触发器。当实体移动时，列表和触发器将被更新。当其他实体移动时，列表将被更新。如果一个实体跨越了一个触发器，或者一个触发器跨越了一个实体，那么软件将检查其他维度，以测试它是否真的是一个触发器事件。</p>
<h3 id="5-1-15-Fault-Tolerance"><a href="#5-1-15-Fault-Tolerance" class="headerlink" title="5.1.15. Fault Tolerance"></a><strong>5.1.15. Fault Tolerance</strong></h3><p>CellApp上的每个实体都会定期备份到其基本实体。如果CellApp不可用，CellAppMgr确保每个空间仍然有至少一个cell。基实体检测它们的单元实体是否丢失，并将它们恢复到它们空间的另一个单元。脚本方法可以确保恢复的实体与游戏世界保持一致。</p>
<h2 id="5-2-CellAppMgr"><a href="#5-2-CellAppMgr" class="headerlink" title="5.2 CellAppMgr"></a><strong>5.2 CellAppMgr</strong></h2><p>CellAppMgr主要负责：</p>
<ul>
<li>维护Cell之间的正确邻接。</li>
<li>向正确的cell中添加新的与角色相关联的实体。</li>
<li>充当全局实体ID代理。</li>
</ul>
<h3 id="5-2-1-CellApp-Registration"><a href="#5-2-1-CellApp-Registration" class="headerlink" title="5.2.1 CellApp Registration"></a><strong>5.2.1 CellApp Registration</strong></h3><p>当一个新的CellApp启动时，它通过向所有BWMachined daemon广播一条消息来找到CellAppMgr的位置。</p>
<p>类似地，当CellApp停止时，它会在CellAppMgr中注销自己，并逐渐删除所有的cell</p>
<h3 id="5-2-2-Load-Balancing"><a href="#5-2-2-Load-Balancing" class="headerlink" title="5.2.2 Load Balancing"></a><strong>5.2.2 Load Balancing</strong></h3><p>BigWorld动态平衡所有空间的单元负载，从小的单cell空间到潜在的大的多cell空间。</p>
<p>一个单元所覆盖的欧氏空间的大小是由它的CellApp所能支持的任何负载所决定的。这可能因CPU或实体密度而异。</p>
<h3 id="5-2-3-Adding-and-Removing-Cells"><a href="#5-2-3-Adding-and-Removing-Cells" class="headerlink" title="5.2.3 Adding and Removing Cells"></a><strong>5.2.3 Adding and Removing Cells</strong></h3><p>CellAppMgr的工作是根据CellApps当前的负载报告和它们正在管理的空间区域来划分空间。CellAppMgr使用这些信息来决定CellApp是否应该调整其职责范围，或者创建一个新的单元或删除一个现有的单元。无论结果如何，它都会与CellApp通信。</p>
<h3 id="5-2-4-Adding-an-Entity"><a href="#5-2-4-Adding-an-Entity" class="headerlink" title="5.2.4 Adding an Entity"></a><strong>5.2.4 Adding an Entity</strong></h3><p>CellAppMgr可以很容易地确定向哪个单元格添加新实体，因为它控制空间的镶嵌。</p>
<p>然而，一个新的单元实体通常会绕过CellAppMgr(从而减少它的负载)，如果它知道在同一空间中有另一个实体，就在它想要创建的地方附近。在这种情况下，它将简单地在现有实体的同一个CellApp上创建自己。</p>
<h3 id="5-2-5-Load-Balancing-for-Multiple-Spaces"><a href="#5-2-5-Load-Balancing-for-Multiple-Spaces" class="headerlink" title="5.2.5 Load Balancing for Multiple Spaces"></a><strong>5.2.5 Load Balancing for Multiple Spaces</strong></h3><p>在多个空间的情况下，BigWorld使用一种最优拟合的单一算法，从大到小，动态地、连续地平衡它们的负载。</p>
<p>该算法的基本目标是为每个空间分配足够的处理能力，并将每个处理分配到尽可能少的CellApps(机器)。如果一个空间必须分布在多台机器上，则使用一种算法将该空间分解为多个单元</p>
<h3 id="5-2-6-Fault-Tolerance"><a href="#5-2-6-Fault-Tolerance" class="headerlink" title="5.2.6 Fault Tolerance"></a><strong>5.2.6 Fault Tolerance</strong></h3><p>如果失败，一个Reviver将重新启动CellAppMgr。它会找到所有的cellapp，并向它们查询它们的细胞和它们所覆盖的区域。</p>
<p>从这一点开始，它可以继续维护cell、CellApps和空间，并能够向正确的cell格添加新实体。通过从存储的检查点或cell维护的ID范围恢复数据，它可以继续扮演空间ID和实体ID代理的角色。</p>
<h2 id="5-3-BaseApp"><a href="#5-3-BaseApp" class="headerlink" title="5.3 BaseApp"></a><strong>5.3 BaseApp</strong></h2><p>BaseApp管理实体bases和代理。代理是实体基础的专门化。<br><img src="/image/bigworld/04_06.png" alt="图片"></p>
<h3 id="5-3-1-Proxies"><a href="#5-3-1-Proxies" class="headerlink" title="5.3.1 Proxies"></a><strong>5.3.1 Proxies</strong></h3><p>当一个玩家登录到服务器上时，一个代理在一个BaseApp上创建，它可能决定在CellApp上的一个单元中创建一个实体。BaseAppMgr在最少加载的BaseApp上创建代理。</p>
<p>当客户端希望向cell上的实体发送消息时，它首先将消息发送给proxies，然后proxies将消息转发给cell。这将客户端与cell开关隔离开来。为了实现这一点，proxies需要知道它的关联实体所在的CellApp的地址。每当cell实体更改CellApps时，它都会与proxies通信。</p>
<p>单元实体还通过关联的代理与其客户端通信。此方法的主要好处是允许代理负责处理消息可靠性。其他好处包括屏蔽CellApps直接与互联网通话，以及限制客户端接收数据的地址。</p>
<p>代理还可以聚合来自多个源的消息，并将它们作为一个包传递给客户机。</p>
<h3 id="5-3-2-Bases"><a href="#5-3-2-Bases" class="headerlink" title="5.3.2 Bases"></a><strong>5.3.2 Bases</strong></h3><p>Base具有以下特点:</p>
<ol>
<li><p>Base可以存储不需要在cell上移动的实体属性–一个很好的例子是在base上存储玩家的库存，在cell上存储活动物品。</p>
</li>
<li><p>当cell实体(或任何其他服务器对象)不知道实体当前在哪个cell上时，它可以与base实体通信。base充当锚点。</p>
</li>
<li><p>一些属性被更有效地保存在base上，因为它们被“远程”对象访问(或订阅)。</p>
</li>
<li><p>团队聊天系统就是一个很好的例子。</p>
</li>
<li><p>base可以是一个没有位置感的实体，例如控制世界事件的实体。</p>
</li>
</ol>
<p>代理是一种特殊类型的base。它有一个相关联的客户端，并控制进出该客户端的消息。</p>
<p>与cell上的实体一样，base也有一个与之相关联的脚本。因此，可以只在脚本中实现不同的base类型。一个典型的例子是群聊系统。</p>
<h3 id="5-3-3-Fault-Tolerance"><a href="#5-3-3-Fault-Tolerance" class="headerlink" title="5.3.3 Fault Tolerance"></a><strong>5.3.3 Fault Tolerance</strong></h3><p>BaseApp支持一个容错方案，每个BaseApp都将自己的实体备份到其他(不止一个)常规BaseApp上。</p>
<p>每个BaseApp都通过许多其他真正的BaseApp来备份它的实体。每个BaseApp都被分配一组其他的BaseApp和一个从实体ID到这些备份的哈希函数。</p>
<p>如果一个BaseApp死亡，它的每个实体都会在备份它的BaseApp上恢复。<br><img src="/image/bigworld/04_07.png" alt="图片"></p>
<p>此外，任何附加的客户机将在意外的BaseApp故障时断开连接，需要重新登录。</p>
<p>但是，如果BaseApp已经撤离，那么附加的客户端会迁移到另一个运行的BaseApp上。</p>
<h3 id="5-3-4-Secondary-Databases"><a href="#5-3-4-Secondary-Databases" class="headerlink" title="5.3.4 Secondary Databases"></a><strong>5.3.4 Secondary Databases</strong></h3><p>为了减少主数据库和DBMgr上的负载，BaseApp将持久数据临时存储在本地磁盘上的辅助数据库中。当实体处于活动状态时，对实体持久数据的更改只存储在辅助数据库中。当实体被卸载时，它的持久数据将从辅助数据库传输到主数据库。</p>
<h2 id="5-4-BaseAppMgr"><a href="#5-4-BaseAppMgr" class="headerlink" title="5.4 BaseAppMgr"></a><strong>5.4 BaseAppMgr</strong></h2><h3 id="5-4-1-Implementation"><a href="#5-4-1-Implementation" class="headerlink" title="5.4.1 Implementation"></a><strong>5.4.1 Implementation</strong></h3><p>当一个BaseApp启动时，它将自己注册到BaseAppMgr中。BaseAppMgr维护所有BaseApps的列表。</p>
<h3 id="5-4-2-Logging-In"><a href="#5-4-2-Logging-In" class="headerlink" title="5.4.2 Logging In"></a><strong>5.4.2 Logging In</strong></h3><p>当客户端登录时，LoginApp向BaseAppMgr发出一个请求(通过DBMgr)，以向系统添加一个播放器。然后BaseAppMgr将一个代理添加到最少加载的BaseApp中。BaseAppMgr将代理的IP地址发送给LoginApp。它被发送给客户端，然后客户端使用它与服务器进行所有未来的通信。</p>
<h3 id="5-4-3-Fault-Tolerance"><a href="#5-4-3-Fault-Tolerance" class="headerlink" title="5.4.3 Fault Tolerance"></a><strong>5.4.3 Fault Tolerance</strong></h3><p>在失败的情况下，一个Reviver会重启BaseAppMgr。BaseApps重新注册到BaseAppMgr，允许它正常继续。</p>
<h2 id="5-5-ServiceApp"><a href="#5-5-ServiceApp" class="headerlink" title="5.5 ServiceApp"></a><strong>5.5 ServiceApp</strong></h2><p>ServiceApp是一个专用的BaseApp，用于运行服务而不是Base实体。</p>
<p>分离服务和基础实体的处理在BaseApps在ServiceApp崩溃的情况下完全不受影响。</p>
<p>ServiceApp可执行文件实际上是一个连接到BaseApp二进制文件。它只是让BaseApp以不同的模式运行。默认情况下，基本实体不会在ServiceApps上创建。</p>
<h3 id="5-5-1-Services"><a href="#5-5-1-Services" class="headerlink" title="5.5.1 Services"></a><strong>5.5.1 Services</strong></h3><p>一个service是一个脚本化的对象，类似于Base-only实体。与基本实体不同，它们没有属性。</p>
<h3 id="5-5-2-Examples-of-Services"><a href="#5-5-2-Examples-of-Services" class="headerlink" title="5.5.2 Examples of Services"></a><strong>5.5.2 Examples of Services</strong></h3><p>服务是实现功能的理想选择，否则这些功能可能由单一的基础实体实现。通常，它们用于将服务器与外部服务集成。例如，服务可以创建为:</p>
<ul>
<li>为服务器提供HTTP web服务接口。这将允许外部服务(如网站)能够调用游戏实体。</li>
<li>允许游戏脚本访问外部web服务</li>
<li>允许游戏脚本访问外部数据库</li>
</ul>
<h3 id="5-5-3-Starting-services"><a href="#5-5-3-Starting-services" class="headerlink" title="5.5.3 Starting services"></a><strong>5.5.3 Starting services</strong></h3><p>默认情况下，每个ServiceApp上都启动一个Service片段。也就是说，每个服务自动分布在所有可能的ServiceApps上。</p>
<h2 id="5-6-LoginApp"><a href="#5-6-LoginApp" class="headerlink" title="5.6. LoginApp"></a><strong>5.6. LoginApp</strong></h2><h3 id="5-6-1-Implementation"><a href="#5-6-1-Implementation" class="headerlink" title="5.6.1. Implementation"></a><strong>5.6.1. Implementation</strong></h3><p>每个LoginApp侦听一个固定的(可配置的)端口，用于从客户端登录请求。</p>
<p>登录细节查看<a href="#4.3.2_Logging_In">4.3.2 Logging in</a></p>
<p>LoginApp发出的所有请求都是非阻塞的，因此它可以处理许多同时进行的登录。</p>
<h3 id="5-6-2-Multiple-LoginApps"><a href="#5-6-2-Multiple-LoginApps" class="headerlink" title="5.6.2 Multiple LoginApps"></a><strong>5.6.2 Multiple LoginApps</strong></h3><p>就负载而言，一个LoginApp应该足以满足大多数目的。然而，由于这仍然是一个潜在的瓶颈和单点故障，BigWorld支持运行多个LoginApps。</p>
<p>剩下的问题是如何跨多个登录服务器分发客户机登录请求。标准的方法是使用DNS解决方案，类似于流行的网站在多台机器上平衡流量负载的方式。</p>
<h2 id="5-7-DBMgr"><a href="#5-7-DBMgr" class="headerlink" title="5.7 DBMgr"></a><strong>5.7 DBMgr</strong></h2><p>DBMgr是主数据库的接口。目前有两种数据库接口组件的实现:</p>
<ul>
<li>XML</li>
<li>MySQL</li>
</ul>
<p>还可以添加其他参数。</p>
<h3 id="5-7-1-XML"><a href="#5-7-1-XML" class="headerlink" title="5.7.1 XML"></a><strong>5.7.1 XML</strong></h3><p>XML实现将数据保存在单个XML文件中—<res>&#x2F;scripts&#x2F;db.xml。这很适合运行小型服务器，因为它是轻量级的，并且不依赖于外部数据库。</p>
<p>在这个实现中，DBMgr在启动时读取XML文件，并将所有的球员描述缓存到内存中。在关闭之前不会执行磁盘I&#x2F;O，关闭时将整个XML文件写入磁盘。</p>
<p>XML数据库有几个已知的限制，使得它不适合生产环境或重度的开发环境。</p>
<h3 id="5-7-2-MySQL"><a href="#5-7-2-MySQL" class="headerlink" title="5.7.2 MySQL"></a><strong>5.7.2 MySQL</strong></h3><p>MySQL实现通过本地MySQL接口与MySQL数据库通信。MySQL可以运行在同一台机器上，也可以运行在不同的机器上，因为该协议是通过TCP运行的。</p>
<p>实体的每个类都存储在一个单独的SQL表中，类的每个属性都是一个列。这些表由 DatabaseIDs建立索引。</p>
<p>在启动时，将根据XML实体定义文件(命名为<res>&#x2F; scripts&#x2F;entity_defs&#x2F;<entity>.def)检查SQL数据库模式，以确保它们是一致的。</p>
<p>如果任何实体类没有数据库表，那么将自动创建一个数据库表。如果XML文件中有任何类的新属性不在数据库中，那么列将自动添加到适当的表中。这个功能在开发过程中非常有用，因为在开发过程中模式可能会频繁变化。</p>
<h3 id="5-7-3-Fault-Tolerance"><a href="#5-7-3-Fault-Tolerance" class="headerlink" title="5.7.3 Fault Tolerance"></a><strong>5.7.3 Fault Tolerance</strong></h3><p>在失败的情况下，DBMgr可以通过Reviver重新启动，它可能在不同的物理机器上。一旦DBMgr重新启动，它就会通过BWMachined发布它的存在，然后所有感兴趣的参与者将开始与它通信。</p>
<p>XML数据库不具有容错性，因为所有数据在关闭之前都保存在RAM中。</p>
<h2 id="5-8-Reviver"><a href="#5-8-Reviver" class="headerlink" title="5.8 Reviver"></a><strong>5.8 Reviver</strong></h2><p>Reviver是一个监控进程，用于重新启动其他失败的进程。Reviver在为容错目的而保留的机器上启动，并等待进程将自己附加到它。</p>
<p>使用Reviver的进程包括:</p>
<ul>
<li>CellAppMgr</li>
<li>BaseAppMgr</li>
<li>DBMgr</li>
<li>LoginApp</li>
</ul>
<p>当每个进程启动时，它会在网络中搜索一个Reviver，然后附加它自己-如果它是由Reviver支持的(这个配置是通过&#x2F;etc&#x2F;bwmachine .conf完成的)</p>
<p>Reviver会定期ping这个进程，检查它是否可用——如果它没有回复，Reviver会作为失败的进程重新启动自己，替换进程和机器。然后可以关闭故障机器&#x2F;进程以进行服务。</p>
<p>由于Revivers通常会在恢复进程后停止运行，所以通常需要几个(最好是在不同的机器上)。Revivers使用BWMachined来启动新进程。</p>
<p>如果一个Reviver崩溃了，那么请求监控的进程将检测到丢失的ping，并寻找新的Reviver。由操作员来确保在适当的机器上运行足够的Revivers。</p>
<h2 id="5-9-BWMachined"><a href="#5-9-BWMachined" class="headerlink" title="5.9 BWMachined"></a><strong>5.9 BWMachined</strong></h2><p>BWMachined进程在服务器集群中的每台机器上运行，并在启动时自动启动。其职责是:</p>
<ul>
<li>启动和停止服务器组件。</li>
<li>定位服务器组件。</li>
<li>提供机器统计数据(CPU速度，网络统计等)。</li>
<li>提供进程统计信息(内存和CPU使用率)。</li>
</ul>
<p>下面的小节描述了每一项职责。</p>
<h3 id="5-9-1-Start-and-Stop-Server-Components"><a href="#5-9-1-Start-and-Stop-Server-Components" class="headerlink" title="5.9.1. Start and Stop Server Components"></a><strong>5.9.1. Start and Stop Server Components</strong></h3><p>BWMachined可以使用任何用户ID启动组件，也可以指定应该使用哪个构建配置(Debug、Hybrid或Release)。</p>
<p>因为不是所有用户都有自己的服务器构建，所以可以根据每个用户指定要使用的服务器二进制文件的位置。这可以在$HOME&#x2F;.bwmachined.conf文件中完成，也可以在&#x2F;etc&#x2F;bwmachined.conf文件中完成。</p>
<h3 id="5-9-2-Locate-Server-Components"><a href="#5-9-2-Locate-Server-Components" class="headerlink" title="5.9.2. Locate Server Components"></a><strong>5.9.2. Locate Server Components</strong></h3><p>当一个服务器组件启动时，它可以选择公开它的Mercury接口。如果是这样，Mercury将向本地机器上的BWMachined发送一个注册包。</p>
<p>下面的列表描述了数据包中包含的字段:</p>
<ul>
<li>UID - User ID</li>
<li>PID - Process ID</li>
<li>Name - Name(例如： CellAppMgr)</li>
<li>ID - 可选的唯一ID</li>
</ul>
<p>BWMachined会将该进程添加到它的注册进程列表中。它每秒钟轮询&#x2F;proc文件系统，以确定每个进程的CPU和内存使用情况。</p>
<p>当一个公开的服务器组件关闭时，它必须向本地BWMachined发送一个注销报文。如果一个进程在没有注销注册的情况下死亡，BWMachined会发现这一点，当它下次轮询和更新它的已知组件列表。</p>
<p>可以通过发送一个查询包到BWMachined来搜索匹配某些字段的服务器组件。它将通过对每个匹配过程发送一个响应包来进行响应。</p>
<p>例如，当一个CellApp启动时，它需要找到当前UID下运行的CellAppMgr进程的地址。它向网络上的每个BWMachined发送一个广播查询，请求所有与当前UID匹配的进程，以及名称“CellAppMgr”。</p>
<h3 id="5-9-3-Provide-Machine-Statistics"><a href="#5-9-3-Provide-Machine-Statistics" class="headerlink" title="5.9.3. Provide Machine Statistics"></a><strong>5.9.3. Provide Machine Statistics</strong></h3><p>在启动时，BWMachined检查&#x2F;proc&#x2F;cpuinfo文件，以确定cpu的数量和它们的速度。它还定期监控整个机器的CPU、内存和网络使用情况。这些信息可以通过UDP请求获得，并显示在WebConsole的StatGrapher组件中。</p>
<h3 id="5-9-4-Provide-Process-Statistics"><a href="#5-9-4-Provide-Process-Statistics" class="headerlink" title="5.9.4. Provide Process Statistics"></a><strong>5.9.4. Provide Process Statistics</strong></h3><p>BWMachined每秒轮询&#x2F;proc文件系统，并收集所有注册进程的内存和CPU统计信息。这些信息可以通过UDP请求获得，并显示在WebConsole的StatGrapher组件中。</p>
<h3 id="5-9-5-BWMachined-Interface-Discovery"><a href="#5-9-5-BWMachined-Interface-Discovery" class="headerlink" title="5.9.5. BWMachined Interface Discovery"></a><strong>5.9.5. BWMachined Interface Discovery</strong></h3><p>为了帮助对错误配置的缺省广播地址进行错误检测，减少所需的配置量，BWMachined会在启动时确定哪个接口被配置为缺省广播路由。</p>
<p>如果bw.xml配置文件中没有定义&lt;internalInterface&gt;标记，则服务器组件将通过本地主机接口查询BWMachined，并请求该接口作为内部接口使用。</p>
<p>如果&lt;monitoringInterface&gt; tag在bw.xml中未定义，,然后MessageLogger将向BWMachined查询内部接口，而任何服务器组件将恢复使用它们在启动期间已经发现的内部接口来监视接口。</p>
<p>&lt;internalInterface&gt;标记已弃用，虽然它们的行为仍与以前的版本一致，但建议不要使用它们。</p>
<h2 id="6-Other-Features"><a href="#6-Other-Features" class="headerlink" title="6. Other Features"></a><strong>6. Other Features</strong></h2><h2 id="6-1-IDs"><a href="#6-1-IDs" class="headerlink" title="6.1. IDs"></a><strong>6.1. IDs</strong></h2><p>无论何时CellApp创建一个新的实体，它都需要一个唯一的实体ID，需要一个ID代理或签发服务。CellAppMgr目前提供了这个功能。</p>
<h3 id="6-1-1-ID-Allocation"><a href="#6-1-1-ID-Allocation" class="headerlink" title="6.1.1. ID Allocation"></a><strong>6.1.1. ID Allocation</strong></h3><p>CellAppMgr目前充当ID的中央ID代理。它处理一个id块的请求，并允许将未使用的id返回“回收”。</p>
<p>如果CellAppMgr在崩溃后由Reviver重新启动，那么它将通过查询单元当前使用的最高ID来恢复其状态。序列将从最高的ID重新开始，添加一个。在失败的情况下，少量的id可能会被浪费。</p>
<p>多余的未使用id存储在特殊的表bigworldNewID和bigworldUsedIDs中。</p>
<h2 id="6-2-Inter-Process-Communication-Mercury"><a href="#6-2-Inter-Process-Communication-Mercury" class="headerlink" title="6.2. Inter-Process Communication (Mercury)"></a><strong>6.2. Inter-Process Communication (Mercury)</strong></h2><h3 id="6-2-1-Overview"><a href="#6-2-1-Overview" class="headerlink" title="6.2.1. Overview"></a><strong>6.2.1. Overview</strong></h3><p>Mercury是用于客户端和服务器之间以及所有服务器组件之间通信的网络层。它基于UDP，允许可靠和不可靠的通信。</p>
<h3 id="6-2-2-Nub"><a href="#6-2-2-Nub" class="headerlink" title="6.2.2 Nub"></a><strong>6.2.2 Nub</strong></h3><p>Nub是Mercury的核心。它负责发送和接收数据包，发送时间消息，和通用的socket通知。</p>
<p>BigWorld所有的通信使用UDP协议，因此对所有的连接使用一个单一的的socket，这远比对每个连接使用一个socket高效，在大量的socket上调用select是很缓慢的。</p>
<p>Nub通常控制应用程序的事件循环，因此它也提供一个时间队列和用户套接字通知。时间队列用于周期性的调用回调函数，或者在时间结束后调用一个单一的回调。当用户套接字准备好读取数据时，能用于监听和调用回调函数。</p>
<h3 id="6-2-3-Messages"><a href="#6-2-3-Messages" class="headerlink" title="6.2.3. Messages"></a><strong>6.2.3. Messages</strong></h3><p>消息（Message）是通信的基本单元。它包括：</p>
<ul>
<li>消息类型 …. 1byte.</li>
<li>消息大小 …. 0-4 bytes.</li>
<li>消息数据 …. 可变大小.</li>
</ul>
<p>对于固定长度的消息，不需要消息大小。消息数据只是由客户机和服务器解释的字节流（stream of bytes）。为方便编组，大多数数据类型都提供了流操作符。</p>
<h3 id="6-2-4-Requests"><a href="#6-2-4-Requests" class="headerlink" title="6.2.4. Requests"></a><strong>6.2.4. Requests</strong></h3><p>一个请求是一个期望应答的消息。可以发出一个请求给客户端，并在没有阻塞进程运行的情况下接收一个和它相关联的回复。本质上，Mercury将分配一个唯一的请求ID，用于和请求的回复关联。当请求发出，一个回复的处理也会被创建。它也处理超时，如果没有在定义好的时间内收到应答会调用一个超时回调。</p>
<h3 id="6-2-5-Bundles"><a href="#6-2-5-Bundles" class="headerlink" title="6.2.5. Bundles"></a><strong>6.2.5. Bundles</strong></h3><p>Bundle是作为一个单元被发送和接收的消息的集合。把多个消息组合起成一个单一的数据包减少了UDP的包头开销（overhead）。如果一个bundle超过了包的最大尺寸，它将被分割成多个包，在它被接收到时重新装配。</p>
<p>每个在bundle中的消息包都可选额外数据，包括队列数量，请求ID和确认ID。</p>
<h3 id="6-2-6-Channels"><a href="#6-2-6-Channels" class="headerlink" title="6.2.6. Channels"></a><strong>6.2.6. Channels</strong></h3><p>通道用于提供两个Nub之间的可靠通信。通道可能有不同的特征，这取决于它是客户机&#x2F;服务器通道还是服务器&#x2F;服务器通道，以及它连接的组件之间。<br>下表描述了一些通道的特征:</p>
<table>
<thead>
<tr>
<th>Channel</th>
<th>Latency</th>
<th>Bandwidth</th>
<th>Loss</th>
</tr>
</thead>
<tbody><tr>
<td>Client&#x2F;server</td>
<td>High</td>
<td>Low</td>
<td>High</td>
</tr>
<tr>
<td>Server&#x2F;server</td>
<td>Low</td>
<td>High</td>
<td>Low</td>
</tr>
</tbody></table>
<p>一个通道的特性可以在创建时指定，这样可以正确的选择它的可靠算法。</p>
<p>如果数据包中的消息被标记为可靠，那么整个数据包也会被视为可靠。发送者会给它分配一个队列数字并存储到滑动窗口。一旦接收者收到数据包会马上确认，会放置一个ACK到下一个发出的数据包。通道会被假定为定期的双向通信(10Hz for client&#x2F;server, 50Hz for server&#x2F;server)不会立即发送ACK，而其他没有常规通信的信道会立即发送ACK。</p>
<p>如果接收到一个乱序的ACK包，它会假定前序包丢失了，会重新发送。在低延迟的情况下，存在一个阈值，在一个确定的时间内哪些包在它们第一次发送后将不会被重新发送。</p>
<p>低带宽(low‐bandwidth)的连接中(client&#x2F;server)，所有不可靠的消息在重新发送之前都会被从数据包剥离，为了节省带宽，如果可能，这个数据包会携带下一个准备发出的数据包。</p>
<h3 id="6-2-7-Interfaces"><a href="#6-2-7-Interfaces" class="headerlink" title="6.2.7. Interfaces"></a><strong>6.2.7. Interfaces</strong></h3><p>从Nub接收的消息会被单个接口处理。因为消息类型是单一的字节，一个接口的限制能达到256个消息（实际上会稍微小一点，因为Mercury保留了一些内部使用信息）。</p>
<p>接口通常被使用宏定义在 src&#x2F;lib&#x2F;network&#x2F;interface_minder.hpp。这样的设计是为了隐藏消息解码的调用细节和调度(dispatching)。对于简单的固定长度消息，结构包含了消息参数，结果是一个对象的方法被调用。对于更复杂的可变长度消息，参须必须手动解析字节流，结果是一个stream对象和方法被调用。</p>
<p>接口也定义消息是否是可变的还是固定长度的。对于固定长度消息，不需要发送长度数据，因为接收者知道有多少字节。</p>
<h2 id="6-3-Fault-Tolerance-and-Disaster-Recovery"><a href="#6-3-Fault-Tolerance-and-Disaster-Recovery" class="headerlink" title="6.3. Fault Tolerance and Disaster Recovery"></a><strong>6.3. Fault Tolerance and Disaster Recovery</strong></h2><p>服务器的每个组件都被设计为容错。任何服务器进程或机器都可能意外死亡，服务器应该继续运行，而不会受到什么影响。</p>
<p>BigWorld服务器还提供了第二级容错功能，称为灾难恢复。可以定期将服务器的状态写入数据库。在整个服务器故障的情况下，可以使用此信息重新启动服务器。</p>
<h2 id="6-4-Packed-Files"><a href="#6-4-Packed-Files" class="headerlink" title="6.4. Packed Files"></a><strong>6.4. Packed Files</strong></h2><p>XML文件因为它的灵活性和易用性而被引擎使用，XML文件也被广泛认为很臃肿，当在一个电脑游戏中使用，很容易被终端用户修改。文件打包是把XML文件转换为压缩的二进制格式。当需要一个XML文件时，客户端和所有的服务端组件都能加载被打包文件。使用打包文件取代XML文件提高了性能，这在一定程度上的混淆也可以阻止一般用户修改文件内容。</p>
<p>打包文件是只读的并不适用于开发中。因为它的只读属性，大多数工具（无论是在客户端还是服务端）无法使用打包文件。</p>
<p><a target="_blank" rel="noopener" href="https://imgamer.gitbooks.io/kbengine-overview/content/">参考</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">华</span>
</div>
  <div class="powered-by">
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
